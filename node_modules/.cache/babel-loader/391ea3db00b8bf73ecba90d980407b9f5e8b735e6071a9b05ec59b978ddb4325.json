{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */function (_super) {\n  __extends(LineCrosshair, _super);\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: Math.PI * 3 / 2\n    });\n  };\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var position = this.get('text').position;\n    var tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  };\n  LineCrosshair.prototype.getTextPoint = function () {\n    var text = this.get('text');\n    var position = text.position,\n      offset = text.offset;\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var angle = position === 'start' ? startAngle : endAngle;\n    var tangentAngle = this.getRotateAngle() - Math.PI;\n    var point = getCirclePoint(center, radius, angle);\n    // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n    var offsetX = Math.cos(tangentAngle) * offset;\n    var offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY\n    };\n  };\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n      center = _a.center,\n      radius = _a.radius,\n      startAngle = _a.startAngle,\n      endAngle = _a.endAngle;\n    var path = null;\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      var x = center.x,\n        y = center.y;\n      path = [['M', x, y - radius], ['A', radius, radius, 0, 1, 1, x, y + radius], ['A', radius, radius, 0, 1, 1, x, y - radius], ['Z']];\n    } else {\n      var startPoint = getCirclePoint(center, radius, startAngle);\n      var endPoint = getCirclePoint(center, radius, endAngle);\n      var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      var sweep = startAngle > endAngle ? 0 : 1;\n      path = [['M', startPoint.x, startPoint.y], ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y]];\n    }\n    return path;\n  };\n  return LineCrosshair;\n}(CrosshairBase);\nexport default LineCrosshair;","map":{"version":3,"mappings":"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","names":["getCirclePoint","CrosshairBase","__extends","LineCrosshair","cfg","_super","getDefaultCfg","type","locationType","center","radius","startAngle","Math","PI","endAngle","getLocation","get","tangentAngle","position","text","offset","angle","getRotateAngle","point","offsetX","cos","offsetY","sin","x","y","path","startPoint","endPoint","large","abs","sweep"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/component/src/crosshair/circle.ts"],"sourcesContent":["import { ILocation } from '../interfaces';\nimport { CircleCrosshairCfg, CircleLocationCfg, Point } from '../types';\nimport { getCirclePoint } from '../util/util';\nimport CrosshairBase from './base';\n\nclass LineCrosshair extends CrosshairBase<CircleCrosshairCfg> implements ILocation<CircleLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'circle',\n      locationType: 'circle',\n      center: null,\n      radius: 100,\n      startAngle: -Math.PI / 2,\n      endAngle: (Math.PI * 3) / 2,\n    };\n  }\n\n  protected getRotateAngle(): number {\n    const { startAngle, endAngle } = this.getLocation();\n    const { position } = this.get('text');\n    const tangentAngle = position === 'start' ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;\n    return tangentAngle;\n  }\n\n  protected getTextPoint(): Point {\n    const text = this.get('text');\n    const { position, offset } = text;\n    const { center, radius, startAngle, endAngle } = this.getLocation();\n    const angle = position === 'start' ? startAngle : endAngle;\n    const tangentAngle = this.getRotateAngle() - Math.PI;\n    const point = getCirclePoint(center, radius, angle);\n    // 这个地方其实应该求切线向量然后在乘以 offset，但是太啰嗦了，直接给出结果\n    // const tangent = [Math.cos(tangentAngle), Math.sin(tangentAngle)];\n    // const offsetVector = vec2.scale([], tangent, offset);\n    const offsetX = Math.cos(tangentAngle) * offset;\n    const offsetY = Math.sin(tangentAngle) * offset;\n    return {\n      x: point.x + offsetX,\n      y: point.y + offsetY,\n    };\n  }\n\n  protected getLinePath(): any[] {\n    const { center, radius, startAngle, endAngle } = this.getLocation();\n    let path = null;\n    if (endAngle - startAngle === Math.PI * 2) {\n      // 整圆\n      const { x, y } = center;\n      path = [\n        ['M', x, y - radius],\n        ['A', radius, radius, 0, 1, 1, x, y + radius],\n        ['A', radius, radius, 0, 1, 1, x, y - radius],\n        ['Z'],\n      ];\n    } else {\n      const startPoint = getCirclePoint(center, radius, startAngle);\n      const endPoint = getCirclePoint(center, radius, endAngle);\n      const large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;\n      const sweep = startAngle > endAngle ? 0 : 1;\n      path = [\n        ['M', startPoint.x, startPoint.y],\n        ['A', radius, radius, 0, large, sweep, endPoint.x, endPoint.y],\n      ];\n    }\n    return path;\n  }\n}\n\nexport default LineCrosshair;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}