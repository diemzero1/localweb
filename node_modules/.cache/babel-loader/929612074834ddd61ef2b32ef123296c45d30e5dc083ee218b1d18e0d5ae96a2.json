{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../util\");\nvar sort = function sort(entries, biasRight, usePrev) {\n  var parts = (0, util_1.partition)(entries, function (entry) {\n    // NOTE: 有fixorder的也可以排\n    return entry.hasOwnProperty(\"fixorder\") && !isNaN(entry.fixorder) || entry.hasOwnProperty(\"barycenter\");\n  });\n  var sortable = parts.lhs;\n  var unsortable = parts.rhs.sort(function (a, b) {\n    return -a.i - -b.i;\n  });\n  var vs = [];\n  var sum = 0;\n  var weight = 0;\n  var vsIndex = 0;\n  sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  sortable === null || sortable === void 0 ? void 0 : sortable.forEach(function (entry) {\n    var _a;\n    vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter * entry.weight;\n    weight += entry.weight;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n  var result = {\n    vs: vs.flat()\n  };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n};\nvar consumeUnsortable = function consumeUnsortable(vs, unsortable, index) {\n  var iindex = index;\n  var last;\n  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {\n    unsortable.pop();\n    vs === null || vs === void 0 ? void 0 : vs.push(last.vs);\n    iindex++;\n  }\n  return iindex;\n};\n/**\n * 配置是否考虑使用之前的布局结果\n */\nvar compareWithBias = function compareWithBias(bias, usePrev) {\n  return function (entryV, entryW) {\n    // 排序的时候先判断fixorder，不行再判断重心\n    if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {\n      return entryV.fixorder - entryW.fixorder;\n    }\n    if (entryV.barycenter < entryW.barycenter) {\n      return -1;\n    }\n    if (entryV.barycenter > entryW.barycenter) {\n      return 1;\n    }\n    // 重心相同，考虑之前排好的顺序\n    if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {\n      if (entryV.order < entryW.order) {\n        return -1;\n      }\n      if (entryV.order > entryW.order) {\n        return 1;\n      }\n    }\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n};\nexports.default = sort;","map":{"version":3,"mappings":"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","names":["sort","entries","biasRight","usePrev","parts","entry","hasOwnProperty","isNaN","fixorder","sortable","lhs","unsortable","rhs","a","b","i","vs","sum","weight","vsIndex","compareWithBias","consumeUnsortable","forEach","length","push","barycenter","result","flat","index","iindex","last","pop","bias","entryV","entryW","undefined","order","exports"],"sources":["/home/iam/Documents/network/node_modules/@antv/layout/src/layout/dagre/src/order/sort.ts"],"sourcesContent":["import { partition } from \"../util\";\nimport { ConflictEntry } from \"./resolve-conflicts\";\n\nconst sort = (entries: ConflictEntry[], biasRight?: boolean, usePrev?: boolean) => {\n  const parts = partition(entries, (entry) => {\n    // NOTE: 有fixorder的也可以排\n    return (entry.hasOwnProperty(\"fixorder\") && !isNaN(entry.fixorder!)) || entry.hasOwnProperty(\"barycenter\");\n  });\n  const sortable = parts.lhs;\n  const unsortable = parts.rhs.sort((a, b) => -a.i - (-b.i));\n  const vs: string[][] = [];\n  let sum = 0;\n  let weight = 0;\n  let vsIndex = 0;\n\n  sortable?.sort(compareWithBias(!!biasRight, !!usePrev));\n\n  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n\n  sortable?.forEach((entry) => {\n    vsIndex += entry.vs?.length;\n    vs.push(entry.vs);\n    sum += entry.barycenter! * entry.weight!;\n    weight += entry.weight!;\n    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);\n  });\n\n  const result: { vs: string[], barycenter?: number, weight?: number } = { vs: vs.flat() };\n  if (weight) {\n    result.barycenter = sum / weight;\n    result.weight = weight;\n  }\n  return result;\n};\n\nconst consumeUnsortable = (vs: string[][], unsortable: ConflictEntry[], index: number) => {\n  let iindex = index;\n  let last;\n  while (unsortable.length && (last = unsortable[unsortable.length - 1]).i <= iindex) {\n    unsortable.pop();\n    vs?.push(last.vs);\n    iindex++;\n  }\n  return iindex;\n};\n\n/**\n * 配置是否考虑使用之前的布局结果\n */\nconst compareWithBias = (bias: boolean, usePrev: boolean) => {\n  return (entryV: ConflictEntry, entryW: ConflictEntry) => {\n    // 排序的时候先判断fixorder，不行再判断重心\n    if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {\n      return entryV.fixorder - entryW.fixorder;\n    }\n    if (entryV.barycenter! < entryW.barycenter!) {\n      return -1;\n    }\n    if (entryV.barycenter! > entryW.barycenter!) {\n      return 1;\n    }\n    // 重心相同，考虑之前排好的顺序\n    if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {\n      if (entryV.order < entryW.order) {\n        return -1;\n      }\n      if (entryV.order > entryW.order) {\n        return 1;\n      }\n    }\n\n    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;\n  };\n};\n\nexport default sort;"]},"metadata":{},"sourceType":"script","externalDependencies":[]}