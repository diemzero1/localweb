{"ast":null,"code":"/**\n * view 中缓存 scale 的类\n */\nimport { deepMix, each, get, isNumber, last } from '@antv/util';\nimport { createScaleByField, syncScale, getDefaultCategoryScaleRange } from '../../util/scale';\n/** @ignore */\nvar ScalePool = /** @class */function () {\n  function ScalePool() {\n    /** 所有的 scales */\n    this.scales = new Map();\n    /** 需要同步的 scale 分组， key: scaleKeyArray */\n    this.syncScales = new Map();\n  }\n  /**\n   * 创建 scale\n   * @param field\n   * @param data\n   * @param scaleDef\n   * @param key\n   */\n  ScalePool.prototype.createScale = function (field, data, scaleDef, key) {\n    var finalScaleDef = scaleDef;\n    var cacheScaleMeta = this.getScaleMeta(key);\n    if (data.length === 0 && cacheScaleMeta) {\n      // 在更新过程中数据变为空，同时 key 对应的 scale 已存在则保持 scale 同类型\n      var cacheScale = cacheScaleMeta.scale;\n      var cacheScaleDef = {\n        type: cacheScale.type\n      };\n      if (cacheScale.isCategory) {\n        // 如果是分类类型，保持 values\n        cacheScaleDef.values = cacheScale.values;\n      }\n      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);\n    }\n    var scale = createScaleByField(field, data, finalScaleDef);\n    // 缓存起来\n    this.cacheScale(scale, scaleDef, key);\n    return scale;\n  };\n  /**\n   * 同步 scale\n   */\n  ScalePool.prototype.sync = function (coordinate, theme) {\n    var _this = this;\n    // 对于 syncScales 中每一个 syncKey 下面的 scale 数组进行同步处理\n    this.syncScales.forEach(function (scaleKeys, syncKey) {\n      // min, max, values, ranges\n      var min = Number.MAX_SAFE_INTEGER;\n      var max = Number.MIN_SAFE_INTEGER;\n      var values = [];\n      // 1. 遍历求得最大最小值，values 等\n      each(scaleKeys, function (key) {\n        var scale = _this.getScale(key);\n        max = isNumber(scale.max) ? Math.max(max, scale.max) : max;\n        min = isNumber(scale.min) ? Math.min(min, scale.min) : min;\n        // 去重\n        each(scale.values, function (v) {\n          if (!values.includes(v)) {\n            values.push(v);\n          }\n        });\n      });\n      // 2. 同步\n      each(scaleKeys, function (key) {\n        var scale = _this.getScale(key);\n        if (scale.isContinuous) {\n          scale.change({\n            min: min,\n            max: max,\n            values: values\n          });\n        } else if (scale.isCategory) {\n          var range = scale.range;\n          var cacheScaleMeta = _this.getScaleMeta(key);\n          // 存在 value 值，且用户没有配置 range 配置 to fix https://github.com/antvis/G2/issues/2996\n          if (values && !get(cacheScaleMeta, ['scaleDef', 'range'])) {\n            // 更新 range\n            range = getDefaultCategoryScaleRange(deepMix({}, scale, {\n              values: values\n            }), coordinate, theme);\n          }\n          scale.change({\n            values: values,\n            range: range\n          });\n        }\n      });\n    });\n  };\n  /**\n   * 缓存一个 scale\n   * @param scale\n   * @param scaleDef\n   * @param key\n   */\n  ScalePool.prototype.cacheScale = function (scale, scaleDef, key) {\n    // 1. 缓存到 scales\n    var sm = this.getScaleMeta(key);\n    // 存在则更新，同时检测类型是否一致\n    if (sm && sm.scale.type === scale.type) {\n      syncScale(sm.scale, scale);\n      sm.scaleDef = scaleDef;\n      // 更新 scaleDef\n    } else {\n      sm = {\n        key: key,\n        scale: scale,\n        scaleDef: scaleDef\n      };\n      this.scales.set(key, sm);\n    }\n    // 2. 缓存到 syncScales，构造 Record<sync, string[]> 数据结构\n    var syncKey = this.getSyncKey(sm);\n    sm.syncKey = syncKey; // 设置 sync 同步的 key\n    // 因为存在更新 scale 机制，所以在缓存之前，先从原 syncScales 中去除 sync 的缓存引用\n    this.removeFromSyncScales(key);\n    // 存在 sync 标记才进行 sync\n    if (syncKey) {\n      // 不存在这个 syncKey，则创建一个空数组\n      var scaleKeys = this.syncScales.get(syncKey);\n      if (!scaleKeys) {\n        scaleKeys = [];\n        this.syncScales.set(syncKey, scaleKeys);\n      }\n      scaleKeys.push(key);\n    }\n  };\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  ScalePool.prototype.getScale = function (key) {\n    var scaleMeta = this.getScaleMeta(key);\n    if (!scaleMeta) {\n      var field = last(key.split('-'));\n      var scaleKeys = this.syncScales.get(field);\n      if (scaleKeys && scaleKeys.length) {\n        scaleMeta = this.getScaleMeta(scaleKeys[0]);\n      }\n    }\n    return scaleMeta && scaleMeta.scale;\n  };\n  /**\n   * 在 view 销毁的时候，删除 scale 实例，防止内存泄露\n   * @param key\n   */\n  ScalePool.prototype.deleteScale = function (key) {\n    var scaleMeta = this.getScaleMeta(key);\n    if (scaleMeta) {\n      var syncKey = scaleMeta.syncKey;\n      var scaleKeys = this.syncScales.get(syncKey);\n      // 移除同步的关系\n      if (scaleKeys && scaleKeys.length) {\n        var idx = scaleKeys.indexOf(key);\n        if (idx !== -1) {\n          scaleKeys.splice(idx, 1);\n        }\n      }\n    }\n    // 删除 scale 实例\n    this.scales.delete(key);\n  };\n  /**\n   * 清空\n   */\n  ScalePool.prototype.clear = function () {\n    this.scales.clear();\n    this.syncScales.clear();\n  };\n  /**\n   * 删除 sync scale 引用\n   * @param key\n   */\n  ScalePool.prototype.removeFromSyncScales = function (key) {\n    var _this = this;\n    this.syncScales.forEach(function (scaleKeys, syncKey) {\n      var idx = scaleKeys.indexOf(key);\n      if (idx !== -1) {\n        scaleKeys.splice(idx, 1);\n        // 删除空数组值\n        if (scaleKeys.length === 0) {\n          _this.syncScales.delete(syncKey);\n        }\n        return false; // 跳出循环\n      }\n    });\n  };\n  /**\n   * get sync key\n   * @param sm\n   */\n  ScalePool.prototype.getSyncKey = function (sm) {\n    var scale = sm.scale,\n      scaleDef = sm.scaleDef;\n    var field = scale.field;\n    var sync = get(scaleDef, ['sync']);\n    // 如果 sync = true，则直接使用字段名作为 syncKey\n    return sync === true ? field : sync === false ? undefined : sync;\n  };\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  ScalePool.prototype.getScaleMeta = function (key) {\n    return this.scales.get(key);\n  };\n  return ScalePool;\n}();\nexport { ScalePool };","map":{"version":3,"mappings":"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","names":["deepMix","each","get","isNumber","last","createScaleByField","syncScale","getDefaultCategoryScaleRange","Map","ScalePool","field","data","scaleDef","key","finalScaleDef","cacheScaleMeta","getScaleMeta","length","cacheScale","scale","cacheScaleDef","type","isCategory","values","coordinate","theme","syncScales","forEach","scaleKeys","syncKey","min","Number","MAX_SAFE_INTEGER","max","MIN_SAFE_INTEGER","_this","getScale","Math","v","includes","push","isContinuous","change","range","sm","scales","set","getSyncKey","removeFromSyncScales","scaleMeta","split","idx","indexOf","splice","delete","clear","sync","undefined"],"sources":["/home/iam/Documents/network/node_modules/@antv/g2/src/chart/util/scale-pool.ts"],"sourcesContent":["/**\n * view 中缓存 scale 的类\n */\nimport { deepMix, each, get, isNumber, last } from '@antv/util';\nimport { Scale, Coordinate } from '../../dependents';\nimport { Data, LooseObject, ScaleOption, ViewCfg } from '../../interface';\nimport { createScaleByField, syncScale, getDefaultCategoryScaleRange } from '../../util/scale';\n\n/** @ignore */\ninterface ScaleMeta {\n  readonly key: string;\n  readonly scale: Scale;\n  scaleDef: ScaleOption;\n  syncKey?: string;\n}\n\n/** @ignore */\nexport class ScalePool {\n  /** 所有的 scales */\n  private scales = new Map<string, ScaleMeta>();\n  /** 需要同步的 scale 分组， key: scaleKeyArray */\n  private syncScales = new Map<string, string[]>();\n\n  /**\n   * 创建 scale\n   * @param field\n   * @param data\n   * @param scaleDef\n   * @param key\n   */\n  public createScale(field: string, data: Data, scaleDef: ScaleOption, key: string): Scale {\n    let finalScaleDef = scaleDef;\n\n    const cacheScaleMeta = this.getScaleMeta(key);\n    if (data.length === 0 && cacheScaleMeta) {\n      // 在更新过程中数据变为空，同时 key 对应的 scale 已存在则保持 scale 同类型\n      const cacheScale = cacheScaleMeta.scale;\n      const cacheScaleDef: LooseObject = {\n        type: cacheScale.type,\n      };\n      if (cacheScale.isCategory) {\n        // 如果是分类类型，保持 values\n        cacheScaleDef.values = cacheScale.values;\n      }\n      finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);\n    }\n\n    const scale = createScaleByField(field, data, finalScaleDef);\n\n    // 缓存起来\n    this.cacheScale(scale, scaleDef, key);\n\n    return scale;\n  }\n\n  /**\n   * 同步 scale\n   */\n  public sync(coordinate: Coordinate, theme: ViewCfg['theme']) {\n    // 对于 syncScales 中每一个 syncKey 下面的 scale 数组进行同步处理\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      // min, max, values, ranges\n      let min = Number.MAX_SAFE_INTEGER;\n      let max = Number.MIN_SAFE_INTEGER;\n      const values = [];\n\n      // 1. 遍历求得最大最小值，values 等\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        max = isNumber(scale.max) ? Math.max(max, scale.max) : max;\n        min = isNumber(scale.min) ? Math.min(min, scale.min) : min;\n\n        // 去重\n        each(scale.values, (v: any) => {\n          if (!values.includes(v)) {\n            values.push(v);\n          }\n        });\n      });\n\n      // 2. 同步\n      each(scaleKeys, (key: string) => {\n        const scale = this.getScale(key);\n\n        if (scale.isContinuous) {\n          scale.change({\n            min,\n            max,\n            values,\n          });\n        } else if (scale.isCategory) {\n          let range = scale.range;\n          const cacheScaleMeta = this.getScaleMeta(key);\n\n          // 存在 value 值，且用户没有配置 range 配置 to fix https://github.com/antvis/G2/issues/2996\n          if (values && !get(cacheScaleMeta, ['scaleDef', 'range'])) {\n            // 更新 range\n            range = getDefaultCategoryScaleRange(\n              deepMix({}, scale, {\n                values,\n              }),\n              coordinate,\n              theme\n            );\n          }\n          scale.change({\n            values,\n            range,\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * 缓存一个 scale\n   * @param scale\n   * @param scaleDef\n   * @param key\n   */\n  private cacheScale(scale: Scale, scaleDef: ScaleOption, key: string) {\n    // 1. 缓存到 scales\n\n    let sm = this.getScaleMeta(key);\n    // 存在则更新，同时检测类型是否一致\n    if (sm && sm.scale.type === scale.type) {\n      syncScale(sm.scale, scale);\n      sm.scaleDef = scaleDef;\n      // 更新 scaleDef\n    } else {\n      sm = {\n        key,\n        scale,\n        scaleDef,\n      };\n\n      this.scales.set(key, sm);\n    }\n\n    // 2. 缓存到 syncScales，构造 Record<sync, string[]> 数据结构\n    const syncKey = this.getSyncKey(sm);\n    sm.syncKey = syncKey; // 设置 sync 同步的 key\n\n    // 因为存在更新 scale 机制，所以在缓存之前，先从原 syncScales 中去除 sync 的缓存引用\n    this.removeFromSyncScales(key);\n\n    // 存在 sync 标记才进行 sync\n    if (syncKey) {\n      // 不存在这个 syncKey，则创建一个空数组\n      let scaleKeys = this.syncScales.get(syncKey);\n      if (!scaleKeys) {\n        scaleKeys = [];\n        this.syncScales.set(syncKey, scaleKeys);\n      }\n      scaleKeys.push(key);\n    }\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  public getScale(key: string): Scale {\n    let scaleMeta = this.getScaleMeta(key);\n    if (!scaleMeta) {\n      const field = last(key.split('-'));\n      const scaleKeys = this.syncScales.get(field);\n      if (scaleKeys && scaleKeys.length) {\n        scaleMeta = this.getScaleMeta(scaleKeys[0]);\n      }\n    }\n    return scaleMeta && scaleMeta.scale;\n  }\n\n  /**\n   * 在 view 销毁的时候，删除 scale 实例，防止内存泄露\n   * @param key\n   */\n  public deleteScale(key: string) {\n    const scaleMeta = this.getScaleMeta(key);\n    if (scaleMeta) {\n      const { syncKey } = scaleMeta;\n\n      const scaleKeys = this.syncScales.get(syncKey);\n\n      // 移除同步的关系\n      if (scaleKeys && scaleKeys.length) {\n        const idx = scaleKeys.indexOf(key);\n\n        if (idx !== -1) {\n          scaleKeys.splice(idx, 1);\n        }\n      }\n    }\n\n    // 删除 scale 实例\n    this.scales.delete(key);\n  }\n\n  /**\n   * 清空\n   */\n  public clear() {\n    this.scales.clear();\n    this.syncScales.clear();\n  }\n\n  /**\n   * 删除 sync scale 引用\n   * @param key\n   */\n  private removeFromSyncScales(key: string) {\n    this.syncScales.forEach((scaleKeys: string[], syncKey: string) => {\n      const idx = scaleKeys.indexOf(key);\n\n      if (idx !== -1) {\n        scaleKeys.splice(idx, 1);\n\n        // 删除空数组值\n        if (scaleKeys.length === 0) {\n          this.syncScales.delete(syncKey);\n        }\n\n        return false; // 跳出循环\n      }\n    });\n  }\n\n  /**\n   * get sync key\n   * @param sm\n   */\n  private getSyncKey(sm: ScaleMeta): string {\n    const { scale, scaleDef } = sm;\n    const { field } = scale;\n    const sync = get(scaleDef, ['sync']);\n\n    // 如果 sync = true，则直接使用字段名作为 syncKey\n    return sync === true ? field : sync === false ? undefined : sync;\n  }\n\n  /**\n   * 通过 key 获取 scale\n   * @param key\n   */\n  private getScaleMeta(key: string): ScaleMeta {\n    return this.scales.get(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}