{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getTextPoint } from '../util/util';\nimport CrosshairBase from './base';\nvar LineCrosshair = /** @class */function (_super) {\n  __extends(LineCrosshair, _super);\n  function LineCrosshair() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  LineCrosshair.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'line',\n      locationType: 'region',\n      start: null,\n      end: null\n    });\n  };\n  // 直线的文本需要同直线垂直\n  LineCrosshair.prototype.getRotateAngle = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    var position = this.get('text').position;\n    var angle = Math.atan2(end.y - start.y, end.x - start.x);\n    var tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    return tangentAngle;\n  };\n  LineCrosshair.prototype.getTextPoint = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    var _b = this.get('text'),\n      position = _b.position,\n      offset = _b.offset;\n    return getTextPoint(start, end, position, offset);\n  };\n  LineCrosshair.prototype.getLinePath = function () {\n    var _a = this.getLocation(),\n      start = _a.start,\n      end = _a.end;\n    return [['M', start.x, start.y], ['L', end.x, end.y]];\n  };\n  return LineCrosshair;\n}(CrosshairBase);\nexport default LineCrosshair;","map":{"version":3,"mappings":";AAEA,SAASA,YAAY,QAAQ,cAAc;AAC3C,OAAOC,aAAa,MAAM,QAAQ;AAElC;EAA4BC;EAA5B;;EAkCA;EAjCSC,qCAAa,GAApB;IACE,IAAMC,GAAG,GAAGC,iBAAMC,aAAa,WAAE;IACjC,6BACKF,GAAG;MACNG,IAAI,EAAE,MAAM;MACZC,YAAY,EAAE,QAAQ;MACtBC,KAAK,EAAE,IAAI;MACXC,GAAG,EAAE;IAAI;EAEb,CAAC;EAED;EACUP,sCAAc,GAAxB;IACQ,SAAiB,IAAI,CAACQ,WAAW,EAAE;MAAjCF,KAAK;MAAEC,GAAG,SAAuB;IACjC,YAAQ,GAAK,IAAI,CAACE,GAAG,CAAC,MAAM,CAAC,SAArB;IAChB,IAAMC,KAAK,GAAGC,IAAI,CAACC,KAAK,CAACL,GAAG,CAACM,CAAC,GAAGP,KAAK,CAACO,CAAC,EAAEN,GAAG,CAACO,CAAC,GAAGR,KAAK,CAACQ,CAAC,CAAC;IAC1D,IAAMC,YAAY,GAAGC,QAAQ,KAAK,OAAO,GAAGN,KAAK,GAAGC,IAAI,CAACM,EAAE,GAAG,CAAC,GAAGP,KAAK,GAAGC,IAAI,CAACM,EAAE,GAAG,CAAC;IACrF,OAAOF,YAAY;EACrB,CAAC;EAESf,oCAAY,GAAtB;IACQ,SAAiB,IAAI,CAACQ,WAAW,EAAE;MAAjCF,KAAK;MAAEC,GAAG,SAAuB;IACnC,SAAuB,IAAI,CAACE,GAAG,CAAC,MAAM,CAAC;MAArCO,QAAQ;MAAEE,MAAM,YAAqB;IAC7C,OAAOrB,YAAY,CAACS,KAAK,EAAEC,GAAG,EAAES,QAAQ,EAAEE,MAAM,CAAC;EACnD,CAAC;EAESlB,mCAAW,GAArB;IACQ,SAAiB,IAAI,CAACQ,WAAW,EAAE;MAAjCF,KAAK;MAAEC,GAAG,SAAuB;IACzC,OAAO,CACL,CAAC,GAAG,EAAED,KAAK,CAACQ,CAAC,EAAER,KAAK,CAACO,CAAC,CAAC,EACvB,CAAC,GAAG,EAAEN,GAAG,CAACO,CAAC,EAAEP,GAAG,CAACM,CAAC,CAAC,CACpB;EACH,CAAC;EACH,oBAAC;AAAD,CAAC,CAlC2Bf,aAAa;AAoCzC,eAAeE,aAAa","names":["getTextPoint","CrosshairBase","__extends","LineCrosshair","cfg","_super","getDefaultCfg","type","locationType","start","end","getLocation","get","angle","Math","atan2","y","x","tangentAngle","position","PI","offset"],"sources":["/home/iam/Documents/network/node_modules/@antv/component/src/crosshair/line.ts"],"sourcesContent":["import { ILocation } from '../interfaces';\nimport { LineCrosshairCfg, Point, RegionLocationCfg } from '../types';\nimport { getTextPoint } from '../util/util';\nimport CrosshairBase from './base';\n\nclass LineCrosshair extends CrosshairBase<LineCrosshairCfg> implements ILocation<RegionLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n      locationType: 'region',\n      start: null,\n      end: null,\n    };\n  }\n\n  // 直线的文本需要同直线垂直\n  protected getRotateAngle(): number {\n    const { start, end } = this.getLocation();\n    const { position } = this.get('text');\n    const angle = Math.atan2(end.y - start.y, end.x - start.x);\n    const tangentAngle = position === 'start' ? angle - Math.PI / 2 : angle + Math.PI / 2;\n    return tangentAngle;\n  }\n\n  protected getTextPoint() {\n    const { start, end } = this.getLocation();\n    const { position, offset } = this.get('text');\n    return getTextPoint(start, end, position, offset);\n  }\n\n  protected getLinePath(): any[] {\n    const { start, end } = this.getLocation();\n    return [\n      ['M', start.x, start.y],\n      ['L', end.x, end.y],\n    ];\n  }\n}\n\nexport default LineCrosshair;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}