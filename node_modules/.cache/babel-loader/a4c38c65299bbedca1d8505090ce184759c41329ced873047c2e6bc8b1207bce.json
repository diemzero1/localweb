{"ast":null,"code":"\"use strict\";\n\n/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar util_1 = require(\"../util\");\nvar twoLayerCrossCount = function twoLayerCrossCount(g, northLayer, southLayer) {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function (v, i) {\n    return i;\n  }));\n  var unflat = northLayer.map(function (v) {\n    var _a;\n    var unsort = (_a = g.outEdges(v)) === null || _a === void 0 ? void 0 : _a.map(function (e) {\n      return {\n        pos: southPos[e.w] || 0,\n        weight: g.edge(e).weight\n      };\n    });\n    return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function (a, b) {\n      return a.pos - b.pos;\n    });\n  });\n  var southEntries = unflat.flat().filter(function (entry) {\n    return entry !== undefined;\n  });\n  // Build the accumulator tree\n  var firstIndex = 1;\n  while (firstIndex < southLayer.length) {\n    firstIndex <<= 1;\n  }\n  var treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  var tree = Array(treeSize).fill(0, 0, treeSize);\n  // Calculate the weighted crossings\n  var cc = 0;\n  southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function (entry) {\n    if (entry) {\n      var index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      var weightSum = 0;\n      while (index > 0) {\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        index = index - 1 >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight * weightSum;\n    }\n  });\n  return cc;\n};\nvar crossCount = function crossCount(g, layering) {\n  var cc = 0;\n  for (var i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n};\nexports.default = crossCount;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;AAkBA;AAEA,IAAMA,kBAAkB,GAAG,SAArBA,kBAAkB,CACtBC,CAAQ,EACRC,UAAoB,EACpBC,UAAoB;EAEpB;EACA;EACA;EACA,IAAMC,QAAQ,GAAG,oBAAS,EACxBD,UAAU,EACVA,UAAU,CAACE,GAAG,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAK,QAAC;EAAD,CAAC,CAAC,CAC5B;EACD,IAAMC,MAAM,GAAGN,UAAU,CAACG,GAAG,CAAC,UAACC,CAAC;;IAC9B,IAAMG,MAAM,GAAG,OAAC,CAACC,QAAQ,CAACJ,CAAC,CAAC,0CAAED,GAAG,CAAC,UAACM,CAAC;MAClC,OAAO;QAAEC,GAAG,EAAER,QAAQ,CAACO,CAAC,CAACE,CAAC,CAAC,IAAI,CAAC;QAAEC,MAAM,EAAEb,CAAC,CAACc,IAAI,CAACJ,CAAC,CAAE,CAACG;MAAM,CAAE;IAC/D,CAAC,CAAC;IACF,OAAOL,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEO,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;MAAK,QAAC,CAACN,GAAG,GAAGM,CAAC,CAACN,GAAG;IAAb,CAAa,CAAC;EAC9C,CAAC,CAAC;EACF,IAAMO,YAAY,GAAGX,MAAM,CAACY,IAAI,EAAE,CAACC,MAAM,CAAC,UAACC,KAAK;IAAK,YAAK,KAAKC,SAAS;EAAnB,CAAmB,CAAC;EAEzE;EACA,IAAIC,UAAU,GAAG,CAAC;EAClB,OAAOA,UAAU,GAAGrB,UAAU,CAACsB,MAAM;IAAED,UAAU,KAAK,CAAC;EAAC;EACxD,IAAME,QAAQ,GAAG,CAAC,GAAGF,UAAU,GAAG,CAAC;EACnCA,UAAU,IAAI,CAAC;EACf,IAAMG,IAAI,GAAGC,KAAK,CAACF,QAAQ,CAAC,CAACG,IAAI,CAAC,CAAC,EAAE,CAAC,EAAEH,QAAQ,CAAC;EAEjD;EACA,IAAII,EAAE,GAAG,CAAC;EACVX,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEY,OAAO,CAAC,UAACT,KAAK;IAC1B,IAAIA,KAAK,EAAE;MACT,IAAIU,KAAK,GAAGV,KAAK,CAACV,GAAG,GAAGY,UAAU;MAClCG,IAAI,CAACK,KAAK,CAAC,IAAIV,KAAK,CAACR,MAAM;MAC3B,IAAImB,SAAS,GAAG,CAAC;MACjB,OAAOD,KAAK,GAAG,CAAC,EAAE;QAChB,IAAIA,KAAK,GAAG,CAAC,EAAE;UACbC,SAAS,IAAIN,IAAI,CAACK,KAAK,GAAG,CAAC,CAAC;;QAE9BA,KAAK,GAAIA,KAAK,GAAG,CAAC,IAAK,CAAC;QACxBL,IAAI,CAACK,KAAK,CAAC,IAAIV,KAAK,CAACR,MAAM;;MAE7BgB,EAAE,IAAIR,KAAK,CAACR,MAAO,GAAGmB,SAAS;;EAEnC,CAAC,CAAC;EAEF,OAAOH,EAAE;AACX,CAAC;AAED,IAAMI,UAAU,GAAG,SAAbA,UAAU,CAAIjC,CAAQ,EAAEkC,QAAoB;EAChD,IAAIL,EAAE,GAAG,CAAC;EACV,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAG4B,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEV,MAAM,GAAElB,CAAC,IAAI,CAAC,EAAE;IAC5CuB,EAAE,IAAI9B,kBAAkB,CAACC,CAAC,EAAEkC,QAAQ,CAAC5B,CAAC,GAAG,CAAC,CAAC,EAAE4B,QAAQ,CAAC5B,CAAC,CAAC,CAAC;;EAE3D,OAAOuB,EAAE;AACX,CAAC;AAEDM,kBAAeF,UAAU","names":["twoLayerCrossCount","g","northLayer","southLayer","southPos","map","v","i","unflat","unsort","outEdges","e","pos","w","weight","edge","sort","a","b","southEntries","flat","filter","entry","undefined","firstIndex","length","treeSize","tree","Array","fill","cc","forEach","index","weightSum","crossCount","layering","exports"],"sources":["/home/iam/Documents/network/node_modules/@antv/layout/src/layout/dagre/src/order/cross-count.ts"],"sourcesContent":["/*\n * A function that takes a layering (an array of layers, each with an array of\n * ordererd nodes) and a graph and returns a weighted crossing count.\n *\n * Pre-conditions:\n *\n *    1. Input graph must be simple (not a multigraph), directed, and include\n *       only simple edges.\n *    2. Edges in the input graph must have assigned weights.\n *\n * Post-conditions:\n *\n *    1. The graph and layering matrix are left unchanged.\n *\n * This algorithm is derived from Barth, et al., \"Bilayer Cross Counting.\"\n */\n\nimport { Graph } from \"../../graph\";\nimport { zipObject } from \"../util\";\n\nconst twoLayerCrossCount = (\n  g: Graph,\n  northLayer: string[],\n  southLayer: string[]\n) => {\n  // Sort all of the edges between the north and south layers by their position\n  // in the north layer and then the south. Map these edges to the position of\n  // their head in the south layer.\n  const southPos = zipObject(\n    southLayer,\n    southLayer.map((v, i) => i)\n  );\n  const unflat = northLayer.map((v) => {\n    const unsort = g.outEdges(v)?.map((e) => {\n      return { pos: southPos[e.w] || 0, weight: g.edge(e)!.weight };\n    });\n    return unsort?.sort((a, b) => a.pos - b.pos);\n  });\n  const southEntries = unflat.flat().filter((entry) => entry !== undefined);\n\n  // Build the accumulator tree\n  let firstIndex = 1;\n  while (firstIndex < southLayer.length) firstIndex <<= 1;\n  const treeSize = 2 * firstIndex - 1;\n  firstIndex -= 1;\n  const tree = Array(treeSize).fill(0, 0, treeSize);\n\n  // Calculate the weighted crossings\n  let cc = 0;\n  southEntries?.forEach((entry) => {\n    if (entry) {\n      let index = entry.pos + firstIndex;\n      tree[index] += entry.weight;\n      let weightSum = 0;\n      while (index > 0) {\n        if (index % 2) {\n          weightSum += tree[index + 1];\n        }\n        index = (index - 1) >> 1;\n        tree[index] += entry.weight;\n      }\n      cc += entry.weight! * weightSum;\n    }\n  });\n\n  return cc;\n};\n\nconst crossCount = (g: Graph, layering: string[][]) => {\n  let cc = 0;\n  for (let i = 1; i < layering?.length; i += 1) {\n    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);\n  }\n  return cc;\n};\n\nexport default crossCount;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}