{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar barycenter_1 = __importDefault(require(\"./barycenter\"));\nvar resolve_conflicts_1 = __importDefault(require(\"./resolve-conflicts\"));\nvar sort_1 = __importDefault(require(\"./sort\"));\nvar sortSubgraph = function sortSubgraph(g, v, cg, biasRight, usePrev) {\n  var _a, _b, _c, _d;\n  var movable = g.children(v);\n  // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n  var node = g.node(v);\n  var bl = node ? node.borderLeft : undefined;\n  var br = node ? node.borderRight : undefined;\n  var subgraphs = {};\n  if (bl) {\n    movable = movable === null || movable === void 0 ? void 0 : movable.filter(function (w) {\n      return w !== bl && w !== br;\n    });\n  }\n  var barycenters = (0, barycenter_1.default)(g, movable || []);\n  barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function (entry) {\n    var _a;\n    if ((_a = g.children(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {\n      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n  var entries = (0, resolve_conflicts_1.default)(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n  // 添加fixorder信息到entries里边\n  // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n  (_a = entries.filter(function (e) {\n    return e.vs.length > 0;\n  })) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var node = g.node(e.vs[0]);\n    if (node) {\n      e.fixorder = node.fixorder;\n      e.order = node.order;\n    }\n  });\n  var result = (0, sort_1.default)(entries, biasRight, usePrev);\n  if (bl) {\n    result.vs = [bl, result.vs, br].flat();\n    if ((_b = g.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {\n      var blPred = g.node(((_c = g.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || \"\");\n      var brPred = g.node(((_d = g.predecessors(br)) === null || _d === void 0 ? void 0 : _d[0]) || \"\");\n      if (!result.hasOwnProperty(\"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);\n      result.weight += 2;\n    }\n  }\n  return result;\n};\nvar expandSubgraphs = function expandSubgraphs(entries, subgraphs) {\n  entries === null || entries === void 0 ? void 0 : entries.forEach(function (entry) {\n    var _a;\n    var vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map(function (v) {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs;\n      }\n      return v;\n    });\n    entry.vs = vss.flat();\n  });\n};\nvar mergeBarycenters = function mergeBarycenters(target, other) {\n  if (target.barycenter !== undefined) {\n    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);\n    target.weight += other.weight;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n};\nexports.default = sortSubgraph;","map":{"version":3,"mappings":"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","names":["sortSubgraph","g","v","cg","biasRight","usePrev","movable","children","node","bl","borderLeft","undefined","br","borderRight","subgraphs","filter","w","barycenters","forEach","entry","length","subgraphResult","hasOwnProperty","mergeBarycenters","entries","expandSubgraphs","e","vs","fixorder","order","result","flat","predecessors","blPred","brPred","barycenter","weight","vss","map","target","other","exports"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/order/sort-subgraph.ts"],"sourcesContent":["import { Graph } from \"../../graph\";\nimport barycenter from \"./barycenter\";\nimport resolveConflicts, { ConflictEntry } from \"./resolve-conflicts\";\nimport sort from \"./sort\";\n\nconst sortSubgraph = (\n  g: Graph,\n  v: string,\n  cg: Graph,\n  biasRight?: boolean,\n  usePrev?: boolean\n) => {\n  let movable = g.children(v);\n  // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）\n  const node = g.node(v)!;\n  const bl = node ? node.borderLeft : undefined;\n  const br = node ? node.borderRight : undefined;\n  const subgraphs: Record<string, Partial<ConflictEntry>> = {};\n\n  if (bl) {\n    movable = movable?.filter((w) => {\n      return w !== bl && w !== br;\n    });\n  }\n\n  const barycenters = barycenter(g, movable || []);\n  barycenters?.forEach((entry) => {\n    if (g.children(entry.v)?.length) {\n      const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);\n      subgraphs[entry.v] = subgraphResult;\n      if (subgraphResult.hasOwnProperty(\"barycenter\")) {\n        mergeBarycenters(entry, subgraphResult);\n      }\n    }\n  });\n\n  const entries = resolveConflicts(barycenters, cg);\n  expandSubgraphs(entries, subgraphs);\n\n  // 添加fixorder信息到entries里边\n  // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现\n  entries\n    .filter((e) => e.vs.length > 0)\n    ?.forEach((e) => {\n      const node = g.node(e.vs[0])!;\n      if (node) {\n        e.fixorder = node.fixorder;\n        e.order = node.order;\n      }\n    });\n\n  const result = sort(entries, biasRight, usePrev);\n\n  if (bl) {\n    result.vs = [bl, result.vs, br].flat();\n    if (g.predecessors(bl)?.length) {\n      const blPred = g.node(g.predecessors(bl)?.[0] || \"\")!;\n      const brPred = g.node(g.predecessors(br)?.[0] || \"\")!;\n      if (!result.hasOwnProperty(\"barycenter\")) {\n        result.barycenter = 0;\n        result.weight = 0;\n      }\n      result.barycenter =\n        (result.barycenter! * result.weight! +\n          (blPred.order as number) +\n          (brPred.order as number)) /\n        (result.weight! + 2);\n      result.weight! += 2;\n    }\n  }\n\n  return result;\n};\n\nconst expandSubgraphs = (\n  entries: ConflictEntry[],\n  subgraphs: Record<string, Partial<ConflictEntry>>\n) => {\n  entries?.forEach((entry) => {\n    const vss = entry.vs?.map((v: string) => {\n      if (subgraphs[v]) {\n        return subgraphs[v].vs!;\n      }\n      return v;\n    });\n    entry.vs = vss.flat();\n  });\n};\n\nconst mergeBarycenters = (\n  target: { weight?: number; barycenter?: number },\n  other: { weight?: number; barycenter?: number }\n) => {\n  if (target.barycenter !== undefined) {\n    target.barycenter =\n      (target.barycenter * target.weight! + other.barycenter! * other.weight!) /\n      (target.weight! + other.weight!);\n    target.weight! += other.weight!;\n  } else {\n    target.barycenter = other.barycenter;\n    target.weight = other.weight;\n  }\n};\n\nexport default sortSubgraph;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}