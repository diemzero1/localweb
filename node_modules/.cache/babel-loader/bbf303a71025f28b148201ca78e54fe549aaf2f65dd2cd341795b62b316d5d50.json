{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.feasibleTreeWithLayer = exports.feasibleTree = void 0;\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graph_1 = require(\"../../graph\");\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTree = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodeCount();\n  t.setNode(start, {});\n  var edge;\n  var delta;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\nexports.feasibleTree = feasibleTree;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTree = function (t, g) {\n  var dfs = function (v) {\n    g.nodeEdges(v).forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n      if (!t.hasNode(w) && !(0, util_1.slack)(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nvar feasibleTreeWithLayer = function (g) {\n  var t = new graph_1.Graph({\n    directed: false\n  });\n  // Choose arbitrary node from which to start our tree\n  var start = g.nodes()[0];\n  var size = g.nodes().filter(function (n) {\n    return !!g.node(n);\n  }).length;\n  t.setNode(start, {});\n  var edge;\n  var delta;\n  while (tightTreeWithLayer(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? (0, util_1.slack)(g, edge) : -(0, util_1.slack)(g, edge);\n    shiftRanks(t, g, delta);\n  }\n  return t;\n};\nexports.feasibleTreeWithLayer = feasibleTreeWithLayer;\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nvar tightTreeWithLayer = function (t, g) {\n  var dfs = function (v) {\n    var _a;\n    (_a = g.nodeEdges(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      var edgeV = e.v;\n      var w = v === edgeV ? e.w : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.node(w).layer !== undefined || !(0, util_1.slack)(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nvar findMinSlackEdge = function (t, g) {\n  return (0, util_2.minBy)(g.edges(), function (e) {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return (0, util_1.slack)(g, e);\n    }\n    return Infinity;\n  });\n};\nvar shiftRanks = function (t, g, delta) {\n  t.nodes().forEach(function (v) {\n    if (!g.node(v).rank) g.node(v).rank = 0;\n    g.node(v).rank += delta;\n  });\n};\nexports.default = {\n  feasibleTree: feasibleTree,\n  feasibleTreeWithLayer: feasibleTreeWithLayer\n};","map":{"version":3,"mappings":"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","names":["feasibleTree","g","t","graph_1","directed","start","nodes","size","nodeCount","setNode","edge","delta","tightTree","findMinSlackEdge","hasNode","v","shiftRanks","exports","dfs","nodeEdges","forEach","e","edgeV","w","setEdge","feasibleTreeWithLayer","filter","node","n","length","tightTreeWithLayer","layer","undefined","edges","Infinity","rank"],"sources":["/home/iam/Documents/network/node_modules/@antv/layout/src/layout/dagre/src/rank/feasible-tree.ts"],"sourcesContent":["import { slack } from './util';\nimport { minBy } from '../util';\nimport { Graph } from '../../graph';\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTree = (g: Graph) => {\n  const t = new Graph({ directed: false });\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodeCount();\n  t.setNode(start, {});\n\n  let edge: any;\n  let delta: number;\n  while (tightTree(t, g) < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTree = (t: Graph, g: Graph) => {\n  const dfs = (v: string) => {\n    g.nodeEdges(v)!.forEach((e) => {\n      const edgeV = e.v;\n      const w = (v === edgeV) ? e.w : edgeV;\n      if (!t.hasNode(w) && !slack(g, e)) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n\n/*\n * Constructs a spanning tree with tight edges and adjusted the input node's\n * ranks to achieve this. A tight edge is one that is has a length that matches\n * its \"minlen\" attribute.\n *\n * The basic structure for this function is derived from Gansner, et al., \"A\n * Technique for Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a DAG.\n *    2. Graph must be connected.\n *    3. Graph must have at least one node.\n *    5. Graph nodes must have been previously assigned a \"rank\" property that\n *       respects the \"minlen\" property of incident edges.\n *    6. Graph edges must have a \"minlen\" property.\n *\n * Post-conditions:\n *\n *    - Graph nodes will have their rank adjusted to ensure that all edges are\n *      tight.\n *\n * Returns a tree (undirected graph) that is constructed using only \"tight\"\n * edges.\n */\nconst feasibleTreeWithLayer = (g: Graph) => {\n  const t = new Graph({ directed: false }) as any;\n\n  // Choose arbitrary node from which to start our tree\n  const start = g.nodes()[0];\n  const size = g.nodes().filter(n => !!g.node(n)).length;\n  t.setNode(start, {});\n\n  let edge: any;\n  let delta: number;\n  while (tightTreeWithLayer(t, g)! < size) {\n    edge = findMinSlackEdge(t, g);\n    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);\n    shiftRanks(t, g, delta);\n  }\n\n  return t;\n};\n\n\n/*\n * Finds a maximal tree of tight edges and returns the number of nodes in the\n * tree.\n */\nconst tightTreeWithLayer = (t: Graph, g: Graph) => {\n  const dfs = (v: string) => {\n    g.nodeEdges(v)?.forEach((e) => {\n      const edgeV = e.v;\n      const w = (v === edgeV) ? e.w : edgeV;\n      // 对于指定layer的，直接加入tight-tree，不参与调整\n      if (!t.hasNode(w) && (g.node(w)!.layer !== undefined || !slack(g, e))) {\n        t.setNode(w, {});\n        t.setEdge(v, w, {});\n        dfs(w);\n      }\n    });\n  };\n\n  t.nodes().forEach(dfs);\n  return t.nodeCount();\n};\n\n/*\n * Finds the edge with the smallest slack that is incident on tree and returns\n * it.\n */\nconst findMinSlackEdge = (t: Graph, g: Graph) => {\n  return minBy(g.edges(), (e: any) => {\n    if (t.hasNode(e.v) !== t.hasNode(e.w)) {\n      return slack(g, e);\n    }\n    return Infinity;\n  });\n};\n\nconst shiftRanks = (t: Graph, g: Graph, delta: number) => {\n  t.nodes().forEach((v: string) => {\n    if (!g.node(v)!.rank) g.node(v)!.rank = 0;\n    (g.node(v)!.rank as number) += delta;\n  });\n};\n\nexport {\n  feasibleTree,\n  feasibleTreeWithLayer\n};\n\nexport default {\n  feasibleTree,\n  feasibleTreeWithLayer\n};"]},"metadata":{},"sourceType":"script","externalDependencies":[]}