{"ast":null,"code":"\"use strict\";\n\n/**\n * @fileOverview dagre layout\n * @author shiwu.wyy@antfin.com\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DagreLayout = void 0;\nvar index_1 = __importDefault(require(\"./dagre/index\"));\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\nvar graph_1 = require(\"./dagre/graph\");\n/**\n * 层次布局\n */\nvar DagreLayout = /** @class */function (_super) {\n  __extends(DagreLayout, _super);\n  function DagreLayout(options) {\n    var _this = _super.call(this) || this;\n    /** layout 方向, 可选 TB, BT, LR, RL */\n    _this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n    _this.sortByCombo = false;\n    /** 是否保留每条边上的dummy node */\n    _this.edgeLabelSpace = true;\n    /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */\n    _this.radial = false;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n    _this.onLayoutEnd = function () {};\n    _this.layoutNode = function (nodeId) {\n      var self = _this;\n      var nodes = self.nodes;\n      var node = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n      if (node) {\n        var layout = node.layout !== false;\n        return layout;\n      }\n      return true;\n    };\n    _this.updateCfg(options);\n    return _this;\n  }\n  DagreLayout.prototype.getDefaultCfg = function () {\n    return {\n      rankdir: \"TB\",\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false,\n      radial: false,\n      focusNode: null // radial 为 true 时生效，关注的节点\n    };\n  };\n  /**\n   * 执行布局\n   */\n  DagreLayout.prototype.execute = function () {\n    var _this = this;\n    var _a, _b, _c;\n    var self = this;\n    var nodes = self.nodes,\n      nodeSize = self.nodeSize,\n      rankdir = self.rankdir,\n      combos = self.combos,\n      begin = self.begin,\n      radial = self.radial,\n      _d = self.comboEdges,\n      comboEdges = _d === void 0 ? [] : _d,\n      _e = self.vedges,\n      vedges = _e === void 0 ? [] : _e;\n    if (!nodes) return;\n    var edges = self.edges || [];\n    var g = new graph_1.Graph({\n      multigraph: true,\n      compound: true\n    });\n    // collect the nodes in their combo, to create virtual edges for comboEdges\n    var nodeComboMap = {};\n    nodes.forEach(function (node) {\n      if (!node.comboId) return;\n      nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];\n      nodeComboMap[node.comboId].push(node.id);\n    });\n    var nodeSizeFunc;\n    if (!nodeSize) {\n      nodeSizeFunc = function (d) {\n        if (d.size) {\n          if ((0, util_1.isArray)(d.size)) {\n            return d.size;\n          }\n          if ((0, util_1.isObject)(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n          return [d.size, d.size];\n        }\n        return [40, 40];\n      };\n    } else if ((0, util_1.isArray)(nodeSize)) {\n      nodeSizeFunc = function () {\n        return nodeSize;\n      };\n    } else {\n      nodeSizeFunc = function () {\n        return [nodeSize, nodeSize];\n      };\n    }\n    var ranksepfunc = (0, util_1.getFunc)(self.ranksep, 50, self.ranksepFunc);\n    var nodesepfunc = (0, util_1.getFunc)(self.nodesep, 50, self.nodesepFunc);\n    var horisep = nodesepfunc;\n    var vertisep = ranksepfunc;\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = ranksepfunc;\n      vertisep = nodesepfunc;\n    }\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    g.setGraph(self);\n    var comboMap = {};\n    if (this.sortByCombo && combos) {\n      combos.forEach(function (combo) {\n        comboMap[combo.id] = combo;\n        // regard the collapsed combo as a node\n        if (combo.collapsed) {\n          var size = nodeSizeFunc(combo);\n          var verti = vertisep(combo);\n          var hori = horisep(combo);\n          var width = size[0] + 2 * hori;\n          var height = size[1] + 2 * verti;\n          g.setNode(combo.id, {\n            width: width,\n            height: height\n          });\n        }\n        if (!combo.parentId) return;\n        if (!comboMap[combo.parentId]) {\n          g.setNode(combo.parentId, {});\n        }\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n    nodes.filter(function (node) {\n      return node.layout !== false;\n    }).forEach(function (node) {\n      var size = nodeSizeFunc(node);\n      var verti = vertisep(node);\n      var hori = horisep(node);\n      var width = size[0] + 2 * hori;\n      var height = size[1] + 2 * verti;\n      var layer = node.layer;\n      if ((0, util_1.isNumber)(layer)) {\n        // 如果有layer属性，加入到node的label中\n        g.setNode(node.id, {\n          width: width,\n          height: height,\n          layer: layer\n        });\n      } else {\n        g.setNode(node.id, {\n          width: width,\n          height: height\n        });\n      }\n      if (_this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = {\n            id: node.comboId\n          };\n          g.setNode(node.comboId, {});\n        }\n        g.setParent(node.id, node.comboId);\n      }\n    });\n    edges.forEach(function (edge) {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      var source = (0, util_1.getEdgeTerminal)(edge, 'source');\n      var target = (0, util_1.getEdgeTerminal)(edge, 'target');\n      if (_this.layoutNode(source) && _this.layoutNode(target)) {\n        g.setEdge(source, target, {\n          weight: edge.weight || 1\n        });\n      }\n    });\n    // create virtual edges from node to node for comboEdges\n    (_a = comboEdges === null || comboEdges === void 0 ? void 0 : comboEdges.concat(vedges || [])) === null || _a === void 0 ? void 0 : _a.forEach(function (comboEdge) {\n      var _a, _b;\n      var source = comboEdge.source,\n        target = comboEdge.target;\n      var sources = ((_a = comboMap[source]) === null || _a === void 0 ? void 0 : _a.collapsed) ? [source] : nodeComboMap[source] || [source];\n      var targets = ((_b = comboMap[target]) === null || _b === void 0 ? void 0 : _b.collapsed) ? [target] : nodeComboMap[target] || [target];\n      sources.forEach(function (s) {\n        targets.forEach(function (t) {\n          g.setEdge(s, t, {\n            weight: comboEdge.weight || 1\n          });\n        });\n      });\n    });\n    // 考虑增量图中的原始图\n    var prevGraph = undefined;\n    if ((_b = self.preset) === null || _b === void 0 ? void 0 : _b.nodes) {\n      prevGraph = new graph_1.Graph({\n        multigraph: true,\n        compound: true\n      });\n      self.preset.nodes.forEach(function (node) {\n        prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n      });\n    }\n    index_1.default.layout(g, {\n      prevGraph: prevGraph,\n      edgeLabelSpace: self.edgeLabelSpace,\n      keepNodeOrder: Boolean(!!self.nodeOrder),\n      nodeOrder: self.nodeOrder\n    });\n    var dBegin = [0, 0];\n    if (begin) {\n      var minX_1 = Infinity;\n      var minY_1 = Infinity;\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        if (minX_1 > coord.x) minX_1 = coord.x;\n        if (minY_1 > coord.y) minY_1 = coord.y;\n      });\n      g.edges().forEach(function (edge) {\n        var _a;\n        var coord = g.edge(edge);\n        (_a = coord.points) === null || _a === void 0 ? void 0 : _a.forEach(function (point) {\n          if (minX_1 > point.x) minX_1 = point.x;\n          if (minY_1 > point.y) minY_1 = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX_1;\n      dBegin[1] = begin[1] - minY_1;\n    }\n    // 变形为辐射\n    if (radial) {\n      var _f = this,\n        focusNode = _f.focusNode,\n        ranksep = _f.ranksep,\n        getRadialPos_1 = _f.getRadialPos;\n      var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;\n      var focusLayer_1 = focusId ? (_c = g.node(focusId)) === null || _c === void 0 ? void 0 : _c._rank : 0;\n      var layers_1 = [];\n      var isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n      var dim_1 = isHorizontal ? 'y' : 'x';\n      var sizeDim_1 = isHorizontal ? 'height' : 'width';\n      // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n      var min_1 = Infinity;\n      var max_1 = -Infinity;\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        if (!nodes[i]) return;\n        var currentNodesep = nodesepfunc(nodes[i]);\n        if (focusLayer_1 === 0) {\n          if (!layers_1[coord._rank]) layers_1[coord._rank] = {\n            nodes: [],\n            totalWidth: 0,\n            maxSize: -Infinity\n          };\n          layers_1[coord._rank].nodes.push(node);\n          layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n          if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height)) layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);\n        } else {\n          var diffLayer = coord._rank - focusLayer_1;\n          if (diffLayer === 0) {\n            if (!layers_1[diffLayer]) layers_1[diffLayer] = {\n              nodes: [],\n              totalWidth: 0,\n              maxSize: -Infinity\n            };\n            layers_1[diffLayer].nodes.push(node);\n            layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n            if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height)) layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);\n          } else {\n            var diffLayerAbs = Math.abs(diffLayer);\n            if (!layers_1[diffLayerAbs]) layers_1[diffLayerAbs] = {\n              left: [],\n              right: [],\n              totalWidth: 0,\n              maxSize: -Infinity\n            };\n            layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];\n            if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);\n            if (diffLayer < 0) {\n              layers_1[diffLayerAbs].left.push(node);\n            } else {\n              layers_1[diffLayerAbs].right.push(node);\n            }\n          }\n        }\n        var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;\n        var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;\n        if (leftPos < min_1) min_1 = leftPos;\n        if (rightPos > max_1) max_1 = rightPos;\n      });\n      // const padding = (max - min) * 0.1; // TODO\n      // \b初始化为第一圈的半径，后面根据每层 ranksep 叠加\n      var radius_1 = ranksep || 50; // TODO;\n      var radiusMap_1 = {};\n      // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n      var rangeLength_1 = (max_1 - min_1) / 0.9;\n      var range_1 = [(min_1 + max_1 - rangeLength_1) * 0.5, (min_1 + max_1 + rangeLength_1) * 0.5];\n      // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n      var processNodes_1 = function (layerNodes, radius, propsMaxRanksep, arcRange) {\n        if (propsMaxRanksep === void 0) {\n          propsMaxRanksep = -Infinity;\n        }\n        if (arcRange === void 0) {\n          arcRange = [0, 1];\n        }\n        var maxRanksep = propsMaxRanksep;\n        layerNodes.forEach(function (node) {\n          var coord = g.node(node);\n          radiusMap_1[node] = radius;\n          // 获取变形为 radial 后的直角坐标系坐标\n          var _a = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange),\n            newX = _a.x,\n            newY = _a.y;\n          // 将新坐标写入源数据\n          var i = nodes.findIndex(function (it) {\n            return it.id === node;\n          });\n          if (!nodes[i]) return;\n          nodes[i].x = newX + dBegin[0];\n          nodes[i].y = newY + dBegin[1];\n          // @ts-ignore: pass layer order to data for increment layout use\n          nodes[i]._order = coord._order;\n          // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n          var currentNodeRanksep = ranksepfunc(nodes[i]);\n          if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;\n        });\n        return maxRanksep;\n      };\n      var isFirstLevel_1 = true;\n      var lastLayerMaxNodeSize_1 = 0;\n      layers_1.forEach(function (layerNodes) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!((_a = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a === void 0 ? void 0 : _a.length) && !((_b = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b === void 0 ? void 0 : _b.length) && !((_c = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c === void 0 ? void 0 : _c.length)) return;\n        // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n        if (isFirstLevel_1 && layerNodes.nodes.length === 1) {\n          // 将新坐标写入源数据\n          var i = nodes.findIndex(function (it) {\n            return it.id === layerNodes.nodes[0];\n          });\n          if (i <= -1) return;\n          nodes[i].x = dBegin[0];\n          nodes[i].y = dBegin[1];\n          radiusMap_1[layerNodes.nodes[0]] = 0;\n          radius_1 = ranksepfunc(nodes[i]);\n          isFirstLevel_1 = false;\n          return;\n        }\n        // 为接缝留出空隙，半径也需要扩大\n        radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n        var maxRanksep = -Infinity;\n        if (focusLayer_1 === 0 || ((_d = layerNodes.nodes) === null || _d === void 0 ? void 0 : _d.length)) {\n          maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]); // 0.8\n        } else {\n          var leftRatio = ((_e = layerNodes.left) === null || _e === void 0 ? void 0 : _e.length) / (((_f = layerNodes.left) === null || _f === void 0 ? void 0 : _f.length) + ((_g = layerNodes.right) === null || _g === void 0 ? void 0 : _g.length));\n          maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [0, leftRatio]); // 接缝留出 0.05 的缝隙\n          maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [leftRatio + 0.05, 1]); // 接缝留出 0.05 的缝隙\n        }\n\n        radius_1 += maxRanksep;\n        isFirstLevel_1 = false;\n        lastLayerMaxNodeSize_1 - layerNodes.maxSize;\n      });\n      g.edges().forEach(function (edge) {\n        var _a, _b, _c;\n        var coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = (0, util_1.getEdgeTerminal)(it, 'source');\n          var target = (0, util_1.getEdgeTerminal)(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          var otherDim_1 = dim_1 === 'x' ? 'y' : 'x';\n          var controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1);\n          var newControlPoints_1 = [];\n          var sourceOtherDimValue_1 = (_b = g.node(edge.v)) === null || _b === void 0 ? void 0 : _b[otherDim_1];\n          var otherDimDist_1 = sourceOtherDimValue_1 - ((_c = g.node(edge.w)) === null || _c === void 0 ? void 0 : _c[otherDim_1]);\n          var sourceRadius_1 = radiusMap_1[edge.v];\n          var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];\n          controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function (point) {\n            // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n            var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1;\n            // 获取变形为 radial 后的直角坐标系坐标\n            var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);\n            newControlPoints_1.push({\n              x: newPos.x + dBegin[0],\n              y: newPos.y + dBegin[1]\n            });\n          });\n          edges[i].controlPoints = newControlPoints_1;\n        }\n      });\n    } else {\n      g.nodes().forEach(function (node) {\n        var coord = g.node(node);\n        if (!coord) return;\n        var ndata = nodes.find(function (it) {\n          return it.id === node;\n        });\n        if (!ndata) {\n          ndata = combos === null || combos === void 0 ? void 0 : combos.find(function (it) {\n            return it.id === node;\n          });\n        }\n        if (!ndata) return;\n        ndata.x = coord.x + dBegin[0];\n        ndata.y = coord.y + dBegin[1];\n        // @ts-ignore: pass layer order to data for increment layout use\n        ndata._order = coord._order;\n      });\n      g.edges().forEach(function (edge) {\n        var _a;\n        var coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = (0, util_1.getEdgeTerminal)(it, 'source');\n          var target = (0, util_1.getEdgeTerminal)(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = (_a = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a === void 0 ? void 0 : _a.slice(1, coord.points.length - 1); // 去掉头尾\n          edges[i].controlPoints.forEach(function (point) {\n            point.x += dBegin[0];\n            point.y += dBegin[1];\n          });\n        }\n      });\n    }\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes: nodes,\n      edges: edges\n    };\n  };\n  DagreLayout.prototype.getRadialPos = function (dimValue, range, rangeLength, radius, arcRange) {\n    if (arcRange === void 0) {\n      arcRange = [0, 1];\n    }\n    // dimRatio 占圆弧的比例\n    var dimRatio = (dimValue - range[0]) / rangeLength;\n    // 再进一步归一化到指定的范围上\n    dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];\n    // 使用最终归一化后的范围计算角度\n    var angle = dimRatio * 2 * Math.PI; // 弧度\n    // 将极坐标系转换为直角坐标系\n    return {\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    };\n  };\n  DagreLayout.prototype.getType = function () {\n    return \"dagre\";\n  };\n  return DagreLayout;\n}(base_1.Base);\nexports.DagreLayout = DagreLayout;","map":{"version":3,"mappings":"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","names":["__extends","options","_super","_this","nodeId","self","node","nodes","find","id","layout","updateCfg","DagreLayout","rankdir","align","undefined","nodeSize","nodesepFunc","ranksepFunc","nodesep","ranksep","controlPoints","radial","focusNode","combos","begin","_d","comboEdges","_e","vedges","edges","g","graph_1","multigraph","compound","nodeComboMap","forEach","comboId","push","nodeSizeFunc","d","size","width","height","ranksepfunc","nodesepfunc","horisep","vertisep","setDefaultEdgeLabel","setGraph","comboMap","sortByCombo","combo","collapsed","verti","hori","setNode","parentId","setParent","filter","layer","edge","source","target","layoutNode","setEdge","weight","concat","comboEdge","sources","targets","s","t","prevGraph","preset","index_1","edgeLabelSpace","keepNodeOrder","Boolean","nodeOrder","dBegin","minX_1","Infinity","minY_1","coord","x","y","points","point","getRadialPos_1","focusId","focusLayer_1","_rank","layers_1","isHorizontal","dim_1","sizeDim_1","min_1","max_1","i","findIndex","it","currentNodesep","totalWidth","maxSize","Math","max","diffLayer","diffLayerAbs","abs","left","right","leftPos","rightPos","radius_1","radiusMap_1","rangeLength_1","range_1","processNodes_1","layerNodes","radius","propsMaxRanksep","arcRange","maxRanksep","newX","newY","_order","currentNodeRanksep","isFirstLevel_1","lastLayerMaxNodeSize_1","length","PI","leftRatio","v","w","type","otherDim_1","slice","newControlPoints_1","sourceOtherDimValue_1","otherDimDist_1","sourceRadius_1","radiusDist_1","cRadius","newPos","ndata","onLayoutEnd","dimValue","range","rangeLength","dimRatio","angle","cos","sin","base_1","exports"],"sources":["/home/iam/Documents/network/node_modules/@antv/layout/src/layout/dagre.ts"],"sourcesContent":["/**\n * @fileOverview dagre layout\n * @author shiwu.wyy@antfin.com\n */\n\nimport { Edge, OutNode, DagreLayoutOptions, PointTuple, Point, Node } from \"./types\";\nimport dagre from \"./dagre/index\";\nimport { isArray, isNumber, isObject, getEdgeTerminal, getFunc, isString } from \"../util\";\nimport { Base } from \"./base\";\nimport { Graph as DagreGraph } from './dagre/graph';\n\n/**\n * 层次布局\n */\nexport class DagreLayout extends Base {\n  /** layout 方向, 可选 TB, BT, LR, RL */\n  public rankdir: \"TB\" | \"BT\" | \"LR\" | \"RL\" = \"TB\";\n\n  /** 节点对齐方式，可选 UL, UR, DL, DR */\n  public align: undefined | \"UL\" | \"UR\" | \"DL\" | \"DR\";\n\n  /** 布局的起始（左上角）位置 */\n  public begin: PointTuple;\n\n  /** 节点大小 */\n  public nodeSize: number | number[] | undefined;\n\n  /** 节点水平间距(px) */\n  public nodesepFunc: ((d?: any) => number) | undefined;\n\n  /** 每一层节点之间间距 */\n  public ranksepFunc: ((d?: any) => number) | undefined;\n\n  /** 节点水平间距(px) */\n  public nodesep: number = 50;\n\n  /** 每一层节点之间间距 */\n  public ranksep: number = 50;\n\n  /** 是否保留布局连线的控制点 */\n  public controlPoints: boolean = false;\n\n  /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n  public sortByCombo: boolean = false;\n\n  /** 是否保留每条边上的dummy node */\n  public edgeLabelSpace: boolean = true;\n\n  /** 是否基于 dagre 进行辐射布局，若是，第一层节点将被放置在最内环上，其余层依次向外辐射 */\n  public radial: boolean = false;\n\n  /** radial 下生效，中心节点，被指定的节点及其同层节点将被放置在最内环上 */\n  public focusNode: string | Node | null;\n\n  /** 给定的节点顺序，配合keepNodeOrder使用 */\n  public nodeOrder: string[];\n\n  /** 上次的布局结果 */\n  public preset: {\n    nodes: OutNode[],\n    edges: any[],\n  };\n\n  public nodes: OutNode[] = [];\n\n  public edges: Edge[] = [];\n\n  /** 迭代结束的回调函数 */\n  public onLayoutEnd: () => void = () => {};\n\n  constructor(options?: DagreLayoutOptions) {\n    super();\n    this.updateCfg(options);\n  }\n\n  public getDefaultCfg() {\n    return {\n      rankdir: \"TB\", // layout 方向, 可选 TB, BT, LR, RL\n      align: undefined, // 节点对齐方式，可选 UL, UR, DL, DR\n      nodeSize: undefined, // 节点大小\n      nodesepFunc: undefined, // 节点水平间距(px)\n      ranksepFunc: undefined, // 每一层节点之间间距\n      nodesep: 50, // 节点水平间距(px)\n      ranksep: 50, // 每一层节点之间间距\n      controlPoints: false, // 是否保留布局连线的控制点\n      radial: false, // 是否基于 dagre 进行辐射布局\n      focusNode: null, // radial 为 true 时生效，关注的节点\n    };\n  }\n\n  public layoutNode = (nodeId: string) => {\n    const self = this;\n    const { nodes } = self;\n    const node = nodes.find((node) => node.id === nodeId);\n    if (node) {\n      const layout = node.layout !== false;\n      return layout;\n    }\n    return true;\n  }\n\n  /**\n   * 执行布局\n   */\n  public execute() {\n    const self = this;\n    const { nodes, nodeSize, rankdir, combos, begin, radial, comboEdges = [], vedges = [] } = self;\n    if (!nodes) return;\n    const edges = (self.edges as any[]) || [];\n    const g = new DagreGraph({\n      multigraph: true,\n      compound: true,\n    });\n\n    // collect the nodes in their combo, to create virtual edges for comboEdges\n    const nodeComboMap = {} as any;\n    nodes.forEach(node => {\n      if (!node.comboId) return;\n      nodeComboMap[node.comboId] = nodeComboMap[node.comboId] || [];\n      nodeComboMap[node.comboId].push(node.id);\n    })\n\n    let nodeSizeFunc: (d?: any) => number[];\n    if (!nodeSize) {\n      nodeSizeFunc = (d: any) => {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }  if (isObject(d.size)) {\n            return [d.size.width || 40, d.size.height || 40];\n          }\n          return [d.size, d.size];\n        }\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = () => nodeSize;\n    } else {\n      nodeSizeFunc = () => [nodeSize, nodeSize];\n    }\n    const ranksepfunc = getFunc(self.ranksep, 50, self.ranksepFunc);\n    const nodesepfunc = getFunc(self.nodesep, 50, self.nodesepFunc);\n    let horisep: Function = nodesepfunc;\n    let vertisep: Function = ranksepfunc;\n\n    if (rankdir === \"LR\" || rankdir === \"RL\") {\n      horisep = ranksepfunc;\n      vertisep = nodesepfunc;\n    }\n    g.setDefaultEdgeLabel(() => ({}));\n    g.setGraph(self);\n\n    const comboMap: { [key: string]: any } = {};\n\n    if (this.sortByCombo && combos) {\n      combos.forEach((combo) => {\n        comboMap[combo.id] = combo;\n        // regard the collapsed combo as a node\n        if (combo.collapsed) {\n          const size = nodeSizeFunc(combo);\n          const verti = vertisep(combo);\n          const hori = horisep(combo);\n          const width = size[0] + 2 * hori;\n          const height = size[1] + 2 * verti;\n          g.setNode(combo.id, { width, height });\n        }\n        if (!combo.parentId) return;\n        if (!comboMap[combo.parentId]) {\n          g.setNode(combo.parentId, {});\n        }\n        g.setParent(combo.id, combo.parentId);\n      });\n    }\n\n    nodes.filter((node) => node.layout !== false).forEach((node) => {\n      const size = nodeSizeFunc(node);\n      const verti = vertisep(node);\n      const hori = horisep(node);\n      const width = size[0] + 2 * hori;\n      const height = size[1] + 2 * verti;\n      const layer = node.layer;\n      if (isNumber(layer)) {\n        // 如果有layer属性，加入到node的label中\n        g.setNode(node.id, { width, height, layer });\n      } else {\n        g.setNode(node.id, { width, height });\n      }\n\n      if (this.sortByCombo && node.comboId) {\n        if (!comboMap[node.comboId]) {\n          comboMap[node.comboId] = { id: node.comboId };\n          g.setNode(node.comboId, {});\n        }\n        g.setParent(node.id, node.comboId);\n      }\n    });\n    \n\n\n    edges.forEach((edge) => {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      const source = getEdgeTerminal(edge, 'source');\n      const target = getEdgeTerminal(edge, 'target');\n      if (this.layoutNode(source) && this.layoutNode(target)) {\n        g.setEdge(source, target, {\n          weight: edge.weight || 1,\n        });\n      }\n    });\n\n    // create virtual edges from node to node for comboEdges\n    (comboEdges?.concat(vedges || []))?.forEach((comboEdge: any) => {\n      const { source, target } = comboEdge;\n      const sources = comboMap[source]?.collapsed ? [source] : nodeComboMap[source] || [source];\n      const targets =  comboMap[target]?.collapsed ? [target] : nodeComboMap[target] || [target];\n      sources.forEach((s: string) => {\n        targets.forEach((t: string) => {\n          g.setEdge(s, t, {\n            weight: comboEdge.weight || 1,\n          });\n        })\n      })\n    })\n\n    // 考虑增量图中的原始图\n    let prevGraph: DagreGraph | undefined = undefined;\n    if (self.preset?.nodes) {\n      prevGraph = new DagreGraph({\n        multigraph: true,\n        compound: true,\n      });\n      self.preset.nodes.forEach((node) => {\n        prevGraph?.setNode(node.id, node);\n      });\n    }\n\n    dagre.layout(g, {\n      prevGraph,\n      edgeLabelSpace: self.edgeLabelSpace,\n      keepNodeOrder: Boolean(!!self.nodeOrder),\n      nodeOrder: self.nodeOrder,\n    });\n\n    const dBegin = [0, 0];\n    if (begin) {\n      let minX = Infinity;\n      let minY = Infinity;\n      g.nodes().forEach((node) => {\n        const coord = g.node(node)!;\n        if (minX > coord.x!) minX = coord.x!;\n        if (minY > coord.y!) minY = coord.y!;\n      });\n      g.edges().forEach((edge) => {\n        const coord = g.edge(edge)!;\n        coord.points?.forEach((point: any) => {\n          if (minX > point.x) minX = point.x;\n          if (minY > point.y) minY = point.y;\n        });\n      });\n      dBegin[0] = begin[0] - minX;\n      dBegin[1] = begin[1] - minY;\n    }\n\n    // 变形为辐射\n    if (radial) {\n      const { focusNode, ranksep, getRadialPos } = this;\n      const focusId = isString(focusNode) ? focusNode: focusNode?.id;\n      const focusLayer = focusId ? g.node(focusId)?._rank : 0;\n      const layers: any[] = [];\n      const isHorizontal = rankdir === 'LR' || rankdir === 'RL';\n      const dim = isHorizontal ? 'y' : 'x';\n      const sizeDim = isHorizontal ? 'height' : 'width';\n      // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度\n      let min = Infinity;\n      let max = -Infinity;\n      g.nodes().forEach((node: any) => {\n        const coord = g.node(node)! as any;\n        const i = nodes.findIndex((it) => it.id === node);\n        if (!nodes[i]) return;\n        const currentNodesep = nodesepfunc(nodes[i]);\n\n        if (focusLayer === 0) {\n          if (!layers[coord._rank]) layers[coord._rank] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n          layers[coord._rank].nodes.push(node);\n          layers[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim];\n          if (layers[coord._rank].maxSize < Math.max(coord.width, coord.height)) layers[coord._rank].maxSize = Math.max(coord.width, coord.height);\n        } else {\n          const diffLayer = coord._rank - focusLayer!;\n          if (diffLayer === 0) {\n            if (!layers[diffLayer]) layers[diffLayer] = { nodes: [], totalWidth: 0, maxSize: -Infinity };\n            layers[diffLayer].nodes.push(node);\n            layers[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim];\n            if (layers[diffLayer].maxSize < Math.max(coord.width, coord.height)) layers[diffLayer].maxSize = Math.max(coord.width, coord.height);\n          } else {\n            const diffLayerAbs = Math.abs(diffLayer);\n            if (!layers[diffLayerAbs]) layers[diffLayerAbs] = { left: [], right: [], totalWidth: 0, maxSize: -Infinity };\n            layers[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim];\n            if (layers[diffLayerAbs].maxSize < Math.max(coord.width, coord.height)) layers[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);\n            if (diffLayer < 0) {\n              layers[diffLayerAbs].left.push(node);\n            } else {\n              layers[diffLayerAbs].right.push(node);\n            }\n          }\n        }\n        const leftPos = coord[dim] - coord[sizeDim] / 2 - currentNodesep;\n        const rightPos = coord[dim] + coord[sizeDim] / 2 + currentNodesep;\n        if (leftPos < min) min = leftPos;\n        if (rightPos > max) max = rightPos;\n      });\n      // const padding = (max - min) * 0.1; // TODO\n      // \b初始化为第一圈的半径，后面根据每层 ranksep 叠加\n      let radius = ranksep || 50; // TODO;\n      const radiusMap: any = {};\n\n      // 扩大最大最小值范围，以便为环上留出接缝处的空隙\n      const rangeLength = (max - min) / 0.9;\n      const range = [ (min + max - rangeLength) * 0.5 , (min + max + rangeLength) * 0.5 ];\n\n      // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值\n      const processNodes = (layerNodes: any, radius: number, propsMaxRanksep = -Infinity, arcRange = [0, 1]) => {\n        let maxRanksep = propsMaxRanksep;\n        layerNodes.forEach((node: any) => {\n          const coord = g.node(node);\n          radiusMap[node] = radius;\n          // 获取变形为 radial 后的直角坐标系坐标\n          const { x: newX, y: newY } = getRadialPos(coord![dim]!, range, rangeLength, radius, arcRange);\n          // 将新坐标写入源数据\n          const i = nodes.findIndex((it) => it.id === node);\n          if (!nodes[i]) return;\n          nodes[i].x = newX + dBegin[0];\n          nodes[i].y = newY + dBegin[1];\n          // @ts-ignore: pass layer order to data for increment layout use\n          nodes[i]._order = coord._order;\n\n          // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上\n          const currentNodeRanksep = ranksepfunc(nodes[i]);\n          if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;\n        });\n        return maxRanksep;\n      };\n\n      let isFirstLevel = true;\n      const lastLayerMaxNodeSize = 0;\n      layers.forEach((layerNodes) => {\n        if (!layerNodes?.nodes?.length && !layerNodes?.left?.length && !layerNodes?.right?.length) return;\n        // 第一层只有一个节点，直接放在圆心，初始半径设定为 0\n        if (isFirstLevel && layerNodes.nodes.length === 1) {\n          // 将新坐标写入源数据\n          const i = nodes.findIndex((it) => it.id === layerNodes.nodes[0]);\n          if (i <= -1) return;\n          nodes[i].x = dBegin[0];\n          nodes[i].y = dBegin[1];\n          radiusMap[layerNodes.nodes[0]] = 0;\n          radius = ranksepfunc(nodes[i]);\n          isFirstLevel = false;\n          return;\n        }\n\n        // 为接缝留出空隙，半径也需要扩大\n        radius = Math.max(radius, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;\n        \n        let maxRanksep = -Infinity;\n        if (focusLayer === 0 || layerNodes.nodes?.length) {\n          maxRanksep = processNodes(layerNodes.nodes, radius, maxRanksep, [0, 1]); // 0.8\n        } else {\n          const leftRatio = layerNodes.left?.length / (layerNodes.left?.length + layerNodes.right?.length);\n          maxRanksep= processNodes(layerNodes.left, radius, maxRanksep, [0, leftRatio]); // 接缝留出 0.05 的缝隙\n          maxRanksep = processNodes(layerNodes.right, radius, maxRanksep, [leftRatio + 0.05, 1]); // 接缝留出 0.05 的缝隙\n        }\n        radius += maxRanksep;\n        isFirstLevel = false;\n        lastLayerMaxNodeSize - layerNodes.maxSize;\n      });\n      g.edges().forEach((edge: any) => {\n        const coord = g.edge(edge);\n        const i = edges.findIndex((it) => {\n          const source = getEdgeTerminal(it, 'source');\n          const target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n          const otherDim = dim === 'x' ? 'y' : 'x';\n          const controlPoints = coord?.points?.slice(1, coord.points.length - 1);\n          const newControlPoints: Point[] = [];\n          const sourceOtherDimValue = g.node(edge.v)?.[otherDim]!;\n          const otherDimDist = sourceOtherDimValue - g.node(edge.w)?.[otherDim]!;\n          const sourceRadius = radiusMap[edge.v];\n          const radiusDist = sourceRadius - radiusMap[edge.w];\n          controlPoints?.forEach((point: any) => {\n            // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径\n            const cRadius = (point[otherDim] - sourceOtherDimValue) / otherDimDist * radiusDist + sourceRadius;\n            // 获取变形为 radial 后的直角坐标系坐标\n            const newPos = getRadialPos(point[dim], range, rangeLength, cRadius);\n            newControlPoints.push({\n              x: newPos.x + dBegin[0],\n              y: newPos.y + dBegin[1]\n            });\n          });\n          edges[i].controlPoints = newControlPoints;\n        }\n      });\n    } else {\n      g.nodes().forEach((node: any) => {\n        const coord = g.node(node)!;\n        if (!coord) return;\n        let ndata: any = nodes.find((it) => it.id === node);\n        if (!ndata) {\n          ndata = combos?.find((it) => it.id === node);\n        }\n        if (!ndata) return;\n        ndata.x = coord.x! + dBegin[0];\n        ndata.y = coord.y! + dBegin[1];\n        // @ts-ignore: pass layer order to data for increment layout use\n        ndata._order = coord._order;\n      });\n      g.edges().forEach((edge: any) => {\n        const coord = g.edge(edge);\n        const i = edges.findIndex((it) => {\n          const source = getEdgeTerminal(it, 'source');\n          const target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n        if (i <= -1) return;\n        if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = coord?.points?.slice(1, coord.points.length - 1); // 去掉头尾\n          edges[i].controlPoints.forEach((point: any) => {\n            point.x += dBegin[0];\n            point.y += dBegin[1];\n          });\n        }\n      });\n    }\n\n    if (self.onLayoutEnd) self.onLayoutEnd();\n    return {\n      nodes,\n      edges,\n    };\n  }\n\n  private getRadialPos(dimValue: number, range: number[], rangeLength: number, radius: number, arcRange: number[] = [0, 1]) {\n    // dimRatio 占圆弧的比例\n    let dimRatio = (dimValue - range[0]) / rangeLength;\n    // 再进一步归一化到指定的范围上\n    dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];\n    // 使用最终归一化后的范围计算角度\n    const angle = dimRatio * 2 * Math.PI; // 弧度\n    // 将极坐标系转换为直角坐标系\n    return {\n      x: Math.cos(angle) * radius,\n      y: Math.sin(angle) * radius\n    };\n  }\n\n  public getType() {\n    return \"dagre\";\n  }\n}"]},"metadata":{},"sourceType":"script","externalDependencies":[]}