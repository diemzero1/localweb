{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar resolveConflicts = function resolveConflicts(entries, cg) {\n  var _a, _b, _c;\n  var mappedEntries = {};\n  entries === null || entries === void 0 ? void 0 : entries.forEach(function (entry, i) {\n    mappedEntries[entry.v] = {\n      i: i,\n      indegree: 0,\n      in: [],\n      out: [],\n      vs: [entry.v]\n    };\n    var tmp = mappedEntries[entry.v];\n    if (entry.barycenter !== undefined) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n  (_a = cg.edges()) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var entryV = mappedEntries[e.v];\n    var entryW = mappedEntries[e.w];\n    if (entryV !== undefined && entryW !== undefined) {\n      entryW.indegree++;\n      entryV.out.push(mappedEntries[e.w]);\n    }\n  });\n  var sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, function (entry) {\n    return !entry.indegree;\n  });\n  return doResolveConflicts(sourceSet);\n};\nvar doResolveConflicts = function doResolveConflicts(sourceSet) {\n  var _a, _b;\n  var entries = [];\n  var handleIn = function handleIn(vEntry) {\n    return function (uEntry) {\n      if (uEntry.merged) return;\n      if (uEntry.barycenter === undefined || vEntry.barycenter === undefined || uEntry.barycenter >= vEntry.barycenter) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  };\n  var handleOut = function handleOut(vEntry) {\n    return function (wEntry) {\n      wEntry[\"in\"].push(vEntry);\n      if (--wEntry.indegree === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  };\n  var _loop_1 = function _loop_1() {\n    var entry = sourceSet.pop();\n    entries.push(entry);\n    (_a = entry[\"in\"].reverse()) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n      return handleIn(entry)(e);\n    });\n    (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach(function (e) {\n      return handleOut(entry)(e);\n    });\n  };\n  while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {\n    _loop_1();\n  }\n  var filtered = entries.filter(function (entry) {\n    return !entry.merged;\n  });\n  var keys = [\"vs\", \"i\", \"barycenter\", \"weight\"];\n  return filtered.map(function (entry) {\n    var picked = {};\n    keys === null || keys === void 0 ? void 0 : keys.forEach(function (key) {\n      if (entry[key] === undefined) return;\n      picked[key] = entry[key];\n    });\n    return picked;\n  });\n};\nvar mergeEntries = function mergeEntries(target, source) {\n  var _a;\n  var sum = 0;\n  var weight = 0;\n  if (target.weight) {\n    sum += target.barycenter * target.weight;\n    weight += target.weight;\n  }\n  if (source.weight) {\n    sum += source.barycenter * source.weight;\n    weight += source.weight;\n  }\n  target.vs = (_a = source.vs) === null || _a === void 0 ? void 0 : _a.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n};\nexports.default = resolveConflicts;","map":{"version":3,"mappings":"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","names":["resolveConflicts","entries","cg","mappedEntries","forEach","entry","i","v","indegree","in","out","vs","tmp","barycenter","undefined","weight","edges","e","entryV","entryW","w","push","sourceSet","values","filter","doResolveConflicts","handleIn","vEntry","uEntry","merged","mergeEntries","handleOut","wEntry","pop","reverse","length","filtered","keys","map","picked","key","target","source","sum","concat","Math","min","exports"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/order/resolve-conflicts.ts"],"sourcesContent":["import { Graph } from \"../../graph\";\n\n/*\n * Given a list of entries of the form {v, barycenter, weight} and a\n * constraint graph this function will resolve any conflicts between the\n * constraint graph and the barycenters for the entries. If the barycenters for\n * an entry would violate a constraint in the constraint graph then we coalesce\n * the nodes in the conflict into a new node that respects the contraint and\n * aggregates barycenter and weight information.\n *\n * This implementation is based on the description in Forster, \"A Fast and\n * Simple Hueristic for Constrained Two-Level Crossing Reduction,\" thought it\n * differs in some specific details.\n *\n * Pre-conditions:\n *\n *    1. Each entry has the form {v, barycenter, weight}, or if the node has\n *       no barycenter, then {v}.\n *\n * Returns:\n *\n *    A new list of entries of the form {vs, i, barycenter, weight}. The list\n *    `vs` may either be a singleton or it may be an aggregation of nodes\n *    ordered such that they do not violate constraints from the constraint\n *    graph. The property `i` is the lowest original index of any of the\n *    elements in `vs`.\n */\n\nexport type ConflictEntry = {\n  i: number;\n  indegree?: number;\n  in?: ConflictEntry[];\n  out?: ConflictEntry[];\n  vs: string[];\n  barycenter?: number;\n  weight?: number;\n  merged?: boolean;\n  fixorder?: number;\n  order?: number;\n};\n\nconst resolveConflicts = (\n  entries: {\n    v: string;\n    barycenter?: number;\n    weight?: number;\n  }[],\n  cg: Graph\n) => {\n  const mappedEntries: Record<string, ConflictEntry> = {};\n  entries?.forEach((entry, i: number) => {\n    mappedEntries[entry.v] = {\n      i,\n      indegree: 0,\n      in: [],\n      out: [],\n      vs: [entry.v],\n    };\n    const tmp = mappedEntries[entry.v];\n    if (entry.barycenter !== undefined) {\n      tmp.barycenter = entry.barycenter;\n      tmp.weight = entry.weight;\n    }\n  });\n\n  cg.edges()?.forEach((e) => {\n    const entryV = mappedEntries[e.v];\n    const entryW = mappedEntries[e.w];\n    if (entryV !== undefined && entryW !== undefined) {\n      entryW.indegree!++;\n      entryV.out!.push(mappedEntries[e.w]);\n    }\n  });\n\n  const sourceSet = Object.values(mappedEntries).filter?.(\n    (entry: ConflictEntry) => !entry.indegree\n  );\n\n  return doResolveConflicts(sourceSet);\n};\n\nconst doResolveConflicts = (sourceSet: ConflictEntry[]) => {\n  const entries = [];\n\n  const handleIn = (vEntry: ConflictEntry) => {\n    return (uEntry: ConflictEntry) => {\n      if (uEntry.merged) return;\n      if (\n        uEntry.barycenter === undefined ||\n        vEntry.barycenter === undefined ||\n        uEntry.barycenter >= vEntry.barycenter\n      ) {\n        mergeEntries(vEntry, uEntry);\n      }\n    };\n  };\n\n  const handleOut = (vEntry: ConflictEntry) => {\n    return (wEntry: ConflictEntry) => {\n      wEntry[\"in\"]!.push(vEntry);\n      if (--wEntry.indegree! === 0) {\n        sourceSet.push(wEntry);\n      }\n    };\n  };\n\n  while (sourceSet?.length) {\n    const entry = sourceSet.pop()!;\n    entries.push(entry);\n    entry[\"in\"]!.reverse()?.forEach((e: ConflictEntry) => handleIn(entry)(e));\n    entry.out?.forEach((e: ConflictEntry) => handleOut(entry)(e));\n  }\n\n  const filtered = entries.filter((entry) => !entry.merged);\n  const keys: (\"vs\" | \"i\" | \"barycenter\" | \"weight\")[] = [\n    \"vs\",\n    \"i\",\n    \"barycenter\",\n    \"weight\",\n  ];\n  return filtered.map((entry) => {\n    const picked: Record<string, any> = {};\n    keys?.forEach((key) => {\n      if (entry[key] === undefined) return;\n      picked[key] = entry[key];\n    });\n    return picked as ConflictEntry;\n  });\n};\n\nconst mergeEntries = (target: ConflictEntry, source: ConflictEntry) => {\n  let sum = 0;\n  let weight = 0;\n\n  if (target.weight) {\n    sum += target.barycenter! * target.weight;\n    weight += target.weight;\n  }\n\n  if (source.weight) {\n    sum += source.barycenter! * source.weight;\n    weight += source.weight;\n  }\n\n  target.vs = source.vs?.concat(target.vs);\n  target.barycenter = sum / weight;\n  target.weight = weight;\n  target.i = Math.min(source.i, target.i);\n  source.merged = true;\n};\n\nexport default resolveConflicts;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}