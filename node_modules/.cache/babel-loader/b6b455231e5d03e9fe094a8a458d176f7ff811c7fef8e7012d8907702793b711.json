{"ast":null,"code":"import { __values } from \"tslib\";\nimport { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\n/** label text和line距离 4px */\nvar MARGIN = 4;\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\nfunction drawLabelline(item /** PolarLabelItem */, coordinate) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  if (item && item.labelLine) {\n    var angle = item.angle,\n      labelOffset = item.offset;\n    // 贴近圆周\n    var startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    var itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    var itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n    var endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN\n    };\n    var smoothConnector = item.labelLine.smooth;\n    var path = [];\n    var dx = endPoint.x - center.x;\n    var dy = endPoint.y - center.y;\n    var endAngle = Math.atan(dy / dx);\n    // 第三象限 & 第四象限\n    if (dx < 0) {\n      endAngle += Math.PI;\n    }\n    // 默认 smooth, undefined 也为 smooth\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n      // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n      var sweepFlag = 0;\n      // 第一象限\n      if (angle < 0 && angle > -Math.PI / 2 || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n      // 第二象限\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n      // 第三象限\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n      // 第四象限\n      if (angle < -Math.PI / 2 || angle >= Math.PI && angle < Math.PI * 1.5) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n      var distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      var breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);\n      // 圆弧的结束点\n      var breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n      var largeArcFlag = 0;\n      // step1: 移动至起点\n      path.push(\"M \".concat(startPoint.x, \" \").concat(startPoint.y));\n      // step2: 连接拐点\n      path.push(\"L \".concat(breakPoint.x, \" \").concat(breakPoint.y));\n      // step3: 绘制圆弧 至 结束点\n      path.push(\"A \".concat(center.x, \" \").concat(center.y, \" 0 \").concat(largeArcFlag, \" \").concat(sweepFlag, \" \").concat(breakPoint3.x, \" \").concat(breakPoint3.y));\n      // step4: 连接结束点\n      path.push(\"L \".concat(endPoint.x, \" \").concat(endPoint.y));\n    } else {\n      var breakPoint = polarToCartesian(center.x, center.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle);\n      // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n      var xSign = startPoint.x < center.x ? 1 : -1;\n      // step1: 连接结束点\n      path.push(\"M \".concat(endPoint.x, \" \").concat(endPoint.y));\n      var slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      var slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push.apply(path, ['C', endPoint.x + xSign * 4, endPoint.y, 2 * breakPoint.x - startPoint.x, 2 * breakPoint.y - startPoint.y, startPoint.x, startPoint.y]);\n      }\n      // step3: 连接至起点\n      path.push(\"L \".concat(startPoint.x, \" \").concat(startPoint.y));\n    }\n    item.labelLine.path = path.join(' ');\n  }\n}\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\nexport function pieOuterLabelLayout(originalItems, labels, shapes, region) {\n  var e_1, _a;\n  var items = filter(originalItems, function (item) {\n    return !isNil(item);\n  });\n  /** 坐标系 */\n  var coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  /** label shapes */\n  var labelsMap = {};\n  try {\n    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n      var labelShape = labels_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  // note labelHeight 可以控制 label 的行高\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = get(items[0], 'offset', 0);\n  if (labelOffset <= 0) {\n    return;\n  }\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  var start = coordinate.start,\n    end = coordinate.end;\n  // step2: calculate totalHeight\n  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  var totalR = totalHeight / 2;\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR\n  };\n  // step 3: antiCollision\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  each(separateLabels, function (half, key) {\n    each(half, function (item) {\n      var isRight = key === RIGHT_HALF_KEY;\n      var labelShape = labelsMap[item.id];\n      // because group could not effect content-shape, should set content-shape position manually\n      var content = labelShape.getChildByIndex(0);\n      // textShape 发生过调整\n      if (content) {\n        var r = radius + labelOffset;\n        // (x - cx)^2 + (y - cy)^2 = totalR^2\n        var dy = item.y - center.y;\n        var rPow2 = Math.pow(r, 2);\n        var dyPow2 = Math.pow(dy, 2);\n        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        var dx = Math.sqrt(dxPow2);\n        var dx_offset = Math.abs(Math.cos(item.angle) * r);\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      }\n      // adjust labelShape\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n      drawLabelline(item, coordinate);\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["isObject","each","get","groupBy","isNil","filter","polarToCartesian","antiCollision","MARGIN","drawLabelline","item","coordinate","center","getCenter","radius","getRadius","labelLine","labelOffset","startPoint","x","y","angle","itemX","Math","cos","itemY","sin","endPoint","smoothConnector","smooth","path","dx","dy","endAngle","atan","PI","sweepFlag","distance","max","breakPoint","breakPoint3","largeArcFlag","push","xSign","slope1","slope2","abs","pow","E","join","pieOuterLabelLayout","originalItems","labels","shapes","region","items","labelsMap","labelShape","labelHeight","LEFT_HALF_KEY","RIGHT_HALF_KEY","separateLabels","end","totalHeight","min","getHeight","totalR","labelsContainerRange","minX","start","maxX","minY","maxY","half","key","maxLabelsCountForOneSide","floor","length","sort","a","b","percent","labelItem","idx","id","set","invisible","isRight","content","getChildByIndex","r","rPow2","dyPow2","dxPow2","sqrt","dx_offset","attr"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g2/src/geometry/label/layout/pie/outer.ts"],"sourcesContent":["import { Coordinate } from '@antv/coord';\nimport { BBox, IGroup, IShape, IElement } from '@antv/g-base';\nimport { isObject, each, get, groupBy, isNil, filter } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\n\n/** label text和line距离 4px */\nconst MARGIN = 4;\n\n/**\n * 配置 labelline\n * @param item PolarLabelItem\n */\nfunction drawLabelline(item: any /** PolarLabelItem */, coordinate: Coordinate) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n\n  if (item && item.labelLine) {\n    const { angle, offset: labelOffset } = item;\n    // 贴近圆周\n    const startPoint = polarToCartesian(center.x, center.y, radius, angle);\n    const itemX = item.x + get(item, 'offsetX', 0) * (Math.cos(angle) > 0 ? 1 : -1);\n    const itemY = item.y + get(item, 'offsetY', 0) * (Math.sin(angle) > 0 ? 1 : -1);\n\n    const endPoint = {\n      x: itemX - Math.cos(angle) * MARGIN,\n      y: itemY - Math.sin(angle) * MARGIN,\n    };\n\n    const smoothConnector = item.labelLine.smooth;\n    const path = [];\n    const dx = endPoint.x - center.x;\n    const dy = endPoint.y - center.y;\n    let endAngle = Math.atan(dy / dx);\n    // 第三象限 & 第四象限\n    if (dx < 0) {\n      endAngle += Math.PI;\n    }\n\n    // 默认 smooth, undefined 也为 smooth\n    if (smoothConnector === false) {\n      if (!isObject(item.labelLine)) {\n        // labelLine: true\n        item.labelLine = {};\n      }\n\n      // 表示弧线的方向，0 表示从起点到终点沿逆时针画弧, 1 表示顺时针\n      let sweepFlag = 0;\n\n      // 第一象限\n      if ((angle < 0 && angle > -Math.PI / 2) || angle > Math.PI * 1.5) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第二象限\n      if (angle >= 0 && angle < Math.PI / 2) {\n        if (endPoint.y > startPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第三象限\n      if (angle >= Math.PI / 2 && angle < Math.PI) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      // 第四象限\n      if (angle < -Math.PI / 2 || (angle >= Math.PI && angle < Math.PI * 1.5)) {\n        if (startPoint.y > endPoint.y) {\n          sweepFlag = 1;\n        }\n      }\n\n      const distance = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);\n      const breakPoint = polarToCartesian(center.x, center.y, radius + distance, angle);\n      // 圆弧的结束点\n      const breakPoint3 = polarToCartesian(center.x, center.y, radius + labelOffset / 2, endAngle);\n\n      /**\n       * @example\n       * M 100 100 L100 90 A 50 50 0 0 0 150 50\n       * 移动至 (100, 100), 连接到 (100, 90), 以 (50, 50) 为圆心，绘制圆弧至 (150, 50);\n       * A 命令的第 4 个参数 large-arc-flag, 决定弧线是大于还是小于 180 度: 0 表示小角度弧，1 表示大角\n       * 第 5 个参数: 是否顺时针绘制\n       */\n      // 默认小弧\n      const largeArcFlag = 0;\n      // step1: 移动至起点\n      path.push(`M ${startPoint.x} ${startPoint.y}`);\n      // step2: 连接拐点\n      path.push(`L ${breakPoint.x} ${breakPoint.y}`);\n      // step3: 绘制圆弧 至 结束点\n      path.push(`A ${center.x} ${center.y} 0 ${largeArcFlag} ${sweepFlag} ${breakPoint3.x} ${breakPoint3.y}`);\n      // step4: 连接结束点\n      path.push(`L ${endPoint.x} ${endPoint.y}`);\n    } else {\n      const breakPoint = polarToCartesian(\n        center.x,\n        center.y,\n        radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)),\n        angle\n      );\n      // G2 旧的拉线\n      // path.push('Q', `${breakPoint.x}`, `${breakPoint.y}`, `${endPoint.x}`, `${endPoint.y}`);\n      const xSign = startPoint.x < center.x ? 1 : -1;\n      // step1: 连接结束点\n      path.push(`M ${endPoint.x} ${endPoint.y}`);\n      const slope1 = (startPoint.y - center.y) / (startPoint.x - center.x);\n      const slope2 = (endPoint.y - center.y) / (endPoint.x - center.x);\n      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {\n        // step2: 绘制 curve line (起点 & 结合点与圆心的斜率不等时, 由于存在误差, 使用近似处理)\n        path.push(\n          ...[\n            'C',\n            endPoint.x + xSign * 4,\n            endPoint.y,\n            2 * breakPoint.x - startPoint.x,\n            2 * breakPoint.y - startPoint.y,\n            startPoint.x,\n            startPoint.y,\n          ]\n        );\n      }\n      // step3: 连接至起点\n      path.push(`L ${startPoint.x} ${startPoint.y}`);\n    }\n    item.labelLine.path = path.join(' ');\n  }\n}\n\n/**\n * 饼图 outer-label 布局, 适用于 type = pie 且 label offset > 0 的标签\n */\nexport function pieOuterLabelLayout(\n  originalItems: PolarLabelItem[],\n  labels: IGroup[],\n  shapes: IShape[] | IGroup[],\n  region: BBox\n) {\n  const items = filter(originalItems, (item) => !isNil(item));\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  // note labelHeight 可以控制 label 的行高\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = get(items[0], 'offset', 0);\n\n  if (labelOffset <= 0) {\n    return;\n  }\n\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  const { start, end } = coordinate;\n  // step2: calculate totalHeight\n  const totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate.getHeight());\n  const totalR = totalHeight / 2;\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalR,\n    maxY: center.y + totalR,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx + 1 > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  each(separateLabels, (half: PolarLabelItem[], key: string) => {\n    each(half, (item: PolarLabelItem) => {\n      const isRight = key === RIGHT_HALF_KEY;\n      const labelShape = labelsMap[item.id];\n\n      // because group could not effect content-shape, should set content-shape position manually\n      const content = labelShape.getChildByIndex(0) as IElement;\n\n      // textShape 发生过调整\n      if (content) {\n        const r = radius + labelOffset;\n        // (x - cx)^2 + (y - cy)^2 = totalR^2\n        const dy = item.y - center.y;\n\n        const rPow2 = Math.pow(r, 2);\n        const dyPow2 = Math.pow(dy, 2);\n        const dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;\n        const dx = Math.sqrt(dxPow2);\n\n        const dx_offset = Math.abs(Math.cos(item.angle) * r);\n        if (!isRight) {\n          // left\n          item.x = center.x - Math.max(dx, dx_offset);\n        } else {\n          // right\n          item.x = center.x + Math.max(dx, dx_offset);\n        }\n      }\n\n      // adjust labelShape\n      if (content) {\n        content.attr('y', item.y);\n        content.attr('x', item.x);\n      }\n\n      drawLabelline(item, coordinate);\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}