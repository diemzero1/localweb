{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spreadArray } from \"tslib\";\nimport { deepMix, each, get, isArray, isFunction, isNil, isNumber, isUndefined } from '@antv/util';\nimport { FIELD_ORIGIN } from '../../constant';\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\nimport Labels from '../../component/labels';\nfunction avg(arr) {\n  var sum = 0;\n  each(arr, function (value) {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nvar GeometryLabel = /** @class */function () {\n  function GeometryLabel(geometry) {\n    this.geometry = geometry;\n  }\n  GeometryLabel.prototype.getLabelItems = function (mapppingArray) {\n    var _this = this;\n    var items = [];\n    var labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, function (mappingData, index) {\n      var labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n      var labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      var total = labelContent.length;\n      each(labelContent, function (content, subIndex) {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n        var item = __assign(__assign({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));\n        if (!item.textAlign) {\n          item.textAlign = _this.getLabelAlign(item, subIndex, total);\n        }\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n        items.push(item);\n      });\n    });\n    return items;\n  };\n  GeometryLabel.prototype.render = function (mappingArray, isUpdate) {\n    if (isUpdate === void 0) {\n      isUpdate = false;\n    }\n    return __awaiter(this, void 0, void 0, function () {\n      var labelItems, labelsRenderer, shapes;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            labelItems = this.getLabelItems(mappingArray);\n            labelsRenderer = this.getLabelsRenderer();\n            shapes = this.getGeometryShapes();\n            // 渲染文本\n            return [4 /*yield*/, labelsRenderer.render(labelItems, shapes, isUpdate)];\n          case 1:\n            // 渲染文本\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  GeometryLabel.prototype.clear = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  };\n  GeometryLabel.prototype.destroy = function () {\n    var labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  };\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  GeometryLabel.prototype.getCoordinate = function () {\n    return this.geometry.coordinate;\n  };\n  /**\n   * 获取 label 的默认配置\n   */\n  GeometryLabel.prototype.getDefaultLabelCfg = function (offset, position) {\n    var geometry = this.geometry;\n    var type = geometry.type,\n      theme = geometry.theme;\n    if (type === 'polygon' || type === 'interval' && position === 'middle' || offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n    return get(theme, 'labels', {});\n  };\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  GeometryLabel.prototype.getThemedLabelCfg = function (labelCfg) {\n    var geometry = this.geometry;\n    var defaultLabelCfg = this.getDefaultLabelCfg();\n    var type = geometry.type,\n      theme = geometry.theme;\n    var themedLabelCfg;\n    if (type === 'polygon' || labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type)) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n    return themedLabelCfg;\n  };\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  GeometryLabel.prototype.setLabelPosition = function (labelPointCfg, mappingData, index, position) {};\n  /**\n   * @desc 获取 label offset\n   */\n  GeometryLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  };\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  GeometryLabel.prototype.getLabelOffsetPoint = function (labelCfg, index, total) {\n    var offset = labelCfg.offset;\n    var coordinate = this.getCoordinate();\n    var transposed = coordinate.isTransposed;\n    var dim = transposed ? 'x' : 'y';\n    var factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    var offsetPoint = {\n      x: 0,\n      y: 0\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  };\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  GeometryLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var coordinate = this.getCoordinate();\n    var total = labelCfg.content.length;\n    function getDimValue(value, idx, isAvg) {\n      if (isAvg === void 0) {\n        isAvg = false;\n      }\n      var v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[value.length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n    var label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: {\n        x: 0,\n        y: 0\n      },\n      color: '#fff'\n    };\n    var shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    var isFunnel = shape === 'funnel' || shape === 'pyramid';\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      var centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      var nextPoints = get(mappingData, 'nextPoints');\n      var points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(nextPoints[1]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        var point1 = coordinate.convert(points[1]);\n        var point2 = coordinate.convert(points[2]);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    var offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = {\n      x: label.x,\n      y: label.y\n    };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  };\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  GeometryLabel.prototype.getLabelAlign = function (item, index, total) {\n    var align = 'center';\n    var coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      var offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  };\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  GeometryLabel.prototype.getLabelId = function (mappingData) {\n    var geometry = this.geometry;\n    var type = geometry.type;\n    var xScale = geometry.getXScale();\n    var yScale = geometry.getYScale();\n    var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n    var labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += \" \".concat(origin[xScale.field]);\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += \" \".concat(origin[xScale.field], \"-\").concat(origin[yScale.field]);\n    }\n    return labelId;\n  };\n  // 获取 labels 组件\n  GeometryLabel.prototype.getLabelsRenderer = function () {\n    var _a = this.geometry,\n      labelsContainer = _a.labelsContainer,\n      labelOption = _a.labelOption,\n      canvasRegion = _a.canvasRegion,\n      animateOption = _a.animateOption;\n    var coordinate = this.geometry.coordinate;\n    var labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout\n        })\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n    return labelsRenderer;\n  };\n  GeometryLabel.prototype.getLabelCfgs = function (mapppingArray) {\n    var _this = this;\n    var geometry = this.geometry;\n    var labelOption = geometry.labelOption,\n      scales = geometry.scales,\n      coordinate = geometry.coordinate;\n    var _a = labelOption,\n      fields = _a.fields,\n      callback = _a.callback,\n      cfg = _a.cfg;\n    var labelScales = fields.map(function (field) {\n      return scales[field];\n    });\n    var labelCfgs = [];\n    each(mapppingArray, function (mappingData, index) {\n      var origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      var originText = _this.getLabelText(origin, labelScales);\n      var callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        var originValues = fields.map(function (field) {\n          return origin[field];\n        });\n        callbackCfg = callback.apply(void 0, __spreadArray([], __read(originValues), false));\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n      var labelCfg = __assign(__assign({\n        id: _this.getLabelId(mappingData),\n        elementId: _this.geometry.getElementId(mappingData),\n        data: origin,\n        // 存储原始数据\n        mappingData: mappingData,\n        // 存储映射后的数据,\n        coordinate: coordinate\n      }, cfg), callbackCfg);\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n      var offset = _this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);\n      var content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n      labelCfgs.push(labelCfg);\n    });\n    return labelCfgs;\n  };\n  GeometryLabel.prototype.getLabelText = function (origin, scales) {\n    var labelTexts = [];\n    each(scales, function (scale) {\n      var value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map(function (subVal) {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  };\n  GeometryLabel.prototype.getOffsetVector = function (offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  };\n  GeometryLabel.prototype.getGeometryShapes = function () {\n    var geometry = this.geometry;\n    var shapes = {};\n    each(geometry.elementsMap, function (element, id) {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), function (child) {\n      var id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n    return shapes;\n  };\n  return GeometryLabel;\n}();\nexport default GeometryLabel;","map":{"version":3,"mappings":"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","names":["deepMix","each","get","isArray","isFunction","isNil","isNumber","isUndefined","FIELD_ORIGIN","getDefaultAnimateCfg","getPolygonCentroid","Labels","avg","arr","sum","value","length","geometry","GeometryLabel","mapppingArray","items","labelCfgs","getLabelCfgs","mappingData","index","labelCfg","x","y","push","labelContent","content","total","subIndex","item","_this","getLabelPoint","textAlign","getLabelAlign","offset","labelLine","mappingArray","isUpdate","labelItems","getLabelItems","labelsRenderer","getLabelsRenderer","shapes","getGeometryShapes","render","_a","clear","destroy","coordinate","position","theme","type","includes","defaultLabelCfg","getDefaultLabelCfg","themedLabelCfg","innerLabels","labels","labelPointCfg","getCoordinate","vector","getOffsetVector","isTransposed","transposed","dim","factor","offsetPoint","getDimValue","idx","isAvg","v","label","start","color","shape","isFunnel","centroid","nextPoints","points","point1","convert","point2","setLabelPosition","getLabelOffsetPoint","align","xScale","getXScale","yScale","getYScale","origin","labelId","getElementId","field","labelsContainer","labelOption","canvasRegion","animateOption","container","layout","defaultLayout","region","animate","scales","fields","callback","cfg","labelScales","map","originText","getLabelText","callbackCfg","originValues","id","getLabelId","elementId","data","getLabelOffset","labelTexts","scale","subVal","getText","actualOffset","applyMatrix","elementsMap","element","getOffscreenGroup","getChildren","child"],"sources":["/home/iam/Documents/network/node_modules/@antv/g2/src/geometry/label/base.ts"],"sourcesContent":["import { deepMix, each, get, isArray, isFunction, isNil, isNumber, isString, isUndefined } from '@antv/util';\n\nimport { FIELD_ORIGIN } from '../../constant';\nimport { Scale } from '../../dependents';\nimport { Datum, LabelOption, MappingDatum, Point } from '../../interface';\nimport { LabelCfg, LabelItem, LabelPointCfg, TextAlign } from './interface';\n\nimport { getDefaultAnimateCfg } from '../../animate';\nimport { getPolygonCentroid } from '../../util/graphics';\n\nimport Labels from '../../component/labels';\nimport Geometry from '../base';\nimport Element from '../element';\n\nexport type GeometryLabelConstructor = new (cfg: any) => GeometryLabel;\n\nfunction avg(arr: number[]) {\n  let sum = 0;\n  each(arr, (value: number) => {\n    sum += value;\n  });\n  return sum / arr.length;\n}\n\n/**\n * Geometry Label 基类，用于生成 Geometry 下所有 label 的配置项信息\n */\nexport default class GeometryLabel {\n  /** geometry 实例 */\n  public readonly geometry: Geometry;\n  public labelsRenderer: Labels;\n  /** 默认的布局 */\n  public defaultLayout: string;\n\n  constructor(geometry: Geometry) {\n    this.geometry = geometry;\n  }\n\n  public getLabelItems(mapppingArray: MappingDatum[]): LabelItem[] {\n    const items = [];\n    const labelCfgs = this.getLabelCfgs(mapppingArray);\n    // 获取 label 相关的 x，y 的值，获取具体的 x, y，防止存在数组\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const labelCfg = labelCfgs[index];\n      if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {\n        items.push(null);\n        return;\n      }\n\n      const labelContent = !isArray(labelCfg.content) ? [labelCfg.content] : labelCfg.content;\n      labelCfg.content = labelContent;\n      const total = labelContent.length;\n      each(labelContent, (content, subIndex) => {\n        if (isNil(content) || content === '') {\n          items.push(null);\n          return;\n        }\n\n        const item = {\n          ...labelCfg,\n          ...this.getLabelPoint(labelCfg, mappingData, subIndex),\n        };\n        if (!item.textAlign) {\n          item.textAlign = this.getLabelAlign(item, subIndex, total);\n        }\n\n        if (item.offset <= 0) {\n          item.labelLine = null;\n        }\n\n        items.push(item);\n      });\n    });\n    return items;\n  }\n\n  public async render(mappingArray: MappingDatum[], isUpdate: boolean = false) {\n    const labelItems = this.getLabelItems(mappingArray);\n    const labelsRenderer = this.getLabelsRenderer();\n    const shapes = this.getGeometryShapes();\n    // 渲染文本\n    await labelsRenderer.render(labelItems, shapes, isUpdate);\n  }\n\n  public clear() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.clear();\n    }\n  }\n\n  public destroy() {\n    const labelsRenderer = this.labelsRenderer;\n    if (labelsRenderer) {\n      labelsRenderer.destroy();\n    }\n    this.labelsRenderer = null;\n  }\n\n  // geometry 更新之后，对应的 Coordinate 也会更新，为了获取到最新鲜的 Coordinate，故使用方法获取\n  public getCoordinate() {\n    return this.geometry.coordinate;\n  }\n\n  /**\n   * 获取 label 的默认配置\n   */\n  protected getDefaultLabelCfg(offset?: number, position?: string) {\n    const geometry = this.geometry;\n    const { type, theme } = geometry;\n\n    if (\n      type === 'polygon' ||\n      (type === 'interval' && position === 'middle') ||\n      (offset < 0 && !['line', 'point', 'path'].includes(type))\n    ) {\n      // polygon 或者 (interval 且 middle) 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      return get(theme, 'innerLabels', {});\n    }\n\n    return get(theme, 'labels', {});\n  }\n\n  /**\n   * 获取当前 label 的最终配置\n   * @param labelCfg\n   */\n  protected getThemedLabelCfg(labelCfg: LabelCfg) {\n    const geometry = this.geometry;\n    const defaultLabelCfg = this.getDefaultLabelCfg();\n    const { type, theme } = geometry;\n    let themedLabelCfg;\n\n    if (type === 'polygon' || (labelCfg.offset < 0 && !['line', 'point', 'path'].includes(type))) {\n      // polygon 或者 offset 小于 0 时，文本展示在图形内部，将其颜色设置为 白色\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.innerLabels, labelCfg);\n    } else {\n      themedLabelCfg = deepMix({}, defaultLabelCfg, theme.labels, labelCfg);\n    }\n\n    return themedLabelCfg;\n  }\n\n  /**\n   * 设置 label 位置\n   * @param labelPointCfg\n   * @param mappingData\n   * @param index\n   * @param position\n   */\n  protected setLabelPosition(\n    labelPointCfg: LabelPointCfg,\n    mappingData: MappingDatum,\n    index: number,\n    position: string\n  ) {}\n\n  /**\n   * @desc 获取 label offset\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    const vector = this.getOffsetVector(offset);\n    return coordinate.isTransposed ? vector[0] : vector[1];\n  }\n\n  /**\n   * 获取每个 label 的偏移量 (矢量)\n   * @param labelCfg\n   * @param index\n   * @param total\n   * @return {Point} offsetPoint\n   */\n  protected getLabelOffsetPoint(labelCfg: LabelCfg, index: number, total: number): Point {\n    const offset = labelCfg.offset;\n    const coordinate = this.getCoordinate();\n    const transposed = coordinate.isTransposed;\n    const dim = transposed ? 'x' : 'y';\n    const factor = transposed ? 1 : -1; // y 方向上越大，像素的坐标越小，所以transposed时将系数变成\n    const offsetPoint = {\n      x: 0,\n      y: 0,\n    };\n    if (index > 0 || total === 1) {\n      // 判断是否小于0\n      offsetPoint[dim] = offset * factor;\n    } else {\n      offsetPoint[dim] = offset * factor * -1;\n    }\n    return offsetPoint;\n  }\n\n  /**\n   * 获取每个 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   * @returns label point\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    const coordinate = this.getCoordinate();\n    const total = labelCfg.content.length;\n\n    function getDimValue(value: number | number[], idx: number, isAvg = false) {\n      let v = value;\n      if (isArray(v)) {\n        if (labelCfg.content.length === 1) {\n          if (isAvg) {\n            v = avg(v);\n          } else {\n            // 如果仅一个 label，多个 y, 取最后一个 y\n            if (v.length <= 2) {\n              v = v[(value as number[]).length - 1];\n            } else {\n              v = avg(v);\n            }\n          }\n        } else {\n          v = v[idx];\n        }\n      }\n      return v;\n    }\n\n    const label = {\n      content: labelCfg.content[index],\n      x: 0,\n      y: 0,\n      start: { x: 0, y: 0 },\n      color: '#fff',\n    };\n    const shape = isArray(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;\n    const isFunnel = shape === 'funnel' || shape === 'pyramid';\n\n    // 多边形场景，多用于地图\n    if (this.geometry.type === 'polygon') {\n      const centroid = getPolygonCentroid(mappingData.x, mappingData.y);\n      label.x = centroid[0];\n      label.y = centroid[1];\n    } else if (this.geometry.type === 'interval' && !isFunnel) {\n      // 对直方图的label X 方向的位置居中\n      label.x = getDimValue(mappingData.x, index, true);\n      label.y = getDimValue(mappingData.y, index);\n    } else {\n      label.x = getDimValue(mappingData.x, index);\n      label.y = getDimValue(mappingData.y, index);\n    }\n\n    // 处理漏斗图文本位置\n    if (isFunnel) {\n      const nextPoints = get(mappingData, 'nextPoints');\n      const points = get(mappingData, 'points');\n      if (nextPoints) {\n        // 非漏斗图底部\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(nextPoints[1] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      } else if (shape === 'pyramid') {\n        const point1 = coordinate.convert(points[1] as Point);\n        const point2 = coordinate.convert(points[2] as Point);\n        label.x = (point1.x + point2.x) / 2;\n        label.y = (point1.y + point2.y) / 2;\n      }\n    }\n\n    if (labelCfg.position) {\n      // 如果 label 支持 position 属性\n      this.setLabelPosition(label, mappingData, index, labelCfg.position);\n    }\n    const offsetPoint = this.getLabelOffsetPoint(labelCfg, index, total);\n    label.start = { x: label.x, y: label.y };\n    label.x += offsetPoint.x;\n    label.y += offsetPoint.y;\n    label.color = mappingData.color;\n    return label;\n  }\n\n  /**\n   * 获取文本的对齐方式\n   * @param item\n   * @param index\n   * @param total\n   * @returns\n   */\n  protected getLabelAlign(item: LabelItem, index: number, total: number): TextAlign {\n    let align: TextAlign = 'center';\n    const coordinate = this.getCoordinate();\n    if (coordinate.isTransposed) {\n      const offset = item.offset;\n      if (offset < 0) {\n        align = 'right';\n      } else if (offset === 0) {\n        align = 'center';\n      } else {\n        align = 'left';\n      }\n      if (total > 1 && index === 0) {\n        if (align === 'right') {\n          align = 'left';\n        } else if (align === 'left') {\n          align = 'right';\n        }\n      }\n    }\n    return align;\n  }\n\n  /**\n   * 获取每一个 label 的唯一 id\n   * @param mappingData label 对应的图形的绘制数据\n   */\n  protected getLabelId(mappingData: MappingDatum) {\n    const geometry = this.geometry;\n    const type = geometry.type;\n    const xScale = geometry.getXScale();\n    const yScale = geometry.getYScale();\n    const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n\n    let labelId = geometry.getElementId(mappingData);\n    if (type === 'line' || type === 'area') {\n      // 折线图以及区域图，一条线会对应一组数据，即多个 labels，为了区分这些 labels，需要在 line id 的前提下加上 x 字段值\n      labelId += ` ${origin[xScale.field]}`;\n    } else if (type === 'path') {\n      // path 路径图，无序，有可能存在相同 x 不同 y 的情况，需要通过 x y 来确定唯一 id\n      labelId += ` ${origin[xScale.field]}-${origin[yScale.field]}`;\n    }\n\n    return labelId;\n  }\n\n  // 获取 labels 组件\n  private getLabelsRenderer() {\n    const { labelsContainer, labelOption, canvasRegion, animateOption } = this.geometry;\n    const coordinate = this.geometry.coordinate;\n\n    let labelsRenderer = this.labelsRenderer;\n    if (!labelsRenderer) {\n      labelsRenderer = new Labels({\n        container: labelsContainer,\n        layout: get(labelOption, ['cfg', 'layout'], {\n          type: this.defaultLayout,\n        }),\n      });\n      this.labelsRenderer = labelsRenderer;\n    }\n    labelsRenderer.region = canvasRegion;\n    // 设置动画配置，如果 geometry 的动画关闭了，那么 label 的动画也会关闭\n    labelsRenderer.animate = animateOption ? getDefaultAnimateCfg('label', coordinate) : false;\n\n    return labelsRenderer;\n  }\n\n  private getLabelCfgs(mapppingArray: MappingDatum[]): LabelCfg[] {\n    const geometry = this.geometry;\n    const { labelOption, scales, coordinate } = geometry;\n    const { fields, callback, cfg } = labelOption as LabelOption;\n    const labelScales = fields.map((field: string) => {\n      return scales[field];\n    });\n\n    const labelCfgs: LabelCfg[] = [];\n    each(mapppingArray, (mappingData: MappingDatum, index: number) => {\n      const origin = mappingData[FIELD_ORIGIN]; // 原始数据\n      const originText = this.getLabelText(origin, labelScales);\n      let callbackCfg;\n      if (callback) {\n        // 当同时配置了 callback 和 cfg 时，以 callback 为准\n        const originValues = fields.map((field: string) => origin[field]);\n        callbackCfg = callback(...originValues);\n        if (isNil(callbackCfg)) {\n          labelCfgs.push(null);\n          return;\n        }\n      }\n\n      let labelCfg = {\n        id: this.getLabelId(mappingData), // 进行 ID 标记\n        elementId: this.geometry.getElementId(mappingData), // label 对应 Element 的 ID\n        data: origin, // 存储原始数据\n        mappingData, // 存储映射后的数据,\n        coordinate, // 坐标系\n        ...cfg,\n        ...callbackCfg,\n      };\n\n      if (isFunction(labelCfg.position)) {\n        labelCfg.position = labelCfg.position(origin, mappingData, index);\n      }\n\n      const offset = this.getLabelOffset(labelCfg.offset || 0);\n      // defaultCfg 需要判断 innerLabels & labels\n      const defaultLabelCfg = this.getDefaultLabelCfg(offset, labelCfg.position);\n      // labelCfg priority: defaultCfg < cfg < callbackCfg\n      labelCfg = deepMix({}, defaultLabelCfg, labelCfg);\n      // 获取最终的 offset\n      labelCfg.offset = this.getLabelOffset(labelCfg.offset || 0);\n\n      const content = labelCfg.content;\n      if (isFunction(content)) {\n        labelCfg.content = content(origin, mappingData, index);\n      } else if (isUndefined(content)) {\n        // 用户未配置 content，则默认为映射的第一个字段的值\n        labelCfg.content = originText[0];\n      }\n\n      labelCfgs.push(labelCfg);\n    });\n\n    return labelCfgs;\n  }\n\n  private getLabelText(origin: Datum, scales: Scale[]) {\n    const labelTexts = [];\n    each(scales, (scale: Scale) => {\n      let value = origin[scale.field];\n      if (isArray(value)) {\n        value = value.map((subVal) => {\n          return scale.getText(subVal);\n        });\n      } else {\n        value = scale.getText(value);\n      }\n\n      if (isNil(value) || value === '') {\n        labelTexts.push(null);\n      } else {\n        labelTexts.push(value);\n      }\n    });\n    return labelTexts;\n  }\n\n  private getOffsetVector(offset: number | string = 0) {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    }\n    // 如果 x,y 翻转，则偏移 x，否则偏移 y\n    return coordinate.isTransposed ? coordinate.applyMatrix(actualOffset, 0) : coordinate.applyMatrix(0, actualOffset);\n  }\n\n  private getGeometryShapes() {\n    const geometry = this.geometry;\n    const shapes = {};\n    each(geometry.elementsMap, (element: Element, id: string) => {\n      shapes[id] = element.shape;\n    });\n    // 因为有可能 shape 还在进行动画，导致 shape.getBBox() 获取到的值不是最终态，所以需要从 offscreenGroup 获取\n    each(geometry.getOffscreenGroup().getChildren(), (child) => {\n      const id = geometry.getElementId(child.get('origin').mappingData);\n      shapes[id] = child;\n    });\n\n    return shapes;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}