{"ast":null,"code":"/**\n * Format number of seconds into days, hours, minutes\n * @param {*} seconds \n * @returns \n */\nexport function formatTimeSecond(sec) {\n  const secsPerDay = 86400;\n  const secsPerHour = 3600;\n  const secsPerMinute = 60;\n  let seconds = Math.abs(sec);\n  let minus = this < 0 ? '-' : '';\n  let days = Math.floor(seconds / secsPerDay);\n  seconds = seconds % secsPerDay;\n  let hours = Math.floor(seconds / secsPerHour);\n  seconds = seconds % secsPerHour;\n  let minutes = Math.floor(seconds / secsPerMinute);\n  seconds = seconds % secsPerMinute;\n  let sDays = days > 0 ? new String(days).padStart(1, '0') + 'd ' : '';\n  let sHours = hours > 0 ? new String(hours).padStart(2, '0') + 'h ' : '';\n  let sMinutes = new String(minutes).padStart(2, '0') + 'm ';\n  return `${minus}${sDays}${sHours}${sMinutes}${seconds}s`;\n}\n\n// https://stackoverflow.com/questions/10420352/converting-file-size-in-bytes-to-human-readable-string\n/**\n * Format bytes as human-readable text.\n *\n * @param bytes Number of bytes.\n * @param si True to use metric (SI) units, aka powers of 1000. False to use\n *           binary (IEC), aka powers of 1024.\n * @param dp Number of decimal places to display.\n *\n * @return Formatted string.\n */\nexport function humanReadableSize(bytes) {\n  let si = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let dp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const thresh = si ? 1000 : 1024;\n  if (Math.abs(bytes) < thresh) {\n    return bytes + ' B';\n  }\n  const units = si ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'] : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];\n  let u = -1;\n  const r = 10 ** dp;\n  do {\n    bytes /= thresh;\n    ++u;\n  } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < (units === null || units === void 0 ? void 0 : units.length) - 1);\n  return bytes.toFixed(dp) + ' ' + units[u];\n}","map":{"version":3,"names":["formatTimeSecond","sec","secsPerDay","secsPerHour","secsPerMinute","seconds","Math","abs","minus","days","floor","hours","minutes","sDays","String","padStart","sHours","sMinutes","humanReadableSize","bytes","si","dp","thresh","units","u","r","round","length","toFixed"],"sources":["/home/iam/Documents/LocalWeb-master/src/service/utils/data-format.js"],"sourcesContent":["/**\n * Format number of seconds into days, hours, minutes\n * @param {*} seconds \n * @returns \n */\nexport function formatTimeSecond(sec) {\n  const secsPerDay = 86400\n  const secsPerHour = 3600\n  const secsPerMinute = 60\n\n  let seconds = Math.abs(sec)\n  let minus = this < 0 ? '-' : ''\n\n  let days = Math.floor(seconds / secsPerDay)\n  seconds = seconds % secsPerDay\n  let hours = Math.floor(seconds / secsPerHour)\n  seconds = seconds % secsPerHour\n  let minutes = Math.floor(seconds / secsPerMinute)\n  seconds = seconds % secsPerMinute\n\n  let sDays = days > 0 ? new String(days).padStart(1, '0') + 'd ' : ''\n  let sHours = hours > 0 ? new String(hours).padStart(2, '0') + 'h ' : ''\n  let sMinutes = new String(minutes).padStart(2, '0') + 'm '\n\n  return `${minus}${sDays}${sHours}${sMinutes}${seconds}s`\n}\n\n// https://stackoverflow.com/questions/10420352/converting-file-size-in-bytes-to-human-readable-string\n/**\n * Format bytes as human-readable text.\n *\n * @param bytes Number of bytes.\n * @param si True to use metric (SI) units, aka powers of 1000. False to use\n *           binary (IEC), aka powers of 1024.\n * @param dp Number of decimal places to display.\n *\n * @return Formatted string.\n */\nexport function humanReadableSize(bytes, si = false, dp = 1) {\n  const thresh = si ? 1000 : 1024\n\n  if (Math.abs(bytes) < thresh) {\n    return bytes + ' B'\n  }\n\n  const units = si\n    ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']\n    : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']\n  let u = -1\n  const r = 10 ** dp\n\n  do {\n    bytes /= thresh\n    ++u\n  } while (\n    Math.round(Math.abs(bytes) * r) / r >= thresh &&\n    u < units?.length - 1\n  )\n\n  return bytes.toFixed(dp) + ' ' + units[u]\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,gBAAgB,CAACC,GAAG,EAAE;EACpC,MAAMC,UAAU,GAAG,KAAK;EACxB,MAAMC,WAAW,GAAG,IAAI;EACxB,MAAMC,aAAa,GAAG,EAAE;EAExB,IAAIC,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACN,GAAG,CAAC;EAC3B,IAAIO,KAAK,GAAG,IAAI,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE;EAE/B,IAAIC,IAAI,GAAGH,IAAI,CAACI,KAAK,CAACL,OAAO,GAAGH,UAAU,CAAC;EAC3CG,OAAO,GAAGA,OAAO,GAAGH,UAAU;EAC9B,IAAIS,KAAK,GAAGL,IAAI,CAACI,KAAK,CAACL,OAAO,GAAGF,WAAW,CAAC;EAC7CE,OAAO,GAAGA,OAAO,GAAGF,WAAW;EAC/B,IAAIS,OAAO,GAAGN,IAAI,CAACI,KAAK,CAACL,OAAO,GAAGD,aAAa,CAAC;EACjDC,OAAO,GAAGA,OAAO,GAAGD,aAAa;EAEjC,IAAIS,KAAK,GAAGJ,IAAI,GAAG,CAAC,GAAG,IAAIK,MAAM,CAACL,IAAI,CAAC,CAACM,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,IAAI,GAAG,EAAE;EACpE,IAAIC,MAAM,GAAGL,KAAK,GAAG,CAAC,GAAG,IAAIG,MAAM,CAACH,KAAK,CAAC,CAACI,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,IAAI,GAAG,EAAE;EACvE,IAAIE,QAAQ,GAAG,IAAIH,MAAM,CAACF,OAAO,CAAC,CAACG,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,IAAI;EAE1D,OAAQ,GAAEP,KAAM,GAAEK,KAAM,GAAEG,MAAO,GAAEC,QAAS,GAAEZ,OAAQ,GAAE;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,iBAAiB,CAACC,KAAK,EAAsB;EAAA,IAApBC,EAAE,uEAAG,KAAK;EAAA,IAAEC,EAAE,uEAAG,CAAC;EACzD,MAAMC,MAAM,GAAGF,EAAE,GAAG,IAAI,GAAG,IAAI;EAE/B,IAAId,IAAI,CAACC,GAAG,CAACY,KAAK,CAAC,GAAGG,MAAM,EAAE;IAC5B,OAAOH,KAAK,GAAG,IAAI;EACrB;EAEA,MAAMI,KAAK,GAAGH,EAAE,GACZ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAChD,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;EAC5D,IAAII,CAAC,GAAG,CAAC,CAAC;EACV,MAAMC,CAAC,GAAG,EAAE,IAAIJ,EAAE;EAElB,GAAG;IACDF,KAAK,IAAIG,MAAM;IACf,EAAEE,CAAC;EACL,CAAC,QACClB,IAAI,CAACoB,KAAK,CAACpB,IAAI,CAACC,GAAG,CAACY,KAAK,CAAC,GAAGM,CAAC,CAAC,GAAGA,CAAC,IAAIH,MAAM,IAC7CE,CAAC,GAAG,CAAAD,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEI,MAAM,IAAG,CAAC;EAGvB,OAAOR,KAAK,CAACS,OAAO,CAACP,EAAE,CAAC,GAAG,GAAG,GAAGE,KAAK,CAACC,CAAC,CAAC;AAC3C"},"metadata":{},"sourceType":"module","externalDependencies":[]}