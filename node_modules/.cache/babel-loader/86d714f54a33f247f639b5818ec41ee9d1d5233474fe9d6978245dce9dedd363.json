{"ast":null,"code":"import { each, isNil, getEllipsisText, pick } from '@antv/util';\nimport { ellipsisString, strLen } from './text';\nvar ELLIPSIS_CODE = \"\\u2026\";\nvar ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\n/** 大数据量阈值 */\nvar OPTIMIZE_THRESHOLD = 400;\n/**\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\n * 最终是去字符串最“长”的那个 label 的宽度。\n * @param labels\n */\nfunction getMaxLabelWidthOptimized(labels) {\n  var texts = labels.map(function (label) {\n    var text = label.attr('text');\n    return isNil(text) ? '' : \"\" + text;\n  });\n  var maxLen = 0;\n  var maxIdx = 0;\n  for (var i = 0; i < texts.length; i += 1) {\n    var len = 0;\n    for (var j = 0; j <= texts[i].length; j += 1) {\n      var code = texts[i].charCodeAt(j);\n      if (code >= 19968 && code <= 40869) {\n        len += 2;\n      } else {\n        len += 1;\n      }\n    }\n    if (len > maxLen) {\n      maxLen = len;\n      maxIdx = i;\n    }\n  }\n  return labels[maxIdx].getBBox().width;\n}\n/** 获取最长的 label */\nexport function getMaxLabelWidth(labels) {\n  if (labels.length > OPTIMIZE_THRESHOLD) {\n    return getMaxLabelWidthOptimized(labels);\n  }\n  var max = 0;\n  each(labels, function (label) {\n    var bbox = label.getBBox();\n    var width = bbox.width;\n    if (max < width) {\n      max = width;\n    }\n  });\n  return max;\n}\n/** 获取label长度 */\nexport function getLabelLength(isVertical, label) {\n  var bbox = label.getCanvasBBox();\n  return isVertical ? bbox.width : bbox.height;\n}\n/* label长度是否超过约束值 */\nexport function testLabel(label, limitLength) {\n  return label.getBBox().width < limitLength;\n}\n/** 处理 text shape 的自动省略 */\nexport function ellipsisLabel(isVertical, label, limitLength, position) {\n  var _a;\n  if (position === void 0) {\n    position = 'tail';\n  }\n  var text = (_a = label.attr('text')) !== null && _a !== void 0 ? _a : ''; // 避免出现null、undefined\n  if (position === 'tail') {\n    // component 里的缩略处理做得很糟糕，文字长度测算完全不准确\n    // 这里暂时只对 tail 做处理\n    var font = pick(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);\n    var ellipsisText = getEllipsisText(text, limitLength, font, '…');\n    if (text !== ellipsisText) {\n      label.attr('text', ellipsisText);\n      label.set('tip', text);\n      return true;\n    }\n    label.set('tip', null);\n    return false;\n  }\n  var labelLength = getLabelLength(isVertical, label);\n  var codeLength = strLen(text);\n  var ellipsisFlag = false;\n  if (limitLength < labelLength) {\n    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\n    var newText = void 0;\n    if (reserveLength >= 0) {\n      newText = ellipsisString(text, reserveLength, position);\n    } else {\n      newText = ELLIPSIS_CODE;\n    }\n    if (newText) {\n      label.attr('text', newText);\n      ellipsisFlag = true;\n    }\n  }\n  if (ellipsisFlag) {\n    label.set('tip', text);\n  } else {\n    label.set('tip', null);\n  }\n  return ellipsisFlag;\n}","map":{"version":3,"mappings":"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","names":["each","isNil","getEllipsisText","pick","ellipsisString","strLen","ELLIPSIS_CODE","ELLIPSIS_CODE_LENGTH","OPTIMIZE_THRESHOLD","getMaxLabelWidthOptimized","labels","texts","map","label","text","attr","maxLen","maxIdx","i","length","len","j","code","charCodeAt","getBBox","width","getMaxLabelWidth","max","bbox","getLabelLength","isVertical","getCanvasBBox","height","testLabel","limitLength","ellipsisLabel","position","font","ellipsisText","set","labelLength","codeLength","ellipsisFlag","reserveLength","Math","floor","newText"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/component/src/util/label.ts"],"sourcesContent":["import { IElement } from '@antv/g-base';\nimport { each, isNil, getEllipsisText, pick } from '@antv/util';\n\nimport { ellipsisString, strLen } from './text';\n\nconst ELLIPSIS_CODE = '\\u2026';\nconst ELLIPSIS_CODE_LENGTH = 2; // 省略号的长度\n\n/** 大数据量阈值 */\nconst OPTIMIZE_THRESHOLD = 400;\n/**\n * 针对大数据量做优化的 getMaxLabelWidth，做法不是直接去比较每一个 label 的最大宽度\n * 而是先通过比较每个 label 每个的字符串的长度，这里区分了下中英文字符\n * 最终是去字符串最“长”的那个 label 的宽度。\n * @param labels\n */\nfunction getMaxLabelWidthOptimized(labels: IElement[]) {\n  const texts: string[] = labels.map((label) => {\n    const text = label.attr('text');\n    return isNil(text) ? '' : `${text}`;\n  });\n  let maxLen = 0;\n  let maxIdx = 0;\n\n  for (let i = 0; i < texts.length; i += 1) {\n    let len = 0;\n    for (let j = 0; j <= texts[i].length; j += 1) {\n      const code = texts[i].charCodeAt(j);\n      if (code >= 19968 && code <= 40869) {\n        len += 2;\n      } else {\n        len += 1;\n      }\n    }\n    if (len > maxLen) {\n      maxLen = len;\n      maxIdx = i;\n    }\n  }\n\n  return labels[maxIdx].getBBox().width;\n}\n\n/** 获取最长的 label */\nexport function getMaxLabelWidth(labels: IElement[]) {\n  if (labels.length > OPTIMIZE_THRESHOLD) {\n    return getMaxLabelWidthOptimized(labels);\n  }\n\n  let max = 0;\n  each(labels, (label) => {\n    const bbox = label.getBBox();\n    const width = bbox.width;\n    if (max < width) {\n      max = width;\n    }\n  });\n  return max;\n}\n\n/** 获取label长度 */\nexport function getLabelLength(isVertical: boolean, label) {\n  const bbox = label.getCanvasBBox();\n  return isVertical ? bbox.width : bbox.height;\n}\n\n/* label长度是否超过约束值 */\nexport function testLabel(label: IElement, limitLength: number): boolean {\n  return label.getBBox().width < limitLength;\n}\n\n/** 处理 text shape 的自动省略 */\nexport function ellipsisLabel(isVertical: boolean, label: IElement, limitLength: number, position: string = 'tail') {\n  const text = label.attr('text') ?? ''; // 避免出现null、undefined\n\n  if (position === 'tail') {\n    // component 里的缩略处理做得很糟糕，文字长度测算完全不准确\n    // 这里暂时只对 tail 做处理\n    const font = pick(label.attr(), ['fontSize', 'fontFamily', 'fontWeight', 'fontStyle', 'fontVariant']);\n    const ellipsisText = getEllipsisText(text, limitLength, font, '…') as string;\n    if (text !== ellipsisText) {\n      label.attr('text', ellipsisText);\n      label.set('tip', text);\n      return true;\n    }\n    label.set('tip', null);\n    return false;\n  }\n\n  const labelLength = getLabelLength(isVertical, label);\n  const codeLength = strLen(text);\n  let ellipsisFlag = false;\n  if (limitLength < labelLength) {\n    const reserveLength = Math.floor((limitLength / labelLength) * codeLength) - ELLIPSIS_CODE_LENGTH; // 计算出来的应该保存的长度\n    let newText;\n    if (reserveLength >= 0) {\n      newText = ellipsisString(text, reserveLength, position);\n    } else {\n      newText = ELLIPSIS_CODE;\n    }\n    if (newText) {\n      label.attr('text', newText);\n      ellipsisFlag = true;\n    }\n  }\n  if (ellipsisFlag) {\n    label.set('tip', text);\n  } else {\n    label.set('tip', null);\n  }\n  return ellipsisFlag;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}