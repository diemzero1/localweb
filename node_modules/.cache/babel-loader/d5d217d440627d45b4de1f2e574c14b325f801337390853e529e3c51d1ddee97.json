{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nvar HALF_PI = Math.PI / 2;\n/**\n * 极坐标下的图形 label\n */\nvar PolarLabel = /** @class */function (_super) {\n  __extends(PolarLabel, _super);\n  function PolarLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  PolarLabel.prototype.getLabelOffset = function (offset) {\n    var coordinate = this.getCoordinate();\n    var actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      var r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n    return actualOffset;\n  };\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  PolarLabel.prototype.getLabelItems = function (mapppingArray) {\n    var items = _super.prototype.getLabelItems.call(this, mapppingArray);\n    var yScale = this.geometry.getYScale();\n    return map(items, function (item) {\n      if (item && yScale) {\n        var percent = yScale.scale(get(item.data, yScale.field));\n        return __assign(__assign({}, item), {\n          percent: percent\n        });\n      }\n      return item;\n    });\n  };\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  PolarLabel.prototype.getLabelAlign = function (point) {\n    var coordinate = this.getCoordinate();\n    var align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      var center = coordinate.getCenter();\n      var offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  };\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  PolarLabel.prototype.getLabelPoint = function (labelCfg, mappingData, index) {\n    var factor = 1;\n    var arcPoint;\n    var content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n    var offset = labelCfg.offset * factor;\n    var middleAngle = this.getPointAngle(arcPoint);\n    var isLabelEmit = labelCfg.labelEmit;\n    var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n    labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y\n    };\n    return labelPositionCfg;\n  };\n  /**\n   * 获取圆弧的位置\n   */\n  PolarLabel.prototype.getArcPoint = function (mappingData, index) {\n    if (index === void 0) {\n      index = 0;\n    }\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y\n      };\n    }\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y\n    };\n  };\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  PolarLabel.prototype.getPointAngle = function (point) {\n    return getAngleByPoint(this.getCoordinate(), point);\n  };\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getCirclePoint = function (angle, offset, point, isLabelEmit) {\n    var coordinate = this.getCoordinate();\n    var center = coordinate.getCenter();\n    var r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return __assign(__assign({}, center), {\n        r: r\n      });\n    }\n    var labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      var appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r: r\n    };\n  };\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  PolarLabel.prototype.getLabelRotate = function (angle, offset, isLabelEmit) {\n    var rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  };\n  // 获取中心的位置\n  PolarLabel.prototype.getMiddlePoint = function (points) {\n    var coordinate = this.getCoordinate();\n    var count = points.length;\n    var middlePoint = {\n      x: 0,\n      y: 0\n    };\n    each(points, function (point) {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  };\n  // 是否居中\n  PolarLabel.prototype.isToMiddle = function (mappingData) {\n    return mappingData.x.length > 2;\n  };\n  return PolarLabel;\n}(GeometryLabel);\nexport default PolarLabel;","map":{"version":3,"mappings":"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","names":["each","get","isArray","map","isNumber","isString","getDistanceToCenter","getAngleByPoint","GeometryLabel","HALF_PI","Math","PI","__extends","PolarLabel","offset","coordinate","getCoordinate","actualOffset","indexOf","r","getRadius","innerRadius","parseFloat","mapppingArray","items","_super","getLabelItems","yScale","geometry","getYScale","item","percent","scale","data","field","point","align","labelEmit","angle","isTransposed","center","getCenter","abs","x","labelCfg","mappingData","index","factor","arcPoint","content","isToMiddle","getMiddlePoint","points","length","getArcPoint","middleAngle","getPointAngle","isLabelEmit","labelPositionCfg","getCirclePoint","color","rotate","autoRotate","getLabelRotate","start","y","labelAngle","appendAngle","asin","cos","sin","count","middlePoint","convert"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g2/src/geometry/label/polar.ts"],"sourcesContent":["import { each, get, isArray, map, isNumber, isString } from '@antv/util';\nimport { MappingDatum, Point } from '../../interface';\nimport { getDistanceToCenter } from '../../util/coordinate';\nimport { getAngleByPoint } from '../../util/coordinate';\nimport GeometryLabel from './base';\nimport { LabelCfg, LabelItem, PolarLabelItem, LabelPointCfg, Writeable } from './interface';\n\nconst HALF_PI = Math.PI / 2;\n\n/**\n * 极坐标下的图形 label\n */\nexport default class PolarLabel extends GeometryLabel {\n  /**\n   * @override\n   * @desc 获取 label offset\n   * polar & theta coordinate support「string」type, should transform to 「number」\n   */\n  protected getLabelOffset(offset: number | string): number {\n    const coordinate = this.getCoordinate();\n    let actualOffset = 0;\n    if (isNumber(offset)) {\n      actualOffset = offset;\n    } else if (isString(offset) && offset.indexOf('%') !== -1) {\n      let r = coordinate.getRadius();\n      if (coordinate.innerRadius > 0) {\n        r = r * (1 - coordinate.innerRadius);\n      }\n      actualOffset = parseFloat(offset) * 0.01 * r;\n    }\n\n    return actualOffset;\n  }\n\n  /**\n   * @override\n   * 获取 labelItems, 增加切片 percent\n   * @param mapppingArray\n   */\n  public getLabelItems(mapppingArray: MappingDatum[]): PolarLabelItem[] {\n    const items = super.getLabelItems(mapppingArray);\n    const yScale = this.geometry.getYScale();\n\n    return map(items, (item) => {\n      if (item && yScale) {\n        const percent = yScale.scale(get(item.data, yScale.field));\n        return { ...item, percent };\n      }\n      return item;\n    });\n  }\n  /**\n   * @override\n   * 获取文本的对齐方式\n   * @param point\n   */\n  protected getLabelAlign(point: LabelItem) {\n    const coordinate = this.getCoordinate();\n    let align;\n    if (point.labelEmit) {\n      align = point.angle <= Math.PI / 2 && point.angle >= -Math.PI / 2 ? 'left' : 'right';\n    } else if (!coordinate.isTransposed) {\n      align = 'center';\n    } else {\n      const center = coordinate.getCenter();\n      const offset = point.offset;\n      if (Math.abs(point.x - center.x) < 1) {\n        align = 'center';\n      } else if (point.angle > Math.PI || point.angle <= 0) {\n        align = offset > 0 ? 'left' : 'right';\n      } else {\n        align = offset > 0 ? 'right' : 'left';\n      }\n    }\n    return align;\n  }\n\n  /**\n   * @override\n   * 获取 label 的位置\n   * @param labelCfg\n   * @param mappingData\n   * @param index\n   */\n  protected getLabelPoint(labelCfg: LabelCfg, mappingData: MappingDatum, index: number): LabelPointCfg {\n    let factor = 1;\n    let arcPoint;\n    const content = labelCfg.content[index];\n    if (this.isToMiddle(mappingData)) {\n      arcPoint = this.getMiddlePoint(mappingData.points as Point[]);\n    } else {\n      if (labelCfg.content.length === 1 && index === 0) {\n        index = 1;\n      } else if (index === 0) {\n        factor = -1;\n      }\n      arcPoint = this.getArcPoint(mappingData, index);\n    }\n\n    const offset = labelCfg.offset * factor;\n    const middleAngle = this.getPointAngle(arcPoint);\n    const isLabelEmit = labelCfg.labelEmit;\n    const labelPositionCfg: Writeable<LabelPointCfg> = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);\n    if (labelPositionCfg.r === 0) {\n      // 如果文本位置位于圆心，则不展示\n      labelPositionCfg.content = '';\n    } else {\n      labelPositionCfg.content = content;\n      labelPositionCfg.angle = middleAngle;\n      labelPositionCfg.color = mappingData.color;\n    }\n\n    labelPositionCfg.rotate = labelCfg.autoRotate\n      ? this.getLabelRotate(middleAngle, offset, isLabelEmit)\n      : labelCfg.rotate;\n    labelPositionCfg.start = {\n      x: arcPoint.x,\n      y: arcPoint.y,\n    };\n    return labelPositionCfg;\n  }\n\n  /**\n   * 获取圆弧的位置\n   */\n  protected getArcPoint(mappingData: MappingDatum, index: number = 0): Point {\n    if (!isArray(mappingData.x) && !isArray(mappingData.y)) {\n      return {\n        x: mappingData.x,\n        y: mappingData.y,\n      };\n    }\n\n    return {\n      x: isArray(mappingData.x) ? mappingData.x[index] : mappingData.x,\n      y: isArray(mappingData.y) ? mappingData.y[index] : mappingData.y,\n    };\n  }\n\n  /**\n   * 计算坐标线点在极坐标系下角度\n   * @param point\n   */\n  protected getPointAngle(point: Point): number {\n    return getAngleByPoint(this.getCoordinate(), point);\n  }\n\n  /**\n   * 获取坐标点与圆心形成的圆的位置信息\n   * @param angle\n   * @param offset\n   * @param point\n   * @param isLabelEmit\n   */\n  protected getCirclePoint(angle: number, offset: number, point: Point, isLabelEmit: boolean) {\n    const coordinate = this.getCoordinate();\n    const center = coordinate.getCenter();\n    let r = getDistanceToCenter(coordinate, point);\n    if (r === 0) {\n      return {\n        ...center,\n        r,\n      };\n    }\n\n    let labelAngle = angle;\n    if (coordinate.isTransposed && r > offset && !isLabelEmit) {\n      const appendAngle = Math.asin(offset / (2 * r));\n      labelAngle = angle + appendAngle * 2;\n    } else {\n      r = r + offset;\n    }\n\n    return {\n      x: center.x + r * Math.cos(labelAngle),\n      y: center.y + r * Math.sin(labelAngle),\n      r,\n    };\n  }\n\n  /**\n   * 获取 label 的旋转角度\n   * @param angle\n   * @param offset\n   * @param isLabelEmit\n   */\n  protected getLabelRotate(angle: number, offset: number, isLabelEmit: boolean) {\n    let rotate = angle + HALF_PI;\n    if (isLabelEmit) {\n      rotate -= HALF_PI;\n    }\n    if (rotate) {\n      if (rotate > HALF_PI) {\n        rotate = rotate - Math.PI;\n      } else if (rotate < -HALF_PI) {\n        rotate = rotate + Math.PI;\n      }\n    }\n    return rotate;\n  }\n\n  // 获取中心的位置\n  private getMiddlePoint(points: Point[]) {\n    const coordinate = this.getCoordinate();\n    const count = points.length;\n    let middlePoint = {\n      x: 0,\n      y: 0,\n    };\n    each(points, (point: Point) => {\n      middlePoint.x += point.x;\n      middlePoint.y += point.y;\n    });\n    middlePoint.x /= count;\n    middlePoint.y /= count;\n\n    middlePoint = coordinate.convert(middlePoint);\n    return middlePoint;\n  }\n\n  // 是否居中\n  private isToMiddle(mappingData: MappingDatum) {\n    return (mappingData.x as number[]).length > 2;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}