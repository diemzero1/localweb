{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { assign, memoize } from '@antv/util';\nimport { LEVEL, log } from '../../utils';\nimport { blend } from '../../utils/color/blend';\nimport { ID_FIELD, PATH_FIELD } from './constant';\nimport { computeTextCentres, intersectionAreaPath } from './layout/diagram';\nimport { scaleSolution, venn } from './layout/layout';\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\nexport var getColorMap = memoize(function (colorPalette, data, blendMode, setsField) {\n  var colorMap = new Map();\n  var colorPaletteLen = colorPalette.length;\n  data.forEach(function (d, idx) {\n    if (d[setsField].length === 1) {\n      colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n    } else {\n      /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n      var colorArr = d[setsField].map(function (id) {\n        return colorMap.get(id);\n      });\n      colorMap.set(d[ID_FIELD], colorArr.slice(1).reduce(function (a, b) {\n        return blend(a, b, blendMode);\n      }, colorArr[0]));\n    }\n  });\n  return colorMap;\n}, function () {\n  var params = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    params[_i] = arguments[_i];\n  }\n  return JSON.stringify(params);\n});\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\nexport function layoutVennData(options, width, height, padding) {\n  if (padding === void 0) {\n    padding = 0;\n  }\n  var data = options.data,\n    setsField = options.setsField,\n    sizeField = options.sizeField;\n  // 处理空数据的情况\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n  var vennData = data.map(function (d) {\n    var _a;\n    return __assign(__assign({}, d), (_a = {\n      sets: d[setsField] || [],\n      size: d[sizeField]\n    }, _a[PATH_FIELD] = '', _a[ID_FIELD] = '', _a));\n  });\n  // 1. 进行排序，避免图形元素遮挡\n  vennData.sort(function (a, b) {\n    return a.sets.length - b.sets.length;\n  });\n  // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n  var solution = venn(vennData);\n  var circles = scaleSolution(solution, width, height, padding);\n  var textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach(function (row) {\n    var sets = row.sets;\n    var id = sets.join(',');\n    row[ID_FIELD] = id;\n    // 保留 vennText 布局方法\n    var setCircles = sets.map(function (set) {\n      return circles[set];\n    });\n    var path = intersectionAreaPath(setCircles);\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n    row[PATH_FIELD] = path;\n    var center = textCenters[id] || {\n      x: 0,\n      y: 0\n    };\n    assign(row, center);\n  });\n  return vennData;\n}\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\nexport function islegalSets(legalArr, testArr) {\n  for (var i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"mappings":"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","names":["assign","memoize","LEVEL","log","blend","ID_FIELD","PATH_FIELD","computeTextCentres","intersectionAreaPath","scaleSolution","venn","getColorMap","colorPalette","data","blendMode","setsField","colorMap","Map","colorPaletteLen","length","forEach","d","idx","set","colorArr","map","id","get","slice","reduce","a","b","_i","params","stringify","layoutVennData","options","width","height","padding","sizeField","WARN","vennData","sets","size","sort","solution","circles","textCenters","row","join","setCircles","path","test","center","x","y","islegalSets","legalArr","testArr","i","includes"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g2plot/src/plots/venn/utils.ts"],"sourcesContent":["import { assign, memoize } from '@antv/util';\nimport { LEVEL, log } from '../../utils';\nimport { blend } from '../../utils/color/blend';\nimport { ID_FIELD, PATH_FIELD } from './constant';\nimport { computeTextCentres, intersectionAreaPath } from './layout/diagram';\nimport { scaleSolution, venn } from './layout/layout';\nimport { VennData, VennOptions } from './types';\n\ntype ColorMapFunction = (\n  colorPalette: string[],\n  data: VennData,\n  blendMode: VennOptions['blendMode'],\n  setsField: VennOptions['setsField']\n) => Map<string, string>;\n\n/**\n * 获取 颜色映射\n * @usage colorMap.get(id) => color\n *\n * @returns Map<string, string>\n */\nexport const getColorMap = memoize(\n  ((colorPalette, data, blendMode, setsField) => {\n    const colorMap = new Map<string /** id */, string /** color */>();\n    const colorPaletteLen = colorPalette.length;\n    data.forEach((d, idx) => {\n      if (d[setsField].length === 1) {\n        colorMap.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);\n      } else {\n        /** 一般都是可以获取到颜色的，如果不正确 就是输入了非法数据 */\n        const colorArr = d[setsField].map((id) => colorMap.get(id));\n        colorMap.set(\n          d[ID_FIELD],\n          colorArr.slice(1).reduce((a, b) => blend(a, b, blendMode), colorArr[0])\n        );\n      }\n    });\n\n    return colorMap;\n  }) as ColorMapFunction,\n  (...params) => JSON.stringify(params)\n) as ColorMapFunction;\n\n/**\n * 给韦恩图数据进行布局\n *\n * @param data\n * @param width\n * @param height\n * @param padding\n * @returns 韦恩图数据\n */\nexport function layoutVennData(options: VennOptions, width: number, height: number, padding: number = 0): VennData {\n  const { data, setsField, sizeField } = options;\n\n  // 处理空数据的情况\n  if (data.length === 0) {\n    log(LEVEL.WARN, false, 'warn: %s', '数据不能为空');\n    return [];\n  }\n\n  const vennData: VennData = data.map((d) => ({\n    ...d,\n    sets: d[setsField] || [],\n    size: d[sizeField],\n    [PATH_FIELD]: '',\n    [ID_FIELD]: '',\n  }));\n  // 1. 进行排序，避免图形元素遮挡\n  vennData.sort((a, b) => a.sets.length - b.sets.length);\n  // todo 2. 可以在这里处理下非法数据输入，避免直接 crash\n\n  const solution = venn(vennData);\n  const circles = scaleSolution(solution, width, height, padding);\n  const textCenters = computeTextCentres(circles, vennData);\n  vennData.forEach((row) => {\n    const sets = row.sets;\n    const id = sets.join(',');\n    row[ID_FIELD] = id;\n    // 保留 vennText 布局方法\n    const setCircles = sets.map((set) => circles[set]);\n    let path = intersectionAreaPath(setCircles);\n    if (!/[zZ]$/.test(path)) {\n      path += ' Z';\n    }\n    row[PATH_FIELD] = path;\n    const center = textCenters[id] || { x: 0, y: 0 };\n    assign(row, center);\n  });\n  return vennData;\n}\n\n/**\n * 检查是否存在 非法元素\n * @param legalArr 合法集合：['A', 'B']\n * @param testArr 检查集合：['A', 'B', 'C'] or ['A', 'C']（存在非法 'C'）\n * @return boolean\n */\nexport function islegalSets(legalArr: any[], testArr: any[]): boolean {\n  for (let i = 0; i < testArr.length; i++) {\n    if (!legalArr.includes(testArr[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}