{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { GAP } from '../constant';\nimport Adjust from './adjust';\nfunction randomNumber(min, max) {\n  return (max - min) * Math.random() + min;\n}\nvar Jitter = /** @class */function (_super) {\n  __extends(Jitter, _super);\n  function Jitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Jitter.prototype.process = function (groupDataArray) {\n    var groupedDataArray = _.clone(groupDataArray);\n    // 之前分组之后的数据，然后有合并回去（和分组前可以理解成是一样的）\n    var mergeData = _.flatten(groupedDataArray);\n    // 返回值\n    this.adjustData(groupedDataArray, mergeData);\n    return groupedDataArray;\n  };\n  /**\n   * 当前数据分组（index）中，按照维度 dim 进行 jitter 调整\n   * @param dim\n   * @param values\n   * @param dataArray\n   */\n  Jitter.prototype.adjustDim = function (dim, values, dataArray) {\n    var _this = this;\n    // 在每一个分组中，将数据再按照 dim 分组，用于散列\n    var groupDataArray = this.groupData(dataArray, dim);\n    return _.each(groupDataArray, function (data, dimValue) {\n      return _this.adjustGroup(data, dim, parseFloat(dimValue), values);\n    });\n  };\n  // 随机出来的字段值\n  Jitter.prototype.getAdjustOffset = function (range) {\n    var pre = range.pre,\n      next = range.next;\n    // 随机的范围\n    var margin = (next - pre) * GAP;\n    return randomNumber(pre + margin, next - margin);\n  };\n  // adjust group data\n  Jitter.prototype.adjustGroup = function (group, dim, dimValue, values) {\n    var _this = this;\n    // 调整范围\n    var range = this.getAdjustRange(dim, dimValue, values);\n    _.each(group, function (data) {\n      data[dim] = _this.getAdjustOffset(range); // 获取调整的位置\n    });\n\n    return group;\n  };\n  return Jitter;\n}(Adjust);\nexport default Jitter;","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,CAAC,MAAM,YAAY;AAC/B,SAASC,GAAG,QAAQ,aAAa;AAEjC,OAAOC,MAAM,MAAM,UAAU;AAE7B,SAASC,YAAY,CAACC,GAAW,EAAEC,GAAW;EAC5C,OAAO,CAACA,GAAG,GAAGD,GAAG,IAAIE,IAAI,CAACC,MAAM,EAAE,GAAGH,GAAG;AAC1C;AAEA;EAAoCI;EAApC;;EA6CA;EA5CSC,wBAAO,GAAd,UAAeC,cAAwB;IACrC,IAAMC,gBAAgB,GAAGX,CAAC,CAACY,KAAK,CAACF,cAAc,CAAC;IAEhD;IACA,IAAMG,SAAS,GAAGb,CAAC,CAACc,OAAO,CAACH,gBAAgB,CAAW;IAEvD;IACA,IAAI,CAACI,UAAU,CAACJ,gBAAgB,EAAEE,SAAS,CAAC;IAE5C,OAAOF,gBAAgB;EACzB,CAAC;EAED;;;;;;EAMUF,0BAAS,GAAnB,UAAoBO,GAAW,EAAEC,MAAgB,EAAEC,SAAiB;IAApE;IACE;IACA,IAAMR,cAAc,GAAG,IAAI,CAACS,SAAS,CAACD,SAAS,EAAEF,GAAG,CAAC;IACrD,OAAOhB,CAAC,CAACoB,IAAI,CAACV,cAAc,EAAE,UAACW,IAAY,EAAEC,QAAgB;MAC3D,OAAOC,KAAI,CAACC,WAAW,CAACH,IAAI,EAAEL,GAAG,EAAES,UAAU,CAACH,QAAQ,CAAC,EAAEL,MAAM,CAAC;IAClE,CAAC,CAAC;EACJ,CAAC;EAED;EACQR,gCAAe,GAAvB,UAAwBiB,KAAY;IAC1B,OAAG,GAAWA,KAAK,IAAhB;MAAEC,IAAI,GAAKD,KAAK,KAAV;IACjB;IACA,IAAME,MAAM,GAAG,CAACD,IAAI,GAAGE,GAAG,IAAI5B,GAAG;IACjC,OAAOE,YAAY,CAAC0B,GAAG,GAAGD,MAAM,EAAED,IAAI,GAAGC,MAAM,CAAC;EAClD,CAAC;EAED;EACQnB,4BAAW,GAAnB,UAAoBqB,KAAa,EAAEd,GAAW,EAAEM,QAAgB,EAAEL,MAAgB;IAAlF;IACE;IACA,IAAMS,KAAK,GAAG,IAAI,CAACK,cAAc,CAACf,GAAG,EAAEM,QAAQ,EAAEL,MAAM,CAAC;IAExDjB,CAAC,CAACoB,IAAI,CAACU,KAAK,EAAE,UAACT,IAAU;MACvBA,IAAI,CAACL,GAAG,CAAC,GAAGO,KAAI,CAACS,eAAe,CAACN,KAAK,CAAC,CAAC,CAAC;IAC3C,CAAC,CAAC;;IACF,OAAOI,KAAK;EACd,CAAC;EACH,aAAC;AAAD,CAAC,CA7CmC5B,MAAM","names":["_","GAP","Adjust","randomNumber","min","max","Math","random","__extends","Jitter","groupDataArray","groupedDataArray","clone","mergeData","flatten","adjustData","dim","values","dataArray","groupData","each","data","dimValue","_this","adjustGroup","parseFloat","range","next","margin","pre","group","getAdjustRange","getAdjustOffset"],"sources":["/home/iam/Documents/network/node_modules/@antv/adjust/src/adjusts/jitter.ts"],"sourcesContent":["import * as _ from '@antv/util';\nimport { GAP } from '../constant';\nimport { Data, Range } from '../interface';\nimport Adjust from './adjust';\n\nfunction randomNumber(min: number, max: number): number {\n  return (max - min) * Math.random() + min;\n}\n\nexport default class Jitter extends Adjust {\n  public process(groupDataArray: Data[][]): Data[][] {\n    const groupedDataArray = _.clone(groupDataArray);\n\n    // 之前分组之后的数据，然后有合并回去（和分组前可以理解成是一样的）\n    const mergeData = _.flatten(groupedDataArray) as Data[];\n\n    // 返回值\n    this.adjustData(groupedDataArray, mergeData);\n\n    return groupedDataArray;\n  }\n\n  /**\n   * 当前数据分组（index）中，按照维度 dim 进行 jitter 调整\n   * @param dim\n   * @param values\n   * @param dataArray\n   */\n  protected adjustDim(dim: string, values: number[], dataArray: Data[]) {\n    // 在每一个分组中，将数据再按照 dim 分组，用于散列\n    const groupDataArray = this.groupData(dataArray, dim);\n    return _.each(groupDataArray, (data: Data[], dimValue: string) => {\n      return this.adjustGroup(data, dim, parseFloat(dimValue), values);\n    });\n  }\n\n  // 随机出来的字段值\n  private getAdjustOffset(range: Range): number {\n    const { pre, next } = range;\n    // 随机的范围\n    const margin = (next - pre) * GAP;\n    return randomNumber(pre + margin, next - margin);\n  }\n\n  // adjust group data\n  private adjustGroup(group: Data[], dim: string, dimValue: number, values: number[]): Data[] {\n    // 调整范围\n    const range = this.getAdjustRange(dim, dimValue, values);\n\n    _.each(group, (data: Data) => {\n      data[dim] = this.getAdjustOffset(range); // 获取调整的位置\n    });\n    return group;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}