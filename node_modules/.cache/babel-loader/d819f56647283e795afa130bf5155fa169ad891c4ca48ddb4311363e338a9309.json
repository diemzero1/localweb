{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;\nvar feasible_tree_1 = require(\"./feasible-tree\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"../util\");\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar preorder = graphlib_1.algorithm.preorder,\n  postorder = graphlib_1.algorithm.postorder;\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nvar networkSimplex = function networkSimplex(og) {\n  var g = (0, util_2.simplify)(og);\n  (0, util_1.longestPath)(g);\n  var t = (0, feasible_tree_1.feasibleTree)(g);\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  var e;\n  var f;\n  while (e = (0, exports.leaveEdge)(t)) {\n    f = (0, exports.enterEdge)(t, g, e);\n    (0, exports.exchangeEdges)(t, g, e, f);\n  }\n};\n/*\n * Initializes cut values for all edges in the tree.\n */\nvar initCutValues = function initCutValues(t, g) {\n  var vs = postorder(t, t.nodes());\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    assignCutValue(t, g, v);\n  });\n};\nexports.initCutValues = initCutValues;\nvar assignCutValue = function assignCutValue(t, g, child) {\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  t.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t, g, child);\n};\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nvar calcCutValue = function calcCutValue(t, g, child) {\n  var _a;\n  var childLab = t.node(child);\n  var parent = childLab.parent;\n  // True if the child is on the tail end of the edge in the directed graph\n  var childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  var graphEdge = g.edgeFromArgs(child, parent);\n  // The accumulated cut value for the edge between this node and its parent\n  var cutValue = 0;\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edgeFromArgs(parent, child);\n  }\n  cutValue = graphEdge.weight;\n  (_a = g.nodeEdges(child)) === null || _a === void 0 ? void 0 : _a.forEach(function (e) {\n    var isOutEdge = e.v === child;\n    var other = isOutEdge ? e.w : e.v;\n    if (other !== parent) {\n      var pointsToHead = isOutEdge === childIsTail;\n      var otherWeight = g.edge(e).weight;\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        var otherCutValue = t.edgeFromArgs(child, other).cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n  return cutValue;\n};\nexports.calcCutValue = calcCutValue;\nvar initLowLimValues = function initLowLimValues(tree, root) {\n  if (root === void 0) {\n    root = tree.nodes()[0];\n  }\n  dfsAssignLowLim(tree, {}, 1, root);\n};\nexports.initLowLimValues = initLowLimValues;\nvar dfsAssignLowLim = function dfsAssignLowLim(tree, visited, nextLim, v, parent) {\n  var _a;\n  var low = nextLim;\n  var useNextLim = nextLim;\n  var label = tree.node(v);\n  visited[v] = true;\n  (_a = tree.neighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (w) {\n    if (!visited[w]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n  label.low = low;\n  label.lim = useNextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n  return useNextLim;\n};\nvar leaveEdge = function leaveEdge(tree) {\n  return tree.edges().find(function (e) {\n    return tree.edge(e).cutvalue < 0;\n  });\n};\nexports.leaveEdge = leaveEdge;\nvar enterEdge = function enterEdge(t, g, edge) {\n  var v = edge.v;\n  var w = edge.w;\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n  var vLabel = t.node(v);\n  var wLabel = t.node(w);\n  var tailLabel = vLabel;\n  var flip = false;\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if (vLabel.lim > wLabel.lim) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n  var candidates = g.edges().filter(function (edge) {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) && flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n  return (0, util_2.minBy)(candidates, function (edge) {\n    return (0, util_1.slack)(g, edge);\n  });\n};\nexports.enterEdge = enterEdge;\nvar exchangeEdges = function exchangeEdges(t, g, e, f) {\n  var v = e.v;\n  var w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  (0, exports.initLowLimValues)(t);\n  (0, exports.initCutValues)(t, g);\n  updateRanks(t, g);\n};\nexports.exchangeEdges = exchangeEdges;\nvar updateRanks = function updateRanks(t, g) {\n  var root = t.nodes().find(function (v) {\n    var _a;\n    return !((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.parent);\n  });\n  var vs = preorder(t, root);\n  vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);\n  vs === null || vs === void 0 ? void 0 : vs.forEach(function (v) {\n    var parent = t.node(v).parent;\n    var edge = g.edgeFromArgs(v, parent);\n    var flipped = false;\n    if (!edge) {\n      edge = g.edgeFromArgs(parent, v);\n      flipped = true;\n    }\n    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);\n  });\n};\n/*\n * Returns true if the edge is in the tree.\n */\nvar isTreeEdge = function isTreeEdge(tree, u, v) {\n  return tree.hasEdge(u, v);\n};\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nvar isDescendant = function isDescendant(tree, vLabel, rootLabel) {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\nexports.default = networkSimplex;","map":{"version":3,"mappings":"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","names":["graphlib_1","postorder","networkSimplex","og","g","t","e","f","initCutValues","vs","nodes","slice","length","forEach","v","assignCutValue","exports","child","childLab","node","parent","edgeFromArgs","cutvalue","calcCutValue","childIsTail","graphEdge","cutValue","weight","nodeEdges","isOutEdge","other","w","pointsToHead","otherWeight","edge","isTreeEdge","otherCutValue","initLowLimValues","tree","root","dfsAssignLowLim","visited","nextLim","low","useNextLim","label","neighbors","lim","leaveEdge","edges","find","enterEdge","hasEdge","vLabel","wLabel","tailLabel","flip","candidates","filter","isDescendant","exchangeEdges","removeEdge","setEdge","updateRanks","preorder","flipped","rank","minlen","u","rootLabel"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/rank/network-simplex.ts"],"sourcesContent":["import { feasibleTree } from './feasible-tree';\nimport { slack, longestPath as initRank } from './util';\nimport { minBy, simplify } from '../util';\nimport { algorithm } from '@antv/graphlib';\nimport { Edge, Graph } from '../../graph';\n\n\nconst { preorder, postorder } = algorithm;\n\n\n/*\n * The network simplex algorithm assigns ranks to each node in the input graph\n * and iteratively improves the ranking to reduce the length of edges.\n *\n * Preconditions:\n *\n *    1. The input graph must be a DAG.\n *    2. All nodes in the graph must have an object value.\n *    3. All edges in the graph must have \"minlen\" and \"weight\" attributes.\n *\n * Postconditions:\n *\n *    1. All nodes in the graph will have an assigned \"rank\" attribute that has\n *       been optimized by the network simplex algorithm. Ranks start at 0.\n *\n *\n * A rough sketch of the algorithm is as follows:\n *\n *    1. Assign initial ranks to each node. We use the longest path algorithm,\n *       which assigns ranks to the lowest position possible. In general this\n *       leads to very wide bottom ranks and unnecessarily long edges.\n *    2. Construct a feasible tight tree. A tight tree is one such that all\n *       edges in the tree have no slack (difference between length of edge\n *       and minlen for the edge). This by itself greatly improves the assigned\n *       rankings by shorting edges.\n *    3. Iteratively find edges that have negative cut values. Generally a\n *       negative cut value indicates that the edge could be removed and a new\n *       tree edge could be added to produce a more compact graph.\n *\n * Much of the algorithms here are derived from Gansner, et al., \"A Technique\n * for Drawing Directed Graphs.\" The structure of the file roughly follows the\n * structure of the overall algorithm.\n */\nconst networkSimplex = (og: Graph) => {\n  const g = simplify(og);\n  initRank(g);\n  const t = feasibleTree(g);\n  initLowLimValues(t);\n  initCutValues(t, g);\n\n  let e;\n  let f;\n  while ((e = leaveEdge(t))) {\n    f = enterEdge(t, g, e);\n    exchangeEdges(t, g, e, f);\n  }\n};\n\n/*\n * Initializes cut values for all edges in the tree.\n */\nexport const initCutValues = (t: Graph, g: Graph) => {\n  let vs = postorder(t, t.nodes());\n  vs = vs?.slice(0, vs?.length - 1);\n  vs?.forEach((v: string) => {\n    assignCutValue(t, g, v);\n  });\n};\n\nconst assignCutValue = (t: Graph, g: Graph, child: string) => {\n  const childLab = t.node(child)!;\n  const parent = childLab.parent!;\n  t.edgeFromArgs(child, parent)!.cutvalue = calcCutValue(t, g, child);\n};\n\n/*\n * Given the tight tree, its graph, and a child in the graph calculate and\n * return the cut value for the edge between the child and its parent.\n */\nexport const calcCutValue = (t: Graph, g: Graph, child: string) => {\n  const childLab = t.node(child)!;\n  const parent = childLab.parent as string;\n  // True if the child is on the tail end of the edge in the directed graph\n  let childIsTail = true;\n  // The graph's view of the tree edge we're inspecting\n  let graphEdge = g.edgeFromArgs(child, parent)!;\n  // The accumulated cut value for the edge between this node and its parent\n  let cutValue = 0;\n\n  if (!graphEdge) {\n    childIsTail = false;\n    graphEdge = g.edgeFromArgs(parent, child)!;\n  }\n\n  cutValue = graphEdge.weight!;\n\n  g.nodeEdges(child)?.forEach((e) => {\n    const isOutEdge = e.v === child;\n    const other = isOutEdge ? e.w : e.v;\n\n    if (other !== parent) {\n      const pointsToHead = isOutEdge === childIsTail;\n      const otherWeight = g.edge(e)!.weight!;\n\n      cutValue += pointsToHead ? otherWeight : -otherWeight;\n      if (isTreeEdge(t, child, other)) {\n        const otherCutValue = t.edgeFromArgs(child, other)!.cutvalue;\n        cutValue += pointsToHead ? -otherCutValue : otherCutValue;\n      }\n    }\n  });\n\n  return cutValue;\n};\n\nexport const initLowLimValues = (tree: Graph, root: string = tree.nodes()[0]) => {\n  dfsAssignLowLim(tree, {}, 1, root);\n};\n\nconst dfsAssignLowLim = (tree: Graph, visited: Record<string, boolean>, nextLim: number, v: string, parent?: string) => {\n  const low = nextLim;\n  let useNextLim = nextLim;\n  const label = tree.node(v)!;\n\n  visited[v] = true;\n  tree.neighbors(v)?.forEach((w) => {\n    if (!visited[w]) {\n      useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w, v);\n    }\n  });\n\n  label.low = low;\n  label.lim = useNextLim++;\n  if (parent) {\n    label.parent = parent;\n  } else {\n    // TODO should be able to remove this when we incrementally update low lim\n    delete label.parent;\n  }\n\n  return useNextLim;\n};\n\nexport const leaveEdge = (tree: Graph) => {\n  return tree.edges().find((e) => {\n    return tree.edge(e)!.cutvalue < 0;\n  });\n};\n\nexport const enterEdge = (t: Graph, g: Graph, edge: any) => {\n  let v = edge.v;\n  let w = edge.w;\n\n  // For the rest of this function we assume that v is the tail and w is the\n  // head, so if we don't have this edge in the graph we should flip it to\n  // match the correct orientation.\n  if (!g.hasEdge(v, w)) {\n    v = edge.w;\n    w = edge.v;\n  }\n\n  const vLabel = t.node(v)!;\n  const wLabel = t.node(w)!;\n  let tailLabel = vLabel;\n  let flip = false;\n\n  // If the root is in the tail of the edge then we need to flip the logic that\n  // checks for the head and tail nodes in the candidates function below.\n  if ((vLabel.lim as number) > (wLabel.lim as number)) {\n    tailLabel = wLabel;\n    flip = true;\n  }\n\n  const candidates = g.edges().filter((edge) => {\n    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&\n           flip !== isDescendant(t, t.node(edge.w), tailLabel);\n  });\n\n  return minBy(candidates, (edge) => { return slack(g, edge); });\n};\n\nexport const exchangeEdges = (t: Graph, g: Graph, e: Edge, f: Edge) => {\n  const v = e.v;\n  const w = e.w;\n  t.removeEdge(v, w);\n  t.setEdge(f.v, f.w, {});\n  initLowLimValues(t);\n  initCutValues(t, g);\n  updateRanks(t, g);\n};\n\nconst updateRanks = (t: Graph, g: Graph) => {\n  const root = t.nodes().find((v) =>{ return !g.node(v)?.parent; })!;\n  let vs = preorder(t, root);\n  vs = vs?.slice(1);\n  vs?.forEach((v: string) => {\n    const parent = t.node(v)!.parent as string;\n    let edge = g.edgeFromArgs(v, parent);\n    let flipped = false;\n\n    if (!edge) {\n      edge = g.edgeFromArgs(parent, v)!;\n      flipped = true;\n    }\n\n    g.node(v)!.rank = g.node(parent)!.rank! + (flipped ? edge.minlen! : -edge.minlen!);\n  });\n};\n\n/*\n * Returns true if the edge is in the tree.\n */\nconst isTreeEdge = (tree: Graph, u: string, v: string) => {\n  return tree.hasEdge(u, v);\n};\n\n/*\n * Returns true if the specified node is descendant of the root node per the\n * assigned low and lim attributes in the tree.\n */\nconst isDescendant = (tree: Graph, vLabel: any, rootLabel: any) => {\n  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;\n};\n\nexport default networkSimplex;"]},"metadata":{},"sourceType":"script","externalDependencies":[]}