{"ast":null,"code":"\"use strict\";\n\n// \"use strict\";\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// var rankUtil = require(\"./util\");\n// var longestPath = rankUtil.longestPathWithLayer;\n// var feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\n// var networkSimplex = require(\"./network-simplex\");\nvar util_1 = require(\"./util\");\nvar feasible_tree_1 = require(\"./feasible-tree\");\nvar network_simplex_1 = __importDefault(require(\"./network-simplex\"));\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nvar rank = function rank(g) {\n  switch (g.graph().ranker) {\n    case \"network-simplex\":\n      networkSimplexRanker(g);\n      break;\n    case \"tight-tree\":\n      tightTreeRanker(g);\n      break;\n    case \"longest-path\":\n      longestPathRanker(g);\n      break;\n    // default: networkSimplexRanker(g);\n    default:\n      tightTreeRanker(g);\n  }\n};\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = util_1.longestPath;\nvar tightTreeRanker = function tightTreeRanker(g) {\n  (0, util_1.longestPathWithLayer)(g);\n  (0, feasible_tree_1.feasibleTreeWithLayer)(g);\n};\nvar networkSimplexRanker = function networkSimplexRanker(g) {\n  (0, network_simplex_1.default)(g);\n};\nexports.default = rank;","map":{"version":3,"mappings":";;AAAA;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;;;AAmBA,IAAMA,IAAI,GAAG,SAAPA,IAAI,CAAIC,CAAQ;EACpB,QAAOA,CAAC,CAACC,KAAK,EAAE,CAACC,MAAM;IACvB,KAAK,iBAAiB;MAAEC,oBAAoB,CAACH,CAAC,CAAC;MAAE;IACjD,KAAK,YAAY;MAAEI,eAAe,CAACJ,CAAC,CAAC;MAAE;IACvC,KAAK,cAAc;MAAEK,iBAAiB,CAACL,CAAC,CAAC;MAAE;IAC3C;IACA;MAASI,eAAe,CAACJ,CAAC,CAAC;EAAC;AAE9B,CAAC;AAED;AACA,IAAMK,iBAAiB,GAAGC,kBAAW;AAErC,IAAMF,eAAe,GAAG,SAAlBA,eAAe,CAAIJ,CAAQ;EAC/B,+BAAoB,EAACA,CAAC,CAAC;EACvB,yCAAY,EAACA,CAAC,CAAC;AACjB,CAAC;AAED,IAAMG,oBAAoB,GAAG,SAAvBA,oBAAoB,CAAIH,CAAQ;EACpC,6BAAc,EAACA,CAAC,CAAC;AACnB,CAAC;AAEDO,kBAAeR,IAAI","names":["rank","g","graph","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker","util_1","exports"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/rank/index.ts"],"sourcesContent":["// \"use strict\";\n\n// var rankUtil = require(\"./util\");\n// var longestPath = rankUtil.longestPathWithLayer;\n// var feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\n// var networkSimplex = require(\"./network-simplex\");\n\nimport { longestPath, longestPathWithLayer } from './util';\nimport { feasibleTreeWithLayer as feasibleTree } from './feasible-tree';\nimport networkSimplex from './network-simplex';\nimport { Graph } from '../../graph';\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nconst rank = (g: Graph) => {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  // default: networkSimplexRanker(g);\n  default: tightTreeRanker(g);\n  }\n};\n\n// A fast and simple ranker, but results are far from optimal.\nconst longestPathRanker = longestPath;\n\nconst tightTreeRanker = (g: Graph) => {\n  longestPathWithLayer(g);\n  feasibleTree(g);\n};\n\nconst networkSimplexRanker = (g: Graph) => {\n  networkSimplex(g);\n};\n\nexport default rank;"]},"metadata":{},"sourceType":"script","externalDependencies":[]}