{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { clamp, deepMix, each, get, isArray, isNil, size } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { Trend } from '../trend/trend';\nimport { DEFAULT_HANDLER_STYLE, Handler } from './handler';\nimport { BACKGROUND_STYLE, DEFAULT_HANDLER_WIDTH, FOREGROUND_STYLE, HANDLER_STYLE, SLIDER_CHANGE, TEXT_STYLE } from './constant';\nvar Slider = /** @class */function (_super) {\n  __extends(Slider, _super);\n  function Slider() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.onMouseDown = function (target) {\n      return function (e) {\n        _this.currentTarget = target;\n        // 取出原生事件\n        var event = e.originalEvent;\n        // 2. 存储当前点击位置\n        event.stopPropagation();\n        event.preventDefault();\n        // 兼容移动端获取数据\n        _this.prevX = get(event, 'touches.0.pageX', event.pageX);\n        _this.prevY = get(event, 'touches.0.pageY', event.pageY);\n        // 3. 开始滑动的时候，绑定 move 和 up 事件\n        var containerDOM = _this.getContainerDOM();\n        containerDOM.addEventListener('mousemove', _this.onMouseMove);\n        containerDOM.addEventListener('mouseup', _this.onMouseUp);\n        containerDOM.addEventListener('mouseleave', _this.onMouseUp);\n        // 移动端事件\n        containerDOM.addEventListener('touchmove', _this.onMouseMove);\n        containerDOM.addEventListener('touchend', _this.onMouseUp);\n        containerDOM.addEventListener('touchcancel', _this.onMouseUp);\n      };\n    };\n    _this.onMouseMove = function (event) {\n      var width = _this.cfg.width;\n      var originValue = [_this.get('start'), _this.get('end')];\n      // 滑动过程中，计算偏移，更新滑块，然后 emit 数据出去\n      event.stopPropagation();\n      event.preventDefault();\n      var x = get(event, 'touches.0.pageX', event.pageX);\n      var y = get(event, 'touches.0.pageY', event.pageY);\n      // 横向的 slider 只处理 x\n      var offsetX = x - _this.prevX;\n      var offsetXRange = _this.adjustOffsetRange(offsetX / width);\n      // 更新 start end range 范围\n      _this.updateStartEnd(offsetXRange);\n      // 更新 ui\n      _this.updateUI(_this.getElementByLocalId('foreground'), _this.getElementByLocalId('minText'), _this.getElementByLocalId('maxText'));\n      _this.prevX = x;\n      _this.prevY = y;\n      _this.draw();\n      // 因为存储的 start、end 可能不一定是按大小存储的，所以排序一下，对外是 end >= start\n      _this.emit(SLIDER_CHANGE, [_this.get('start'), _this.get('end')].sort());\n      _this.delegateEmit('valuechanged', {\n        originValue: originValue,\n        value: [_this.get('start'), _this.get('end')]\n      });\n    };\n    _this.onMouseUp = function () {\n      // 结束之后，取消绑定的事件\n      if (_this.currentTarget) {\n        _this.currentTarget = undefined;\n      }\n      var containerDOM = _this.getContainerDOM();\n      if (containerDOM) {\n        containerDOM.removeEventListener('mousemove', _this.onMouseMove);\n        containerDOM.removeEventListener('mouseup', _this.onMouseUp);\n        // 防止滑动到 canvas 外部之后，状态丢失\n        containerDOM.removeEventListener('mouseleave', _this.onMouseUp);\n        // 移动端事件\n        containerDOM.removeEventListener('touchmove', _this.onMouseMove);\n        containerDOM.removeEventListener('touchend', _this.onMouseUp);\n        containerDOM.removeEventListener('touchcancel', _this.onMouseUp);\n      }\n    };\n    return _this;\n  }\n  Slider.prototype.setRange = function (min, max) {\n    this.set('minLimit', min);\n    this.set('maxLimit', max);\n    var oldStart = this.get('start');\n    var oldEnd = this.get('end');\n    var newStart = clamp(oldStart, min, max);\n    var newEnd = clamp(oldEnd, min, max);\n    if (!this.get('isInit') && (oldStart !== newStart || oldEnd !== newEnd)) {\n      this.setValue([newStart, newEnd]);\n    }\n  };\n  Slider.prototype.getRange = function () {\n    return {\n      min: this.get('minLimit') || 0,\n      max: this.get('maxLimit') || 1\n    };\n  };\n  Slider.prototype.setValue = function (value) {\n    var range = this.getRange();\n    if (isArray(value) && value.length === 2) {\n      var originValue = [this.get('start'), this.get('end')];\n      this.update({\n        start: clamp(value[0], range.min, range.max),\n        end: clamp(value[1], range.min, range.max)\n      });\n      if (!this.get('updateAutoRender')) {\n        this.render();\n      }\n      this.delegateEmit('valuechanged', {\n        originValue: originValue,\n        value: value\n      });\n    }\n  };\n  Slider.prototype.getValue = function () {\n    return [this.get('start'), this.get('end')];\n  };\n  Slider.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      name: 'slider',\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 16,\n      backgroundStyle: {},\n      foregroundStyle: {},\n      handlerStyle: {},\n      textStyle: {},\n      defaultCfg: {\n        backgroundStyle: BACKGROUND_STYLE,\n        foregroundStyle: FOREGROUND_STYLE,\n        handlerStyle: HANDLER_STYLE,\n        textStyle: TEXT_STYLE\n      }\n    });\n  };\n  Slider.prototype.update = function (cfg) {\n    var start = cfg.start,\n      end = cfg.end;\n    var validCfg = __assign({}, cfg);\n    if (!isNil(start)) {\n      validCfg.start = clamp(start, 0, 1);\n    }\n    if (!isNil(end)) {\n      validCfg.end = clamp(end, 0, 1);\n    }\n    _super.prototype.update.call(this, validCfg);\n    this.minHandler = this.getChildComponentById(this.getElementId('minHandler'));\n    this.maxHandler = this.getChildComponentById(this.getElementId('maxHandler'));\n    this.trend = this.getChildComponentById(this.getElementId('trend'));\n  };\n  Slider.prototype.init = function () {\n    this.set('start', clamp(this.get('start'), 0, 1));\n    this.set('end', clamp(this.get('end'), 0, 1));\n    _super.prototype.init.call(this);\n  };\n  Slider.prototype.render = function () {\n    _super.prototype.render.call(this);\n    this.updateUI(this.getElementByLocalId('foreground'), this.getElementByLocalId('minText'), this.getElementByLocalId('maxText'));\n  };\n  Slider.prototype.renderInner = function (group) {\n    var _a = this.cfg,\n      start = _a.start,\n      end = _a.end,\n      width = _a.width,\n      height = _a.height,\n      _b = _a.trendCfg,\n      trendCfg = _b === void 0 ? {} : _b,\n      minText = _a.minText,\n      maxText = _a.maxText,\n      _c = _a.backgroundStyle,\n      backgroundStyle = _c === void 0 ? {} : _c,\n      _d = _a.foregroundStyle,\n      foregroundStyle = _d === void 0 ? {} : _d,\n      _e = _a.textStyle,\n      textStyle = _e === void 0 ? {} : _e;\n    var handlerStyle = deepMix({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);\n    var min = start * width;\n    var max = end * width;\n    // 趋势图数据\n    if (size(get(trendCfg, 'data'))) {\n      this.trend = this.addComponent(group, __assign({\n        component: Trend,\n        id: this.getElementId('trend'),\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }, trendCfg));\n    }\n    // 1. 背景\n    this.addShape(group, {\n      id: this.getElementId('background'),\n      type: 'rect',\n      attrs: __assign({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }, backgroundStyle)\n    });\n    // 2. 左右文字\n    var minTextShape = this.addShape(group, {\n      id: this.getElementId('minText'),\n      type: 'text',\n      attrs: __assign({\n        // x: 0,\n        y: height / 2,\n        textAlign: 'right',\n        text: minText,\n        silent: false\n      }, textStyle)\n    });\n    var maxTextShape = this.addShape(group, {\n      id: this.getElementId('maxText'),\n      type: 'text',\n      attrs: __assign({\n        // x: 0,\n        y: height / 2,\n        textAlign: 'left',\n        text: maxText,\n        silent: false\n      }, textStyle)\n    });\n    // 3. 前景 选中背景框\n    var foregroundShape = this.addShape(group, {\n      id: this.getElementId('foreground'),\n      name: 'foreground',\n      type: 'rect',\n      attrs: __assign({\n        // x: 0,\n        y: 0,\n        // width: 0,\n        height: height\n      }, foregroundStyle)\n    });\n    // 滑块相关的大小信息\n    var handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n    var handlerHeight = get(handlerStyle, 'height', 24);\n    // 4. 左右滑块\n    this.minHandler = this.addComponent(group, {\n      component: Handler,\n      id: this.getElementId('minHandler'),\n      name: 'handler-min',\n      x: 0,\n      y: (height - handlerHeight) / 2,\n      width: handlerWidth,\n      height: handlerHeight,\n      cursor: 'ew-resize',\n      style: handlerStyle\n    });\n    this.maxHandler = this.addComponent(group, {\n      component: Handler,\n      id: this.getElementId('maxHandler'),\n      name: 'handler-max',\n      x: 0,\n      y: (height - handlerHeight) / 2,\n      width: handlerWidth,\n      height: handlerHeight,\n      cursor: 'ew-resize',\n      style: handlerStyle\n    });\n  };\n  Slider.prototype.applyOffset = function () {\n    this.moveElementTo(this.get('group'), {\n      x: this.get('x'),\n      y: this.get('y')\n    });\n  };\n  Slider.prototype.initEvent = function () {\n    this.bindEvents();\n  };\n  Slider.prototype.updateUI = function (foregroundShape, minTextShape, maxTextShape) {\n    var _a = this.cfg,\n      start = _a.start,\n      end = _a.end,\n      width = _a.width,\n      minText = _a.minText,\n      maxText = _a.maxText,\n      handlerStyle = _a.handlerStyle,\n      height = _a.height;\n    var min = start * width;\n    var max = end * width;\n    if (this.trend) {\n      this.trend.update({\n        width: width,\n        height: height\n      });\n      if (!this.get('updateAutoRender')) {\n        this.trend.render();\n      }\n    }\n    // 1. foreground\n    foregroundShape.attr('x', min);\n    foregroundShape.attr('width', max - min);\n    // 滑块相关的大小信息\n    var handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n    // 设置文本\n    minTextShape.attr('text', minText);\n    maxTextShape.attr('text', maxText);\n    var _b = this._dodgeText([min, max], minTextShape, maxTextShape),\n      minAttrs = _b[0],\n      maxAttrs = _b[1];\n    // 2. 左侧滑块和文字位置\n    if (this.minHandler) {\n      this.minHandler.update({\n        x: min - handlerWidth / 2\n      });\n      if (!this.get('updateAutoRender')) {\n        this.minHandler.render();\n      }\n    }\n    each(minAttrs, function (v, k) {\n      return minTextShape.attr(k, v);\n    });\n    // 3. 右侧滑块和文字位置\n    if (this.maxHandler) {\n      this.maxHandler.update({\n        x: max - handlerWidth / 2\n      });\n      if (!this.get('updateAutoRender')) {\n        this.maxHandler.render();\n      }\n    }\n    each(maxAttrs, function (v, k) {\n      return maxTextShape.attr(k, v);\n    });\n  };\n  Slider.prototype.bindEvents = function () {\n    var group = this.get('group');\n    group.on('handler-min:mousedown', this.onMouseDown('minHandler'));\n    group.on('handler-min:touchstart', this.onMouseDown('minHandler'));\n    // 2. 右滑块的滑动\n    group.on('handler-max:mousedown', this.onMouseDown('maxHandler'));\n    group.on('handler-max:touchstart', this.onMouseDown('maxHandler'));\n    // 3. 前景选中区域\n    var foreground = group.findById(this.getElementId('foreground'));\n    foreground.on('mousedown', this.onMouseDown('foreground'));\n    foreground.on('touchstart', this.onMouseDown('foreground'));\n  };\n  /**\n   * 调整 offsetRange，因为一些范围的限制\n   * @param offsetRange\n   */\n  Slider.prototype.adjustOffsetRange = function (offsetRange) {\n    var _a = this.cfg,\n      start = _a.start,\n      end = _a.end;\n    // 针对不同的滑动组件，处理的方式不同\n    switch (this.currentTarget) {\n      case 'minHandler':\n        {\n          var min = 0 - start;\n          var max = 1 - start;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n      case 'maxHandler':\n        {\n          var min = 0 - end;\n          var max = 1 - end;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n      case 'foreground':\n        {\n          var min = 0 - start;\n          var max = 1 - end;\n          return Math.min(max, Math.max(min, offsetRange));\n        }\n    }\n  };\n  Slider.prototype.updateStartEnd = function (offsetRange) {\n    var _a = this.cfg,\n      start = _a.start,\n      end = _a.end;\n    // 操作不同的组件，反馈不一样\n    switch (this.currentTarget) {\n      case 'minHandler':\n        start += offsetRange;\n        break;\n      case 'maxHandler':\n        end += offsetRange;\n        break;\n      case 'foreground':\n        start += offsetRange;\n        end += offsetRange;\n        break;\n    }\n    this.set('start', start);\n    this.set('end', end);\n  };\n  /**\n   * 调整 text 的位置，自动躲避\n   * 根据位置，调整返回新的位置\n   * @param range\n   */\n  Slider.prototype._dodgeText = function (range, minTextShape, maxTextShape) {\n    var _a, _b;\n    var _c = this.cfg,\n      handlerStyle = _c.handlerStyle,\n      width = _c.width;\n    var PADDING = 2;\n    var handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n    var min = range[0],\n      max = range[1];\n    var sorted = false;\n    // 如果交换了位置，则对应的 min max 也交互\n    if (min > max) {\n      _a = [max, min], min = _a[0], max = _a[1];\n      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];\n      sorted = true;\n    }\n    // 避让规则，优先显示在两侧，只有显示不下的时候，才显示在中间\n    var minBBox = minTextShape.getBBox();\n    var maxBBox = maxTextShape.getBBox();\n    var minAttrs = minBBox.width > min - PADDING ? {\n      x: min + handlerWidth / 2 + PADDING,\n      textAlign: 'left'\n    } : {\n      x: min - handlerWidth / 2 - PADDING,\n      textAlign: 'right'\n    };\n    var maxAttrs = maxBBox.width > width - max - PADDING ? {\n      x: max - handlerWidth / 2 - PADDING,\n      textAlign: 'right'\n    } : {\n      x: max + handlerWidth / 2 + PADDING,\n      textAlign: 'left'\n    };\n    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];\n  };\n  Slider.prototype.draw = function () {\n    var container = this.get('container');\n    var canvas = container && container.get('canvas');\n    if (canvas) {\n      canvas.draw();\n    }\n  };\n  Slider.prototype.getContainerDOM = function () {\n    var container = this.get('container');\n    var canvas = container && container.get('canvas');\n    return canvas && canvas.get('container');\n  };\n  return Slider;\n}(GroupComponent);\nexport { Slider };\nexport default Slider;","map":{"version":3,"mappings":"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","names":["clamp","deepMix","each","get","isArray","isNil","size","GroupComponent","Trend","DEFAULT_HANDLER_STYLE","Handler","BACKGROUND_STYLE","DEFAULT_HANDLER_WIDTH","FOREGROUND_STYLE","HANDLER_STYLE","SLIDER_CHANGE","TEXT_STYLE","__extends","_this","target","e","currentTarget","event","originalEvent","stopPropagation","preventDefault","prevX","pageX","prevY","pageY","containerDOM","getContainerDOM","addEventListener","onMouseMove","onMouseUp","cfg","originValue","x","y","offsetX","offsetXRange","adjustOffsetRange","width","updateStartEnd","updateUI","getElementByLocalId","draw","emit","sort","delegateEmit","value","undefined","removeEventListener","Slider","min","max","set","oldStart","oldEnd","newStart","newEnd","setValue","range","getRange","length","update","start","end","render","_super","getDefaultCfg","name","height","backgroundStyle","foregroundStyle","handlerStyle","textStyle","defaultCfg","validCfg","minHandler","getChildComponentById","getElementId","maxHandler","trend","init","group","_b","trendCfg","minText","maxText","_c","_d","_e","addComponent","component","id","addShape","type","attrs","minTextShape","textAlign","text","silent","maxTextShape","foregroundShape","handlerWidth","handlerHeight","cursor","style","moveElementTo","bindEvents","attr","_dodgeText","minAttrs","maxAttrs","v","k","on","onMouseDown","foreground","findById","offsetRange","Math","PADDING","sorted","_a","minBBox","getBBox","maxBBox","container","canvas"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/component/src/slider/slider.ts"],"sourcesContent":["import { Event, IGroup, IShape } from '@antv/g-base';\nimport { clamp, deepMix, each, get, isArray, isNil, size } from '@antv/util';\nimport GroupComponent from '../abstract/group-component';\nimport { ISlider } from '../interfaces';\nimport { Trend } from '../trend/trend';\nimport { DEFAULT_HANDLER_STYLE, Handler, HandlerCfg } from './handler';\nimport { GroupComponentCfg, Range } from '../types';\nimport {\n  BACKGROUND_STYLE,\n  DEFAULT_HANDLER_WIDTH,\n  FOREGROUND_STYLE,\n  HANDLER_STYLE,\n  SLIDER_CHANGE,\n  TEXT_STYLE,\n} from './constant';\n\nexport interface TrendCfg {\n  // 数据\n  readonly data: number[];\n  // 样式\n  readonly smooth?: boolean;\n  readonly isArea?: boolean;\n  readonly backgroundStyle?: object;\n  readonly lineStyle?: object;\n  readonly areaStyle?: object;\n}\n\n/**\n * slider handler style 设置\n */\ntype HandlerStyle = HandlerCfg['style'] & {\n  readonly width?: number;\n  readonly height?: number;\n};\n\nexport interface SliderCfg extends GroupComponentCfg {\n  // position size\n  readonly x: number;\n  readonly y: number;\n  readonly width: number;\n  readonly height: number;\n\n  // style\n  readonly trendCfg?: TrendCfg;\n  readonly backgroundStyle?: any;\n  readonly foregroundStyle?: any;\n  readonly handlerStyle?: HandlerStyle;\n  readonly textStyle?: any;\n  // 允许滑动位置\n  readonly minLimit?: number;\n  readonly maxLimit?: number;\n  // 初始位置\n  readonly start?: number;\n  readonly end?: number;\n  // 滑块文本\n  readonly minText?: string;\n  readonly maxText?: string;\n}\n\nexport class Slider extends GroupComponent<SliderCfg> implements ISlider {\n  public cfg: SliderCfg;\n\n  private minHandler: Handler;\n  private maxHandler: Handler;\n  private trend: Trend;\n  private currentTarget: string;\n  private prevX: number;\n  private prevY: number;\n\n  public setRange(min: number, max: number) {\n    this.set('minLimit', min);\n    this.set('maxLimit', max);\n    const oldStart = this.get('start');\n    const oldEnd = this.get('end');\n    const newStart = clamp(oldStart, min, max);\n    const newEnd = clamp(oldEnd, min, max);\n    if (!this.get('isInit') && (oldStart !== newStart || oldEnd !== newEnd)) {\n      this.setValue([newStart, newEnd]);\n    }\n  }\n\n  public getRange(): Range {\n    return {\n      min: this.get('minLimit') || 0,\n      max: this.get('maxLimit') || 1,\n    };\n  }\n\n  public setValue(value: number | number[]) {\n    const range = this.getRange();\n    if (isArray(value) && value.length === 2) {\n      const originValue = [this.get('start'), this.get('end')];\n      this.update({\n        start: clamp(value[0], range.min, range.max),\n        end: clamp(value[1], range.min, range.max),\n      });\n      if (!this.get('updateAutoRender')) {\n        this.render();\n      }\n      this.delegateEmit('valuechanged', {\n        originValue,\n        value,\n      });\n    }\n  }\n\n  public getValue(): number | number[] {\n    return [this.get('start'), this.get('end')];\n  }\n\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      name: 'slider',\n      x: 0,\n      y: 0,\n      width: 100,\n      height: 16,\n      backgroundStyle: {},\n      foregroundStyle: {},\n      handlerStyle: {},\n      textStyle: {},\n      defaultCfg: {\n        backgroundStyle: BACKGROUND_STYLE,\n        foregroundStyle: FOREGROUND_STYLE,\n        handlerStyle: HANDLER_STYLE,\n        textStyle: TEXT_STYLE,\n      },\n    };\n  }\n\n  public update(cfg: Partial<SliderCfg>) {\n    const { start, end } = cfg;\n    const validCfg = { ...cfg };\n    if (!isNil(start)) {\n      validCfg.start = clamp(start, 0, 1);\n    }\n    if (!isNil(end)) {\n      validCfg.end = clamp(end, 0, 1);\n    }\n    super.update(validCfg);\n    this.minHandler = this.getChildComponentById(this.getElementId('minHandler'));\n    this.maxHandler = this.getChildComponentById(this.getElementId('maxHandler'));\n    this.trend = this.getChildComponentById(this.getElementId('trend'));\n  }\n\n  public init() {\n    this.set('start', clamp(this.get('start'), 0, 1));\n    this.set('end', clamp(this.get('end'), 0, 1));\n    super.init();\n  }\n\n  public render() {\n    super.render();\n\n    this.updateUI(\n      this.getElementByLocalId('foreground'),\n      this.getElementByLocalId('minText'),\n      this.getElementByLocalId('maxText')\n    );\n  }\n\n  protected renderInner(group: IGroup) {\n    const {\n      start,\n      end,\n      width,\n      height,\n      trendCfg = {},\n      minText,\n      maxText,\n      backgroundStyle = {},\n      foregroundStyle = {},\n      textStyle = {},\n    } = this.cfg;\n\n    const handlerStyle = deepMix({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);\n\n    const min = start * width;\n    const max = end * width;\n\n    // 趋势图数据\n    if (size(get(trendCfg, 'data'))) {\n      this.trend = this.addComponent(group, {\n        component: Trend,\n        id: this.getElementId('trend'),\n        x: 0,\n        y: 0,\n        width,\n        height,\n        ...trendCfg,\n      });\n    }\n\n    // 1. 背景\n    this.addShape(group, {\n      id: this.getElementId('background'),\n      type: 'rect',\n      attrs: {\n        x: 0,\n        y: 0,\n        width,\n        height,\n        ...backgroundStyle,\n      },\n    });\n\n    // 2. 左右文字\n    const minTextShape = this.addShape(group, {\n      id: this.getElementId('minText'),\n      type: 'text',\n      attrs: {\n        // x: 0,\n        y: height / 2,\n        textAlign: 'right',\n        text: minText,\n        silent: false,\n        ...textStyle,\n      },\n    });\n\n    const maxTextShape = this.addShape(group, {\n      id: this.getElementId('maxText'),\n      type: 'text',\n      attrs: {\n        // x: 0,\n        y: height / 2,\n        textAlign: 'left',\n        text: maxText,\n        silent: false,\n        ...textStyle,\n      },\n    });\n\n    // 3. 前景 选中背景框\n    const foregroundShape = this.addShape(group, {\n      id: this.getElementId('foreground'),\n      name: 'foreground',\n      type: 'rect',\n      attrs: {\n        // x: 0,\n        y: 0,\n        // width: 0,\n        height,\n        ...foregroundStyle,\n      },\n    });\n\n    // 滑块相关的大小信息\n    const handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n    const handlerHeight = get(handlerStyle, 'height', 24);\n\n    // 4. 左右滑块\n    this.minHandler = this.addComponent(group, {\n      component: Handler,\n      id: this.getElementId('minHandler'),\n      name: 'handler-min',\n      x: 0,\n      y: (height - handlerHeight) / 2,\n      width: handlerWidth,\n      height: handlerHeight,\n      cursor: 'ew-resize',\n      style: handlerStyle,\n    });\n\n    this.maxHandler = this.addComponent(group, {\n      component: Handler,\n      id: this.getElementId('maxHandler'),\n      name: 'handler-max',\n      x: 0,\n      y: (height - handlerHeight) / 2,\n      width: handlerWidth,\n      height: handlerHeight,\n      cursor: 'ew-resize',\n      style: handlerStyle,\n    });\n  }\n\n  protected applyOffset() {\n    this.moveElementTo(this.get('group'), {\n      x: this.get('x'),\n      y: this.get('y'),\n    });\n  }\n\n  protected initEvent() {\n    this.bindEvents();\n  }\n\n  private updateUI(foregroundShape: IShape, minTextShape: IShape, maxTextShape: IShape) {\n    const { start, end, width, minText, maxText, handlerStyle, height } = this.cfg as SliderCfg;\n    const min = start * width;\n    const max = end * width;\n\n    if (this.trend) {\n      this.trend.update({\n        width,\n        height,\n      });\n      if (!this.get('updateAutoRender')) {\n        this.trend.render();\n      }\n    }\n\n    // 1. foreground\n    foregroundShape.attr('x', min);\n    foregroundShape.attr('width', max - min);\n\n    // 滑块相关的大小信息\n    const handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n\n    // 设置文本\n    minTextShape.attr('text', minText);\n    maxTextShape.attr('text', maxText);\n\n    const [minAttrs, maxAttrs] = this._dodgeText([min, max], minTextShape, maxTextShape);\n    // 2. 左侧滑块和文字位置\n    if (this.minHandler) {\n      this.minHandler.update({\n        x: min - handlerWidth / 2,\n      });\n      if (!this.get('updateAutoRender')) {\n        this.minHandler.render();\n      }\n    }\n    each(minAttrs, (v, k) => minTextShape.attr(k, v));\n\n    // 3. 右侧滑块和文字位置\n    if (this.maxHandler) {\n      this.maxHandler.update({\n        x: max - handlerWidth / 2,\n      });\n      if (!this.get('updateAutoRender')) {\n        this.maxHandler.render();\n      }\n    }\n    each(maxAttrs, (v, k) => maxTextShape.attr(k, v));\n  }\n\n  private bindEvents() {\n    const group: IGroup = this.get('group');\n\n    group.on('handler-min:mousedown', this.onMouseDown('minHandler'));\n    group.on('handler-min:touchstart', this.onMouseDown('minHandler'));\n\n    // 2. 右滑块的滑动\n    group.on('handler-max:mousedown', this.onMouseDown('maxHandler'));\n    group.on('handler-max:touchstart', this.onMouseDown('maxHandler'));\n\n    // 3. 前景选中区域\n    const foreground = group.findById(this.getElementId('foreground'));\n    foreground.on('mousedown', this.onMouseDown('foreground'));\n    foreground.on('touchstart', this.onMouseDown('foreground'));\n  }\n\n  private onMouseDown = (target: string) => (e: Event) => {\n    this.currentTarget = target;\n    // 取出原生事件\n    const event = e.originalEvent as MouseEvent;\n\n    // 2. 存储当前点击位置\n    event.stopPropagation();\n    event.preventDefault();\n\n    // 兼容移动端获取数据\n    this.prevX = get(event, 'touches.0.pageX', event.pageX);\n    this.prevY = get(event, 'touches.0.pageY', event.pageY);\n\n    // 3. 开始滑动的时候，绑定 move 和 up 事件\n    const containerDOM = this.getContainerDOM();\n\n    containerDOM.addEventListener('mousemove', this.onMouseMove);\n    containerDOM.addEventListener('mouseup', this.onMouseUp);\n    containerDOM.addEventListener('mouseleave', this.onMouseUp);\n\n    // 移动端事件\n    containerDOM.addEventListener('touchmove', this.onMouseMove);\n    containerDOM.addEventListener('touchend', this.onMouseUp);\n    containerDOM.addEventListener('touchcancel', this.onMouseUp);\n  };\n\n  private onMouseMove = (event: MouseEvent) => {\n    const { width } = this.cfg as SliderCfg;\n    const originValue = [this.get('start'), this.get('end')];\n    // 滑动过程中，计算偏移，更新滑块，然后 emit 数据出去\n    event.stopPropagation();\n    event.preventDefault();\n\n    const x = get(event, 'touches.0.pageX', event.pageX);\n    const y = get(event, 'touches.0.pageY', event.pageY);\n\n    // 横向的 slider 只处理 x\n    const offsetX = x - this.prevX;\n\n    const offsetXRange = this.adjustOffsetRange(offsetX / width);\n\n    // 更新 start end range 范围\n    this.updateStartEnd(offsetXRange);\n    // 更新 ui\n    this.updateUI(\n      this.getElementByLocalId('foreground'),\n      this.getElementByLocalId('minText'),\n      this.getElementByLocalId('maxText')\n    );\n\n    this.prevX = x;\n    this.prevY = y;\n\n    this.draw();\n\n    // 因为存储的 start、end 可能不一定是按大小存储的，所以排序一下，对外是 end >= start\n    this.emit(SLIDER_CHANGE, [this.get('start'), this.get('end')].sort());\n    this.delegateEmit('valuechanged', {\n      originValue,\n      value: [this.get('start'), this.get('end')],\n    });\n  };\n\n  private onMouseUp = () => {\n    // 结束之后，取消绑定的事件\n    if (this.currentTarget) {\n      this.currentTarget = undefined;\n    }\n\n    const containerDOM = this.getContainerDOM();\n    if (containerDOM) {\n      containerDOM.removeEventListener('mousemove', this.onMouseMove);\n      containerDOM.removeEventListener('mouseup', this.onMouseUp);\n      // 防止滑动到 canvas 外部之后，状态丢失\n      containerDOM.removeEventListener('mouseleave', this.onMouseUp);\n\n      // 移动端事件\n      containerDOM.removeEventListener('touchmove', this.onMouseMove);\n      containerDOM.removeEventListener('touchend', this.onMouseUp);\n      containerDOM.removeEventListener('touchcancel', this.onMouseUp);\n    }\n  };\n\n  /**\n   * 调整 offsetRange，因为一些范围的限制\n   * @param offsetRange\n   */\n  private adjustOffsetRange(offsetRange: number): number {\n    const { start, end } = this.cfg as SliderCfg;\n    // 针对不同的滑动组件，处理的方式不同\n    switch (this.currentTarget) {\n      case 'minHandler': {\n        const min = 0 - start;\n        const max = 1 - start;\n\n        return Math.min(max, Math.max(min, offsetRange));\n      }\n      case 'maxHandler': {\n        const min = 0 - end;\n        const max = 1 - end;\n\n        return Math.min(max, Math.max(min, offsetRange));\n      }\n      case 'foreground': {\n        const min = 0 - start;\n        const max = 1 - end;\n\n        return Math.min(max, Math.max(min, offsetRange));\n      }\n    }\n  }\n\n  private updateStartEnd(offsetRange: number) {\n    let { start, end } = this.cfg as SliderCfg;\n    // 操作不同的组件，反馈不一样\n    switch (this.currentTarget) {\n      case 'minHandler':\n        start += offsetRange;\n        break;\n      case 'maxHandler':\n        end += offsetRange;\n        break;\n      case 'foreground':\n        start += offsetRange;\n        end += offsetRange;\n        break;\n    }\n    this.set('start', start);\n    this.set('end', end);\n  }\n\n  /**\n   * 调整 text 的位置，自动躲避\n   * 根据位置，调整返回新的位置\n   * @param range\n   */\n  private _dodgeText(range: [number, number], minTextShape, maxTextShape): [object, object] {\n    const { handlerStyle, width } = this.cfg as SliderCfg;\n    const PADDING = 2;\n    const handlerWidth = get(handlerStyle, 'width', DEFAULT_HANDLER_WIDTH);\n\n    let [min, max] = range;\n    let sorted = false;\n\n    // 如果交换了位置，则对应的 min max 也交互\n    if (min > max) {\n      [min, max] = [max, min];\n      [minTextShape, maxTextShape] = [maxTextShape, minTextShape];\n      sorted = true;\n    }\n\n    // 避让规则，优先显示在两侧，只有显示不下的时候，才显示在中间\n    const minBBox = minTextShape.getBBox();\n    const maxBBox = maxTextShape.getBBox();\n\n    const minAttrs =\n      minBBox.width > min - PADDING\n        ? { x: min + handlerWidth / 2 + PADDING, textAlign: 'left' }\n        : { x: min - handlerWidth / 2 - PADDING, textAlign: 'right' };\n\n    const maxAttrs =\n      maxBBox.width > width - max - PADDING\n        ? { x: max - handlerWidth / 2 - PADDING, textAlign: 'right' }\n        : { x: max + handlerWidth / 2 + PADDING, textAlign: 'left' };\n\n    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];\n  }\n\n  public draw() {\n    const container = this.get('container');\n    const canvas = container && container.get('canvas');\n    if (canvas) {\n      canvas.draw();\n    }\n  }\n\n  private getContainerDOM() {\n    const container = this.get('container');\n    const canvas = container && container.get('canvas');\n\n    return canvas && canvas.get('container');\n  }\n}\n\nexport default Slider;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}