{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\nvar Line = /** @class */function (_super) {\n  __extends(Line, _super);\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Line.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'line',\n      locationType: 'region',\n      /**\n       * 起始点, x, y\n       * @type {object}\n       */\n      start: null,\n      /**\n       * 结束点, x, y\n       * @type {object}\n       */\n      end: null\n    });\n  };\n  // 获取坐标轴线的 path\n  Line.prototype.getLinePath = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    var path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  };\n  // 重新计算 layout bbox，考虑到 line 不显示\n  Line.prototype.getInnerLayoutBBox = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    var bbox = _super.prototype.getInnerLayoutBBox.call(this);\n    var minX = Math.min(start.x, end.x, bbox.x);\n    var minY = Math.min(start.y, end.y, bbox.y);\n    var maxX = Math.max(start.x, end.x, bbox.maxX);\n    var maxY = Math.max(start.y, end.y, bbox.maxY);\n    return {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  };\n  Line.prototype.isVertical = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.x, end.x);\n  };\n  Line.prototype.isHorizontal = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return isNumberEqual(start.y, end.y);\n  };\n  Line.prototype.getTickPoint = function (tickValue) {\n    var self = this;\n    var start = self.get('start');\n    var end = self.get('end');\n    var regionX = end.x - start.x;\n    var regionY = end.y - start.y;\n    return {\n      x: start.x + regionX * tickValue,\n      y: start.y + regionY * tickValue\n    };\n  };\n  // 直线坐标轴下任一点的向量方向都相同\n  Line.prototype.getSideVector = function (offset) {\n    var axisVector = this.getAxisVector();\n    var normal = vec2.normalize([0, 0], axisVector);\n    var factor = this.get('verticalFactor');\n    var verticalVector = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n    return vec2.scale([0, 0], verticalVector, offset * factor);\n  };\n  // 获取坐标轴的向量\n  Line.prototype.getAxisVector = function () {\n    var start = this.get('start');\n    var end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  };\n  Line.prototype.processOverlap = function (labelGroup) {\n    var _this = this;\n    var isVertical = this.isVertical();\n    var isHorizontal = this.isHorizontal();\n    // 非垂直，或者非水平时不处理遮挡问题\n    if (!isVertical && !isHorizontal) {\n      return;\n    }\n    var labelCfg = this.get('label');\n    var titleCfg = this.get('title');\n    var verticalLimitLength = this.get('verticalLimitLength');\n    var labelOffset = labelCfg.offset;\n    var limitLength = verticalLimitLength;\n    var titleHeight = 0;\n    var titleSpacing = 0;\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n    var overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, function (name) {\n      if (labelCfg[name] && _this.canProcessOverlap(name)) {\n        _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        var bbox = labelGroup.getCanvasBBox();\n        var length_1 = isVertical ? bbox.width : bbox.height;\n        // 如果用户没有设置 offset，则自动计算\n        titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;\n      }\n    }\n  };\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n  Line.prototype.canProcessOverlap = function (name) {\n    var labelCfg = this.get('label');\n    // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    }\n    // 默认所有 overlap 都可执行\n    return true;\n  };\n  Line.prototype.autoProcessOverlap = function (name, value, labelGroup, limitLength) {\n    var _this = this;\n    var isVertical = this.isVertical();\n    var hasAdjusted = false;\n    var util = OverlapUtil[name];\n    if (value === true) {\n      var labelCfg = this.get('label');\n      // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n    } else if (isFunction(value)) {\n      // 回调函数形式的配置： 用户可以传入回调函数\n      hasAdjusted = value(isVertical, labelGroup, limitLength);\n    } else if (isObject(value)) {\n      // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n      var overlapCfg = value;\n      if (util[overlapCfg.type]) {\n        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n      }\n    } else if (util[value]) {\n      // 字符串类型的配置：按照名称执行 overlap 处理方法\n      hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n    }\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        var labels = labelGroup.getChildren();\n        var verticalFactor_1 = this.get('verticalFactor');\n        each(labels, function (label) {\n          var textAlign = label.attr('textAlign');\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            var newAlign = verticalFactor_1 > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      var children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n      each(children, function (label) {\n        if (!label.get('visible')) {\n          if (_this.get('isRegister')) {\n            // 已经注册过了，则删除\n            _this.unregisterElement(label);\n          }\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  };\n\n  return Line;\n}(AxisBase);\nexport default Line;","map":{"version":3,"mappings":"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","names":["vec2","each","isFunction","isNil","isNumberEqual","isObject","AxisBase","OverlapUtil","__extends","Line","cfg","_super","getDefaultCfg","type","locationType","start","end","get","path","push","x","y","bbox","getInnerLayoutBBox","minX","Math","min","minY","maxX","max","maxY","width","height","tickValue","self","regionX","regionY","offset","axisVector","getAxisVector","normal","normalize","factor","verticalVector","scale","labelGroup","isVertical","isHorizontal","labelCfg","titleCfg","verticalLimitLength","labelOffset","limitLength","titleHeight","titleSpacing","style","fontSize","spacing","overlapOrder","name","_this","canProcessOverlap","autoProcessOverlap","getCanvasBBox","length_1","rotate","value","hasAdjusted","util","getDefault","overlapCfg","labels","getChildren","verticalFactor_1","label","textAlign","attr","newAlign","children","slice","unregisterElement","remove"],"sources":["/home/iam/Documents/network/node_modules/@antv/component/src/axis/line.ts"],"sourcesContent":["import { IGroup } from '@antv/g-base';\nimport { vec2 } from '@antv/matrix-util';\nimport { each, isFunction, isNil, isNumberEqual, isObject } from '@antv/util';\nimport { ILocation } from '../interfaces';\nimport { AxisLabelAutoHideCfg, BBox, LineAxisCfg, Point, RegionLocationCfg } from '../types';\nimport Theme from '../util/theme';\nimport AxisBase from './base';\nimport * as OverlapUtil from './overlap';\n\nclass Line extends AxisBase<LineAxisCfg> implements ILocation<RegionLocationCfg> {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n      locationType: 'region',\n      /**\n       * 起始点, x, y\n       * @type {object}\n       */\n      start: null,\n      /**\n       * 结束点, x, y\n       * @type {object}\n       */\n      end: null,\n    };\n  }\n\n  // 获取坐标轴线的 path\n  public getLinePath(): any[] {\n    const start = this.get('start');\n    const end = this.get('end');\n    const path = [];\n    path.push(['M', start.x, start.y]);\n    path.push(['L', end.x, end.y]);\n    return path;\n  }\n\n  // 重新计算 layout bbox，考虑到 line 不显示\n  protected getInnerLayoutBBox(): BBox {\n    const start = this.get('start');\n    const end = this.get('end');\n    const bbox = super.getInnerLayoutBBox();\n    const minX = Math.min(start.x, end.x, bbox.x);\n    const minY = Math.min(start.y, end.y, bbox.y);\n    const maxX = Math.max(start.x, end.x, bbox.maxX);\n    const maxY = Math.max(start.y, end.y, bbox.maxY);\n    return {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n\n  protected isVertical() {\n    const start = this.get('start');\n    const end = this.get('end');\n    return isNumberEqual(start.x, end.x);\n  }\n\n  protected isHorizontal() {\n    const start = this.get('start');\n    const end = this.get('end');\n    return isNumberEqual(start.y, end.y);\n  }\n\n  protected getTickPoint(tickValue: number): Point {\n    const self = this;\n    const start = self.get('start');\n    const end = self.get('end');\n    const regionX = end.x - start.x;\n    const regionY = end.y - start.y;\n    return {\n      x: start.x + regionX * tickValue,\n      y: start.y + regionY * tickValue,\n    };\n  }\n\n  // 直线坐标轴下任一点的向量方向都相同\n  protected getSideVector(offset: number) {\n    const axisVector = this.getAxisVector();\n    const normal = vec2.normalize([0, 0], axisVector);\n    const factor = this.get('verticalFactor');\n    const verticalVector: [number, number] = [normal[1], normal[0] * -1]; // 垂直方向，逆时针方向\n    return vec2.scale([0, 0], verticalVector, offset * factor);\n  }\n\n  // 获取坐标轴的向量\n  protected getAxisVector(): [number, number] {\n    const start = this.get('start');\n    const end = this.get('end');\n    return [end.x - start.x, end.y - start.y];\n  }\n\n  protected processOverlap(labelGroup) {\n    const isVertical = this.isVertical();\n    const isHorizontal = this.isHorizontal();\n    // 非垂直，或者非水平时不处理遮挡问题\n    if (!isVertical && !isHorizontal) {\n      return;\n    }\n    const labelCfg = this.get('label');\n    const titleCfg = this.get('title');\n    const verticalLimitLength = this.get('verticalLimitLength');\n    const labelOffset = labelCfg.offset;\n    let limitLength = verticalLimitLength;\n    let titleHeight = 0;\n    let titleSpacing = 0;\n    if (titleCfg) {\n      titleHeight = titleCfg.style.fontSize;\n      titleSpacing = titleCfg.spacing;\n    }\n    if (limitLength) {\n      limitLength = limitLength - labelOffset - titleSpacing - titleHeight;\n    }\n    const overlapOrder = this.get('overlapOrder');\n    each(overlapOrder, (name) => {\n      if (labelCfg[name] && this.canProcessOverlap(name)) {\n        this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);\n      }\n    });\n    if (titleCfg) {\n      if (isNil(titleCfg.offset)) {\n        // 调整 title 的 offset\n        const bbox = labelGroup.getCanvasBBox();\n        const length = isVertical ? bbox.width : bbox.height;\n        // 如果用户没有设置 offset，则自动计算\n        titleCfg.offset = labelOffset + length + titleSpacing + titleHeight / 2;\n      }\n    }\n  }\n\n  /**\n   * 是否可以执行某一 overlap\n   * @param name\n   */\n  private canProcessOverlap(name: string) {\n    const labelCfg = this.get('label');\n\n    // 对 autoRotate，如果配置了旋转角度，直接进行固定角度旋转\n    if (name === 'autoRotate') {\n      return isNil(labelCfg.rotate);\n    }\n\n    // 默认所有 overlap 都可执行\n    return true;\n  }\n\n  private autoProcessOverlap(name: string, value: any, labelGroup: IGroup, limitLength: number) {\n    const isVertical = this.isVertical();\n    let hasAdjusted = false;\n    const util = OverlapUtil[name];\n    if (value === true) {\n      const labelCfg = this.get('label');\n      // true 形式的配置：使用 overlap 默认的的处理方法进行处理\n      hasAdjusted = util.getDefault()(isVertical, labelGroup, limitLength);\n    } else if (isFunction(value)) {\n      // 回调函数形式的配置： 用户可以传入回调函数\n      hasAdjusted = value(isVertical, labelGroup, limitLength);\n    } else if (isObject(value)) {\n      // object 形式的配置方式：包括 处理方法 type， 和可选参数配置 cfg\n      const overlapCfg = value as { type: string; cfg?: AxisLabelAutoHideCfg };\n      if (util[overlapCfg.type]) {\n        hasAdjusted = util[overlapCfg.type](isVertical, labelGroup, limitLength, overlapCfg.cfg);\n      }\n    } else if (util[value]) {\n      // 字符串类型的配置：按照名称执行 overlap 处理方法\n      hasAdjusted = util[value](isVertical, labelGroup, limitLength);\n    }\n    if (name === 'autoRotate') {\n      // 文本旋转后，文本的对齐方式可能就不合适了\n      if (hasAdjusted) {\n        const labels = labelGroup.getChildren();\n        const verticalFactor = this.get('verticalFactor');\n        each(labels, (label) => {\n          const textAlign = label.attr('textAlign');\n          if (textAlign === 'center') {\n            // 居中的文本需要调整旋转度\n            const newAlign = verticalFactor > 0 ? 'end' : 'start';\n            label.attr('textAlign', newAlign);\n          }\n        });\n      }\n    } else if (name === 'autoHide') {\n      const children = labelGroup.getChildren().slice(0); // 复制数组，删除时不会出错\n      each(children, (label) => {\n        if (!label.get('visible')) {\n          if (this.get('isRegister')) {\n            // 已经注册过了，则删除\n            this.unregisterElement(label);\n          }\n          label.remove(); // 防止 label 数量太多，所以统一删除\n        }\n      });\n    }\n  }\n}\n\nexport default Line;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}