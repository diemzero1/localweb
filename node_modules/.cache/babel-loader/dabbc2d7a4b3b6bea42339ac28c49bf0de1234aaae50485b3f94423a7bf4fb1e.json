{"ast":null,"code":"import { __values } from \"tslib\";\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\n/** 拐点偏移量, 暂不可配置 */\nvar INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nvar LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nvar LABEL_TEXT_LINE_OFFSET = 4;\nfunction drawLabelline(item, coordinate, inRight) {\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  var startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y\n  };\n  var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  var p1 = {\n    x: startPoint.x,\n    y: startPoint.y\n  };\n  var p2 = {\n    x: inflectionPoint.x,\n    y: inflectionPoint.y\n  };\n  var endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  var path = '';\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    var offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n  path = [\"M \".concat(startPoint.x, \",\").concat(startPoint.y), \"L \".concat(p1.x, \",\").concat(p1.y), \"L \".concat(p2.x, \",\").concat(p2.y), \"L \".concat(inflectionPoint.x, \",\").concat(inflectionPoint.y), \"L \".concat(endPoint.x, \",\").concat(endPoint.y)].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, {\n    path: path\n  });\n}\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items, labels, shapes, region) {\n  var e_1, _a;\n  /** 坐标系 */\n  var coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n  /** 坐标圆心 */\n  var center = coordinate.getCenter();\n  /** 圆半径 */\n  var radius = coordinate.getRadius();\n  /** label shapes */\n  var labelsMap = {};\n  try {\n    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {\n      var labelShape = labels_1_1.value;\n      labelsMap[labelShape.get('id')] = labelShape;\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (labels_1_1 && !labels_1_1.done && (_a = labels_1.return)) _a.call(labels_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n  var labelHeight = get(items[0], 'labelHeight', 14);\n  var labelOffset = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n  // step 1: adjust items to spider\n  each(items, function (item) {\n    if (!item) return;\n    var label = get(labelsMap, [item.id]);\n    if (!label) return;\n    var inRight = item.x > center.x || item.x === center.x && item.y > center.y;\n    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    var inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n    var totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n  var start = coordinate.start,\n    end = coordinate.end;\n  var LEFT_HALF_KEY = 'left';\n  var RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  var separateLabels = groupBy(items, function (item) {\n    return item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;\n  });\n  // step2: calculate totalHeight\n  var totalHeight = (radius + labelOffset) * 2 + labelHeight;\n  each(separateLabels, function (half) {\n    var halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  var labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2\n  };\n  // step 3: antiCollision\n  each(separateLabels, function (half, key) {\n    var maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort(function (a, b) {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n      each(half, function (labelItem, idx) {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n  var startY = labelsContainerRange.minY;\n  var endY = labelsContainerRange.maxY;\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, function (half, key) {\n    var inRight = key === RIGHT_HALF_KEY;\n    each(half, function (item) {\n      var label = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n      var labelContent = label.getChildByIndex(0);\n      var box = labelContent.getCanvasBBox();\n      var originalPos = {\n        x: inRight ? box.x : box.maxX,\n        y: box.y + box.height / 2 /** vertical-align: middle */\n      };\n      translate(labelContent, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["each","get","isNil","deepMix","groupBy","polarToCartesian","antiCollision","translate","INFLECTION_OFFSET","LABEL_OFFSET_X","LABEL_TEXT_LINE_OFFSET","drawLabelline","item","coordinate","inRight","center","getCenter","radius","getRadius","startPoint","x","y","inflectionPoint","angle","p1","p2","endPoint","path","offset","Math","PI","max","min","join","labelLine","pieSpiderLabelLayout","items","labels","shapes","region","labelsMap","labelShape","labelHeight","labelOffset","label","id","offsetX","totalOffset","end","LEFT_HALF_KEY","RIGHT_HALF_KEY","separateLabels","totalHeight","half","halfHeight","length","abs","start","labelsContainerRange","minX","maxX","minY","maxY","key","maxLabelsCountForOneSide","sort","a","b","percent","labelItem","idx","set","invisible","startY","endY","labelContent","getChildByIndex","box","getCanvasBBox","originalPos","height"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g2/src/geometry/label/layout/pie/spider.ts"],"sourcesContent":["import { BBox, IGroup, IShape } from '@antv/g-base';\nimport { each, get, isNil, deepMix, groupBy } from '@antv/util';\nimport { polarToCartesian } from '../../../../util/graphics';\nimport { LabelItem, PolarLabelItem } from '../../interface';\nimport { antiCollision } from './util';\nimport { translate } from '../../../../util/transform';\nimport { Coordinate } from '@antv/coord';\n\n/** 拐点偏移量, 暂不可配置 */\nconst INFLECTION_OFFSET = 4;\n/** 标签偏移量, distance between label and edge: offsetX */\nconst LABEL_OFFSET_X = 4;\n/** 标签与牵引线的偏移量 */\nconst LABEL_TEXT_LINE_OFFSET = 4;\n\nfunction drawLabelline(item: PolarLabelItem, coordinate: Coordinate, inRight: boolean) {\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  const startPoint = {\n    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),\n    y: item.y,\n  };\n  const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n  const p1 = { x: startPoint.x, y: startPoint.y };\n  const p2 = { x: inflectionPoint.x, y: inflectionPoint.y };\n\n  const endPoint = polarToCartesian(center.x, center.y, radius, item.angle);\n  let path = '';\n\n  // 文本被调整下去了，则添加拐点连接线\n  if (startPoint.y !== inflectionPoint.y) {\n    const offset = inRight ? 4 : -4;\n    p1.y = startPoint.y;\n\n    /** 是否在第一象限 */\n    if (item.angle < 0 && item.angle >= -Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第二象限 */\n    if (item.angle > 0 && item.angle < Math.PI / 2) {\n      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.max(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第三象限 */\n    if (item.angle > Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y > inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n    /** 是否在 第四象限 */\n    if (item.angle < -Math.PI / 2) {\n      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);\n      if (startPoint.y < inflectionPoint.y) {\n        p2.y = p1.y;\n      } else {\n        p2.y = inflectionPoint.y;\n        p2.x = Math.min(p2.x, p1.x - offset);\n      }\n    }\n  }\n\n  path = [\n    `M ${startPoint.x},${startPoint.y}`,\n    `L ${p1.x},${p1.y}`,\n    `L ${p2.x},${p2.y}`,\n    `L ${inflectionPoint.x},${inflectionPoint.y}`,\n    `L ${endPoint.x},${endPoint.y}`,\n  ].join(' ');\n  item.labelLine = deepMix({}, item.labelLine, { path });\n}\n\n/**\n * 饼图标签 spider 布局, 只适用于 pie-spider 的标签类型\n * region 应该是 labelsRenderer 容器的范围限制(便于后续组件间布局)\n */\nexport function pieSpiderLabelLayout(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  /** 坐标系 */\n  const coordinate = labels[0] && labels[0].get('coordinate');\n  if (!coordinate) {\n    return;\n  }\n\n  /** 坐标圆心 */\n  const center = coordinate.getCenter();\n  /** 圆半径 */\n  const radius = coordinate.getRadius();\n  /** label shapes */\n  const labelsMap: Record<string /** id */, IGroup> = {};\n  for (const labelShape of labels) {\n    labelsMap[labelShape.get('id')] = labelShape;\n  }\n\n  const labelHeight: number = get(items[0], 'labelHeight', 14);\n  const labelOffset: number = Math.max(get(items[0], 'offset', 0), INFLECTION_OFFSET);\n\n  // step 1: adjust items to spider\n  each(items, (item) => {\n    if (!item) return;\n    const label = get(labelsMap, [item.id]);\n    if (!label) return;\n\n    const inRight = item.x > center.x || (item.x === center.x && item.y > center.y);\n    const offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;\n    const inflectionPoint = polarToCartesian(center.x, center.y, radius + INFLECTION_OFFSET, item.angle);\n\n    const totalOffset = labelOffset + offsetX;\n    item.x = center.x + (inRight ? 1 : -1) * (radius + totalOffset);\n    item.y = inflectionPoint.y;\n  });\n\n  const { start, end } = coordinate;\n  const LEFT_HALF_KEY = 'left';\n  const RIGHT_HALF_KEY = 'right';\n  // step 1: separate labels\n  const separateLabels = groupBy(items, (item) => (item.x < center.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY));\n\n  // step2: calculate totalHeight\n  let totalHeight = (radius + labelOffset) * 2 + labelHeight;\n\n  each(separateLabels, (half: PolarLabelItem[]) => {\n    const halfHeight = half.length * labelHeight;\n    if (halfHeight > totalHeight) {\n      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));\n    }\n  });\n\n  /** labels 容器的范围(后续根据组件的布局设计进行调整) */\n  const labelsContainerRange = {\n    minX: start.x,\n    maxX: end.x,\n    minY: center.y - totalHeight / 2,\n    maxY: center.y + totalHeight / 2,\n  };\n\n  // step 3: antiCollision\n  each(separateLabels, (half, key) => {\n    const maxLabelsCountForOneSide = totalHeight / labelHeight;\n    if (half.length > maxLabelsCountForOneSide) {\n      half.sort((a, b) => {\n        // sort by percentage DESC\n        return b.percent - a.percent;\n      });\n\n      each(half, (labelItem: PolarLabelItem, idx) => {\n        if (idx > maxLabelsCountForOneSide) {\n          labelsMap[labelItem.id].set('visible', false);\n          labelItem.invisible = true;\n        }\n      });\n    }\n    antiCollision(half, labelHeight, labelsContainerRange);\n  });\n\n  const startY = labelsContainerRange.minY;\n  const endY = labelsContainerRange.maxY;\n\n  // step4: applyTo labels and adjust labelLines\n  each(separateLabels, (half, key) => {\n    const inRight = key === RIGHT_HALF_KEY;\n\n    each(half, (item) => {\n      const label: IGroup = get(labelsMap, item && [item.id]);\n      if (!label) {\n        return;\n      }\n      // out of range, hidden\n      if (item.y < startY || item.y > endY) {\n        label.set('visible', false);\n        return;\n      }\n\n      const labelContent = label.getChildByIndex(0);\n      const box = labelContent.getCanvasBBox();\n      const originalPos = { x: inRight ? box.x : box.maxX, y: box.y + box.height / 2 /** vertical-align: middle */ };\n\n      translate(labelContent as any, item.x - originalPos.x /** 从 pos.x 移动到 item.x */, item.y - originalPos.y);\n\n      // adjust labelLines\n      if (item.labelLine) {\n        drawLabelline(item, coordinate, inRight);\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}