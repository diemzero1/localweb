{"ast":null,"code":"import { isArray, isNil, isString } from '@antv/util';\n// todo 这个到底目的是什么？\nvar toScaleString = function (scale, value) {\n  if (isString(value)) {\n    return value;\n  }\n  return scale.invert(scale.scale(value));\n};\n/**\n * 所有视觉通道属性的基类\n * @class Base\n */\nvar Attribute = /** @class */function () {\n  function Attribute(cfg) {\n    this.names = [];\n    this.scales = [];\n    this.linear = false;\n    this.values = [];\n    this.callback = function () {\n      return [];\n    };\n    // 解析配置\n    this._parseCfg(cfg);\n  }\n  /**\n   * 映射的值组成的数组\n   * @param params 对应 scale 顺序的值传入\n   */\n  Attribute.prototype.mapping = function () {\n    var _this = this;\n    var params = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    }\n    var values = params.map(function (param, idx) {\n      return _this._toOriginParam(param, _this.scales[idx]);\n    });\n    return this.callback.apply(this, values);\n  };\n  /**\n   * 如果进行线性映射，返回对应的映射值\n   * @param percent\n   */\n  Attribute.prototype.getLinearValue = function (percent) {\n    // 分段数量\n    var steps = this.values.length - 1;\n    var step = Math.floor(steps * percent);\n    var leftPercent = steps * percent - step;\n    // todo 不懂这个逻辑\n    var start = this.values[step];\n    var end = step === steps ? start : this.values[step + 1];\n    // 线性方程\n    return start + (end - start) * leftPercent;\n  };\n  /**\n   * 根据度量获取属性名\n   */\n  Attribute.prototype.getNames = function () {\n    var scales = this.scales;\n    var names = this.names;\n    var length = Math.min(scales.length, names.length);\n    var rst = [];\n    for (var i = 0; i < length; i += 1) {\n      rst.push(names[i]);\n    }\n    return rst;\n  };\n  /**\n   * 获取所有的维度名\n   */\n  Attribute.prototype.getFields = function () {\n    return this.scales.map(function (scale) {\n      return scale.field;\n    });\n  };\n  /**\n   * 根据名称获取度量\n   * @param name\n   */\n  Attribute.prototype.getScale = function (name) {\n    return this.scales[this.names.indexOf(name)];\n  };\n  /**\n   * 默认的回调函数（用户没有自定义 callback，或者用户自定义 callback 返回空的时候，使用 values 映射）\n   * @param params\n   */\n  Attribute.prototype.defaultCallback = function () {\n    var _this = this;\n    var params = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      params[_i] = arguments[_i];\n    }\n    // 没有 params 的情况，是指没有指定 fields，直接返回配置的 values 常量\n    if (params.length === 0) {\n      return this.values;\n    }\n    return params.map(function (param, idx) {\n      var scale = _this.scales[idx];\n      return scale.type === 'identity' ? scale.values[0] : _this._getAttributeValue(scale, param);\n    });\n  };\n  // 解析配置\n  Attribute.prototype._parseCfg = function (cfg) {\n    var _this = this;\n    var _a = cfg.type,\n      type = _a === void 0 ? 'base' : _a,\n      _b = cfg.names,\n      names = _b === void 0 ? [] : _b,\n      _c = cfg.scales,\n      scales = _c === void 0 ? [] : _c,\n      _d = cfg.values,\n      values = _d === void 0 ? [] : _d,\n      callback = cfg.callback;\n    this.type = type;\n    this.scales = scales;\n    this.values = values;\n    this.names = names;\n    // 构造 callback 方法\n    this.callback = function () {\n      var params = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        params[_i] = arguments[_i];\n      }\n      /**\n       * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值\n       */\n      if (callback) {\n        // 使用用户返回的值处理\n        var ret = callback.apply(void 0, params);\n        if (!isNil(ret)) {\n          return [ret];\n        }\n      }\n      // 没有 callback 或者用户 callback 返回值为空，则使用默认的逻辑处理\n      return _this.defaultCallback.apply(_this, params);\n    };\n  };\n  // 获取属性值，将值映射到视觉通道\n  Attribute.prototype._getAttributeValue = function (scale, value) {\n    // 如果是非线性的字段，直接从 values 中取值即可\n    if (scale.isCategory && !this.linear) {\n      // 离散 scale 变换成索引\n      var idx = scale.translate(value);\n      return this.values[idx % this.values.length];\n    }\n    // 线性则使用线性值\n    var percent = scale.scale(value);\n    return this.getLinearValue(percent);\n  };\n  /**\n   * 通过 scale 拿到数据对应的原始的参数\n   * @param param\n   * @param scale\n   * @private\n   */\n  Attribute.prototype._toOriginParam = function (param, scale) {\n    // 是线性，直接返回\n    // 非线性，使用 scale 变换\n    return !scale.isLinear ? isArray(param) ? param.map(function (p) {\n      return toScaleString(scale, p);\n    }) : toScaleString(scale, param) : param;\n  };\n  return Attribute;\n}();\nexport default Attribute;","map":{"version":3,"mappings":"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","names":["isArray","isNil","isString","toScaleString","scale","value","invert","cfg","_parseCfg","Attribute","_i","params","values","map","param","idx","_this","_toOriginParam","scales","callback","apply","percent","steps","length","step","Math","floor","leftPercent","start","end","names","min","rst","i","push","field","name","indexOf","type","_getAttributeValue","_b","_c","_d","ret","defaultCallback","isCategory","linear","translate","getLinearValue","isLinear","p"],"sources":["/home/iam/Documents/network/node_modules/@antv/attr/src/attributes/base.ts"],"sourcesContent":["import { each, identity, isArray, isNil, isString, mix } from '@antv/util';\nimport { AttributeCfg, CallbackType, Scale } from '../interface';\n\n// todo 这个到底目的是什么？\nconst toScaleString = (scale: Scale, value: any): any => {\n  if (isString(value)) {\n    return value;\n  }\n  return scale.invert(scale.scale(value));\n};\n\nexport type AttributeConstructor = new (cfg: any) => Attribute;\n\n/**\n * 所有视觉通道属性的基类\n * @class Base\n */\nexport default class Attribute {\n  public type: string;\n  public names: string[] = [];\n  public scales: Scale[] = [];\n  public linear: boolean = false;\n\n  public values: any[] = [];\n\n  constructor(cfg: AttributeCfg) {\n    // 解析配置\n    this._parseCfg(cfg);\n  }\n  public callback: CallbackType = () => [];\n\n  /**\n   * 映射的值组成的数组\n   * @param params 对应 scale 顺序的值传入\n   */\n  public mapping(...params: any[]): any[] {\n    const values = params.map((param, idx) => {\n      return this._toOriginParam(param, this.scales[idx]);\n    });\n\n    return this.callback.apply(this, values);\n  }\n\n  /**\n   * 如果进行线性映射，返回对应的映射值\n   * @param percent\n   */\n  public getLinearValue(percent: number): number | string {\n    // 分段数量\n    const steps = this.values.length - 1;\n\n    const step = Math.floor(steps * percent);\n    const leftPercent = steps * percent - step;\n\n    // todo 不懂这个逻辑\n    const start = this.values[step];\n    const end = step === steps ? start : this.values[step + 1];\n\n    // 线性方程\n    return start + (end - start) * leftPercent;\n  }\n\n  /**\n   * 根据度量获取属性名\n   */\n  public getNames() {\n    const scales = this.scales;\n    const names = this.names;\n\n    const length = Math.min(scales.length, names.length);\n    const rst = [];\n    for (let i = 0; i < length; i += 1) {\n      rst.push(names[i]);\n    }\n    return rst;\n  }\n\n  /**\n   * 获取所有的维度名\n   */\n  public getFields() {\n    return this.scales.map((scale) => scale.field);\n  }\n\n  /**\n   * 根据名称获取度量\n   * @param name\n   */\n  public getScale(name: string) {\n    return this.scales[this.names.indexOf(name)];\n  }\n\n  /**\n   * 默认的回调函数（用户没有自定义 callback，或者用户自定义 callback 返回空的时候，使用 values 映射）\n   * @param params\n   */\n  private defaultCallback(...params: any[]): any[] {\n    // 没有 params 的情况，是指没有指定 fields，直接返回配置的 values 常量\n    if (params.length === 0) {\n      return this.values;\n    }\n\n    return params.map((param, idx) => {\n      const scale = this.scales[idx];\n\n      return scale.type === 'identity' ? scale.values[0] : this._getAttributeValue(scale, param);\n    });\n  }\n\n  // 解析配置\n  private _parseCfg(cfg: AttributeCfg) {\n    const { type = 'base', names = [], scales = [], values = [], callback } = cfg;\n\n    this.type = type;\n\n    this.scales = scales;\n    this.values = values;\n    this.names = names;\n\n    // 构造 callback 方法\n    this.callback = (...params: any[]): any[] => {\n      /**\n       * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值\n       */\n      if (callback) {\n        // 使用用户返回的值处理\n        const ret = callback(...params);\n        if (!isNil(ret)) {\n          return [ret];\n        }\n      }\n\n      // 没有 callback 或者用户 callback 返回值为空，则使用默认的逻辑处理\n      return this.defaultCallback.apply(this, params);\n    };\n  }\n\n  // 获取属性值，将值映射到视觉通道\n  private _getAttributeValue(scale: Scale, value: any) {\n    // 如果是非线性的字段，直接从 values 中取值即可\n    if (scale.isCategory && !this.linear) {\n      // 离散 scale 变换成索引\n      const idx = scale.translate(value) as number;\n      return this.values[idx % this.values.length];\n    }\n\n    // 线性则使用线性值\n    const percent = scale.scale(value);\n    return this.getLinearValue(percent);\n  }\n\n  /**\n   * 通过 scale 拿到数据对应的原始的参数\n   * @param param\n   * @param scale\n   * @private\n   */\n  private _toOriginParam(param: any, scale: Scale) {\n    // 是线性，直接返回\n    // 非线性，使用 scale 变换\n    return !scale.isLinear\n      ? isArray(param)\n        ? param.map((p: any) => toScaleString(scale, p))\n        : toScaleString(scale, param)\n      : param;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}