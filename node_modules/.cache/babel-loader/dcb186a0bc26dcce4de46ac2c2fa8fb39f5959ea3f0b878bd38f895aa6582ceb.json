{"ast":null,"code":"import { registerShape, Util } from '@antv/g2';\nimport { clamp } from '@antv/util';\n/**\n * 自定义 Shape 部分: 自定义米轨仪表盘\n * 定义 STEP, STEP_RATIO. 可绘制区域: 1 / (STEP + 1) * i -> 1 / (STEP + 1) * i + (STEP_RATIO / (STEP + 1))\n */\nregisterShape('interval', 'meter-gauge', {\n  draw: function draw(cfg, container) {\n    // 使用 customInfo 传递参数\n    var _a = cfg.customInfo.meter,\n      meter = _a === void 0 ? {} : _a;\n    var _b = meter.steps,\n      STEP = _b === void 0 ? 50 : _b,\n      _c = meter.stepRatio,\n      STEP_RATIO = _c === void 0 ? 0.5 : _c;\n    STEP = STEP < 1 ? 1 : STEP;\n    // stepRatio 取值范围: (0, 1]\n    STEP_RATIO = clamp(STEP_RATIO, 0, 1);\n    var _d = this.coordinate,\n      COORD_START_ANGLE = _d.startAngle,\n      COORD_END_ANGLE = _d.endAngle;\n    var GAP = 0;\n    if (STEP_RATIO > 0 && STEP_RATIO < 1) {\n      var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;\n      GAP = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);\n    }\n    var INTERVAL = GAP / (1 - STEP_RATIO) * STEP_RATIO;\n    var group = container.addGroup();\n    // 绘制图形的时候，留下 gap\n    var center = this.coordinate.getCenter();\n    var radius = this.coordinate.getRadius();\n    var _e = Util.getAngle(cfg, this.coordinate),\n      START_ANGLE = _e.startAngle,\n      END_ANGLE = _e.endAngle;\n    for (var startAngle = START_ANGLE; startAngle < END_ANGLE;) {\n      var endAngle = void 0;\n      var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP);\n      if (r < INTERVAL) {\n        endAngle = startAngle + (INTERVAL - r);\n      } else {\n        startAngle += INTERVAL + GAP - r;\n        endAngle = startAngle + INTERVAL;\n      }\n      var path = Util.getSectorPath(center.x, center.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);\n      group.addShape('path', {\n        name: 'meter-gauge',\n        attrs: {\n          path: path,\n          fill: cfg.color,\n          stroke: cfg.color,\n          lineWidth: 0.5\n        }\n      });\n      startAngle = endAngle + GAP;\n    }\n    return group;\n  }\n});","map":{"version":3,"mappings":"AAAA,SAASA,aAAa,EAASC,IAAI,QAAQ,UAAU;AACrD,SAASC,KAAK,QAAQ,YAAY;AAOlC;;;;AAIAF,aAAa,CAAC,UAAU,EAAE,aAAa,EAAE;EACvCG,IAAI,EAAJ,cAAKC,GAAa,EAAEC,SAAS;IAC3B;IACQ,SAAeD,GAAG,CAACE,UAAU,MAAnB;MAAVC,KAAK,mBAAG,EAAE;IACZ,SAAkDA,KAAK,MAAvC;MAATC,IAAI,mBAAG,EAAE;MAAEC,KAAgCF,KAAK,UAAV;MAAhBG,UAAU,mBAAG,GAAG;IACnDF,IAAI,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,GAAGA,IAAI;IAC1B;IACAE,UAAU,GAAGR,KAAK,CAACQ,UAAU,EAAE,CAAC,EAAE,CAAC,CAAC;IAE9B,SAA+D,IAAI,CAACC,UAAU;MAAhEC,iBAAiB;MAAYC,eAAe,cAAoB;IACpF,IAAIC,GAAG,GAAG,CAAC;IACX,IAAIJ,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,CAAC,EAAE;MACpC,IAAMK,KAAK,GAAGF,eAAe,GAAGD,iBAAiB;MACjDE,GAAG,GAAGC,KAAK,GAAGP,IAAI,IAAIE,UAAU,IAAI,CAAC,GAAGA,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,GAAGF,IAAI,CAAC;;IAErE,IAAMQ,QAAQ,GAAIF,GAAG,IAAI,CAAC,GAAGJ,UAAU,CAAC,GAAIA,UAAU;IAEtD,IAAMO,KAAK,GAAGZ,SAAS,CAACa,QAAQ,EAAE;IAClC;IACA,IAAMC,MAAM,GAAG,IAAI,CAACR,UAAU,CAACS,SAAS,EAAE;IAC1C,IAAMC,MAAM,GAAG,IAAI,CAACV,UAAU,CAACW,SAAS,EAAE;IACpC,SAAmDrB,IAAI,CAACsB,QAAQ,CAACnB,GAAG,EAAE,IAAI,CAACO,UAAU,CAAC;MAAxEa,WAAW;MAAYC,SAAS,cAAwC;IAE5F,KAAK,IAAIC,UAAU,GAAGF,WAAW,EAAEE,UAAU,GAAGD,SAAS,GAAI;MAC3D,IAAIE,QAAQ;MACZ,IAAMC,CAAC,GAAG,CAACF,UAAU,GAAGd,iBAAiB,KAAKI,QAAQ,GAAGF,GAAG,CAAC;MAC7D,IAAIc,CAAC,GAAGZ,QAAQ,EAAE;QAChBW,QAAQ,GAAGD,UAAU,IAAIV,QAAQ,GAAGY,CAAC,CAAC;OACvC,MAAM;QACLF,UAAU,IAAIV,QAAQ,GAAGF,GAAG,GAAGc,CAAC;QAChCD,QAAQ,GAAGD,UAAU,GAAGV,QAAQ;;MAElC,IAAMa,IAAI,GAAG5B,IAAI,CAAC6B,aAAa,CAC7BX,MAAM,CAACY,CAAC,EACRZ,MAAM,CAACa,CAAC,EACRX,MAAM,EACNK,UAAU,EACVO,IAAI,CAACC,GAAG,CAACP,QAAQ,EAAEF,SAAS,CAAC,EAC7BJ,MAAM,GAAG,IAAI,CAACV,UAAU,CAACwB,WAAW,CACrC;MACDlB,KAAK,CAACmB,QAAQ,CAAC,MAAM,EAAE;QACrBC,IAAI,EAAE,aAAa;QACnBC,KAAK,EAAE;UACLT,IAAI;UACJU,IAAI,EAAEnC,GAAG,CAACoC,KAAK;UACfC,MAAM,EAAErC,GAAG,CAACoC,KAAK;UACjBE,SAAS,EAAE;;OAEd,CAAC;MACFhB,UAAU,GAAGC,QAAQ,GAAGb,GAAG;;IAG7B,OAAOG,KAAK;EACd;CACD,CAAC","names":["registerShape","Util","clamp","draw","cfg","container","customInfo","meter","STEP","_c","STEP_RATIO","coordinate","COORD_START_ANGLE","COORD_END_ANGLE","GAP","TOTAL","INTERVAL","group","addGroup","center","getCenter","radius","getRadius","getAngle","START_ANGLE","END_ANGLE","startAngle","endAngle","r","path","getSectorPath","x","y","Math","min","innerRadius","addShape","name","attrs","fill","color","stroke","lineWidth"],"sources":["/home/iam/Documents/network/node_modules/@antv/g2plot/src/plots/gauge/shapes/meter-gauge.ts"],"sourcesContent":["import { registerShape, Types, Util } from '@antv/g2';\nimport { clamp } from '@antv/util';\nimport { GaugeCustomInfo } from '../types';\n\ntype ShapeCfg = Omit<Types.ShapeInfo, 'customInfo'> & {\n  customInfo: GaugeCustomInfo;\n};\n\n/**\n * 自定义 Shape 部分: 自定义米轨仪表盘\n * 定义 STEP, STEP_RATIO. 可绘制区域: 1 / (STEP + 1) * i -> 1 / (STEP + 1) * i + (STEP_RATIO / (STEP + 1))\n */\nregisterShape('interval', 'meter-gauge', {\n  draw(cfg: ShapeCfg, container) {\n    // 使用 customInfo 传递参数\n    const { meter = {} } = cfg.customInfo;\n    let { steps: STEP = 50, stepRatio: STEP_RATIO = 0.5 } = meter;\n    STEP = STEP < 1 ? 1 : STEP;\n    // stepRatio 取值范围: (0, 1]\n    STEP_RATIO = clamp(STEP_RATIO, 0, 1);\n\n    const { startAngle: COORD_START_ANGLE, endAngle: COORD_END_ANGLE } = this.coordinate;\n    let GAP = 0;\n    if (STEP_RATIO > 0 && STEP_RATIO < 1) {\n      const TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;\n      GAP = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);\n    }\n    const INTERVAL = (GAP / (1 - STEP_RATIO)) * STEP_RATIO;\n\n    const group = container.addGroup();\n    // 绘制图形的时候，留下 gap\n    const center = this.coordinate.getCenter();\n    const radius = this.coordinate.getRadius();\n    const { startAngle: START_ANGLE, endAngle: END_ANGLE } = Util.getAngle(cfg, this.coordinate);\n\n    for (let startAngle = START_ANGLE; startAngle < END_ANGLE; ) {\n      let endAngle;\n      const r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP);\n      if (r < INTERVAL) {\n        endAngle = startAngle + (INTERVAL - r);\n      } else {\n        startAngle += INTERVAL + GAP - r;\n        endAngle = startAngle + INTERVAL;\n      }\n      const path = Util.getSectorPath(\n        center.x,\n        center.y,\n        radius,\n        startAngle,\n        Math.min(endAngle, END_ANGLE),\n        radius * this.coordinate.innerRadius\n      );\n      group.addShape('path', {\n        name: 'meter-gauge',\n        attrs: {\n          path,\n          fill: cfg.color,\n          stroke: cfg.color,\n          lineWidth: 0.5,\n        },\n      });\n      startAngle = endAngle + GAP;\n    }\n\n    return group;\n  },\n});\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}