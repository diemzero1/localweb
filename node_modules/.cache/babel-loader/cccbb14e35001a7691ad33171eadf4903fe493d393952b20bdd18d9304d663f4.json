{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar init_order_1 = __importDefault(require(\"./init-order\"));\nvar cross_count_1 = __importDefault(require(\"./cross-count\"));\nvar build_layer_graph_1 = __importDefault(require(\"./build-layer-graph\"));\nvar add_subgraph_constraints_1 = __importDefault(require(\"./add-subgraph-constraints\"));\nvar sort_subgraph_1 = __importDefault(require(\"./sort-subgraph\"));\nvar util_1 = require(\"../../../../util\");\nvar graph_1 = require(\"../../graph\");\nvar util_2 = require(\"../util\");\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nvar order = function order(g) {\n  var mxRank = (0, util_2.maxRank)(g);\n  var range1 = [];\n  var range2 = [];\n  for (var i = 1; i < mxRank + 1; i++) {\n    range1.push(i);\n  }\n  for (var i = mxRank - 1; i > -1; i--) {\n    range2.push(i);\n  }\n  var downLayerGraphs = buildLayerGraphs(g, range1, \"inEdges\");\n  var upLayerGraphs = buildLayerGraphs(g, range2, \"outEdges\");\n  var layering = (0, init_order_1.default)(g);\n  assignOrder(g, layering);\n  var bestCC = Number.POSITIVE_INFINITY;\n  var best;\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n    layering = (0, util_2.buildLayerMatrix)(g);\n    var cc = (0, cross_count_1.default)(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = (0, util_1.clone)(layering);\n      bestCC = cc;\n    }\n  }\n  // consider use previous result, maybe somewhat reduendant\n  layering = (0, init_order_1.default)(g);\n  assignOrder(g, layering);\n  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true);\n    layering = (0, util_2.buildLayerMatrix)(g);\n    var cc = (0, cross_count_1.default)(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = (0, util_1.clone)(layering);\n      bestCC = cc;\n    }\n  }\n  assignOrder(g, best);\n};\nvar buildLayerGraphs = function buildLayerGraphs(g, ranks, relationship) {\n  return ranks.map(function (rank) {\n    return (0, build_layer_graph_1.default)(g, rank, relationship);\n  });\n};\nvar sweepLayerGraphs = function sweepLayerGraphs(layerGraphs, biasRight, usePrev) {\n  var cg = new graph_1.Graph();\n  layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(function (lg) {\n    var _a;\n    var root = lg.graph().root;\n    var sorted = (0, sort_subgraph_1.default)(lg, root, cg, biasRight, usePrev);\n    for (var i = 0; i < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {\n      var lnode = lg.node(sorted.vs[i]);\n      if (lnode) {\n        lnode.order = i;\n      }\n    }\n    (0, add_subgraph_constraints_1.default)(lg, cg, sorted.vs);\n  });\n};\nvar assignOrder = function assignOrder(g, layering) {\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      g.node(v).order = i;\n    });\n  });\n};\nexports.default = order;","map":{"version":3,"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;AAeA,IAAMA,KAAK,GAAG,SAARA,KAAK,CAAIC,CAAQ;EACrB,IAAMC,MAAM,GAAG,kBAAO,EAACD,CAAC,CAAC;EACzB,IAAME,MAAM,GAAG,EAAE;EACjB,IAAMC,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,EAAE;IAAEF,MAAM,CAACG,IAAI,CAACD,CAAC,CAAC;EAAC;EACpD,KAAK,IAAIA,CAAC,GAAGH,MAAM,GAAG,CAAC,EAAEG,CAAC,GAAG,CAAC,CAAC,EAAEA,CAAC,EAAE;IAAED,MAAM,CAACE,IAAI,CAACD,CAAC,CAAC;EAAC;EACrD,IAAME,eAAe,GAAGC,gBAAgB,CAACP,CAAC,EAAEE,MAAM,EAAE,SAAS,CAAC;EAC9D,IAAMM,aAAa,GAAGD,gBAAgB,CAACP,CAAC,EAAEG,MAAM,EAAE,UAAU,CAAC;EAE7D,IAAIM,QAAQ,GAAG,wBAAS,EAACT,CAAC,CAAC;EAC3BU,WAAW,CAACV,CAAC,EAAES,QAAQ,CAAC;EAExB,IAAIE,MAAM,GAAGC,MAAM,CAACC,iBAAiB;EACrC,IAAIC,IAAgB;EACpB,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEW,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG,CAAC,EAAE,EAAEX,CAAC,EAAE,EAAEW,QAAQ,EAAE;IAC3DC,gBAAgB,CAACZ,CAAC,GAAG,CAAC,GAAGE,eAAe,GAAGE,aAAa,EAAEJ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAErEK,QAAQ,GAAG,2BAAgB,EAACT,CAAC,CAAC;IAC9B,IAAMiB,EAAE,GAAG,yBAAU,EAACjB,CAAC,EAAES,QAAQ,CAAC;IAClC,IAAIQ,EAAE,GAAGN,MAAM,EAAE;MACfI,QAAQ,GAAG,CAAC;MACZD,IAAI,GAAG,gBAAK,EAACL,QAAQ,CAAC;MACtBE,MAAM,GAAGM,EAAE;;;EAIf;EACAR,QAAQ,GAAG,wBAAS,EAACT,CAAC,CAAC;EACvBU,WAAW,CAACV,CAAC,EAAES,QAAQ,CAAC;EACxB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEW,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAG,CAAC,EAAE,EAAEX,CAAC,EAAE,EAAEW,QAAQ,EAAE;IAC3DC,gBAAgB,CAACZ,CAAC,GAAG,CAAC,GAAGE,eAAe,GAAGE,aAAa,EAAEJ,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;IAE3EK,QAAQ,GAAG,2BAAgB,EAACT,CAAC,CAAC;IAC9B,IAAMiB,EAAE,GAAG,yBAAU,EAACjB,CAAC,EAAES,QAAQ,CAAC;IAClC,IAAIQ,EAAE,GAAGN,MAAM,EAAE;MACfI,QAAQ,GAAG,CAAC;MACZD,IAAI,GAAG,gBAAK,EAACL,QAAQ,CAAC;MACtBE,MAAM,GAAGM,EAAE;;;EAGfP,WAAW,CAACV,CAAC,EAAEc,IAAK,CAAC;AACvB,CAAC;AAED,IAAMP,gBAAgB,GAAG,SAAnBA,gBAAgB,CACpBP,CAAQ,EACRkB,KAAe,EACfC,YAAoC;EAEpC,OAAOD,KAAK,CAACE,GAAG,CAAC,UAACC,IAAI;IACpB,OAAO,+BAAe,EAACrB,CAAC,EAAEqB,IAAI,EAAEF,YAAY,CAAC;EAC/C,CAAC,CAAC;AACJ,CAAC;AAED,IAAMH,gBAAgB,GAAG,SAAnBA,gBAAgB,CACpBM,WAAoB,EACpBC,SAAkB,EAClBC,OAAiB;EAEjB,IAAMC,EAAE,GAAG,IAAIC,aAAK,EAAE;EACtBJ,WAAW,aAAXA,WAAW,uBAAXA,WAAW,CAAEK,OAAO,CAAC,UAACC,EAAE;;IACtB,IAAMC,IAAI,GAAGD,EAAE,CAACE,KAAK,EAAE,CAACD,IAAc;IACtC,IAAME,MAAM,GAAG,2BAAY,EAACH,EAAE,EAAEC,IAAI,EAAEJ,EAAE,EAAEF,SAAS,EAAEC,OAAO,CAAC;IAC7D,KAAK,IAAIpB,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAG,YAAM,CAAC4B,EAAE,0CAAEC,MAAM,KAAI,CAAC,EAAE7B,CAAC,EAAE,EAAE;MAC/C,IAAM8B,KAAK,GAAGN,EAAE,CAACO,IAAI,CAACJ,MAAM,CAACC,EAAE,CAAC5B,CAAC,CAAC,CAAC;MACnC,IAAI8B,KAAK,EAAE;QACTA,KAAK,CAACnC,KAAK,GAAGK,CAAC;;;IAGnB,sCAAsB,EAACwB,EAAE,EAAEH,EAAE,EAAEM,MAAM,CAACC,EAAE,CAAC;EAC3C,CAAC,CAAC;AACJ,CAAC;AAED,IAAMtB,WAAW,GAAG,SAAdA,WAAW,CAAIV,CAAQ,EAAES,QAAoB;EACjDA,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEkB,OAAO,CAAC,UAACS,KAAK;IACtBA,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAET,OAAO,CAAC,UAACU,CAAS,EAAEjC,CAAS;MAClCJ,CAAC,CAACmC,IAAI,CAACE,CAAC,CAAE,CAACtC,KAAK,GAAGK,CAAC;IACtB,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC;AAEDkC,kBAAevC,KAAK","names":["order","g","mxRank","range1","range2","i","push","downLayerGraphs","buildLayerGraphs","upLayerGraphs","layering","assignOrder","bestCC","Number","POSITIVE_INFINITY","best","lastBest","sweepLayerGraphs","cc","ranks","relationship","map","rank","layerGraphs","biasRight","usePrev","cg","graph_1","forEach","lg","root","graph","sorted","vs","length","lnode","node","layer","v","exports"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/order/index.ts"],"sourcesContent":["import initOrder from \"./init-order\";\nimport crossCount from \"./cross-count\";\nimport buildLayerGraph from \"./build-layer-graph\";\nimport addSubgraphConstraints from \"./add-subgraph-constraints\";\nimport sortSubgraph from \"./sort-subgraph\";\nimport { clone } from \"../../../../util\";\nimport { Graph } from \"../../graph\";\nimport { buildLayerMatrix, maxRank } from \"../util\";\n\n/*\n * Applies heuristics to minimize edge crossings in the graph and sets the best\n * order solution as an order attribute on each node.\n *\n * Pre-conditions:\n *\n *    1. Graph must be DAG\n *    2. Graph nodes must be objects with a \"rank\" attribute\n *    3. Graph edges must have the \"weight\" attribute\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have an \"order\" attribute based on the results of the\n *       algorithm.\n */\nconst order = (g: Graph) => {\n  const mxRank = maxRank(g);\n  const range1 = [];\n  const range2 = [];\n  for (let i = 1; i < mxRank + 1; i++) range1.push(i);\n  for (let i = mxRank - 1; i > -1; i--) range2.push(i);\n  const downLayerGraphs = buildLayerGraphs(g, range1, \"inEdges\");\n  const upLayerGraphs = buildLayerGraphs(g, range2, \"outEdges\");\n\n  let layering = initOrder(g);\n  assignOrder(g, layering);\n\n  let bestCC = Number.POSITIVE_INFINITY;\n  let best: string[][];\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);\n\n    layering = buildLayerMatrix(g);\n    const cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = clone(layering);\n      bestCC = cc;\n    }\n  }\n\n  // consider use previous result, maybe somewhat reduendant\n  layering = initOrder(g);\n  assignOrder(g, layering);\n  for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {\n    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true);\n\n    layering = buildLayerMatrix(g);\n    const cc = crossCount(g, layering);\n    if (cc < bestCC) {\n      lastBest = 0;\n      best = clone(layering);\n      bestCC = cc;\n    }\n  }\n  assignOrder(g, best!);\n};\n\nconst buildLayerGraphs = (\n  g: Graph,\n  ranks: number[],\n  relationship: \"inEdges\" | \"outEdges\"\n) => {\n  return ranks.map((rank) => {\n    return buildLayerGraph(g, rank, relationship);\n  });\n};\n\nconst sweepLayerGraphs = (\n  layerGraphs: Graph[],\n  biasRight: boolean,\n  usePrev?: boolean\n) => {\n  const cg = new Graph();\n  layerGraphs?.forEach((lg) => {\n    const root = lg.graph().root as string;\n    const sorted = sortSubgraph(lg, root, cg, biasRight, usePrev);\n    for (let i = 0; i < sorted.vs?.length || 0; i++) {\n      const lnode = lg.node(sorted.vs[i]);\n      if (lnode) {\n        lnode.order = i;\n      }\n    }\n    addSubgraphConstraints(lg, cg, sorted.vs);\n  });\n};\n\nconst assignOrder = (g: Graph, layering: string[][]) => {\n  layering?.forEach((layer) => {\n    layer?.forEach((v: string, i: number) => {\n      g.node(v)!.order = i;\n    });\n  });\n};\n\nexport default order;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}