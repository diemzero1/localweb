{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nvar initOrder = function initOrder(g) {\n  var visited = {};\n  var simpleNodes = g.nodes().filter(function (v) {\n    var _a;\n    return !((_a = g.children(v)) === null || _a === void 0 ? void 0 : _a.length);\n  });\n  var nodeRanks = simpleNodes.map(function (v) {\n    return g.node(v).rank;\n  });\n  var maxRank = Math.max.apply(Math, nodeRanks);\n  var layers = [];\n  for (var i = 0; i < maxRank + 1; i++) {\n    layers.push([]);\n  }\n  var dfs = function dfs(v) {\n    var _a;\n    if (visited.hasOwnProperty(v)) return;\n    visited[v] = true;\n    var node = g.node(v);\n    if (!isNaN(node.rank)) {\n      layers[node.rank].push(v);\n    }\n    (_a = g.successors(v)) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      return dfs(child);\n    });\n  };\n  var orderedVs = simpleNodes.sort(function (a, b) {\n    return g.node(a).rank - g.node(b).rank;\n  });\n  // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });\n  // 有fixOrder的，直接排序好放进去\n  var beforeSort = orderedVs.filter(function (n) {\n    return g.node(n).fixorder !== undefined;\n  });\n  var fixOrderNodes = beforeSort.sort(function (a, b) {\n    return g.node(a).fixorder - g.node(b).fixorder;\n  });\n  fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function (n) {\n    if (!isNaN(g.node(n).rank)) {\n      layers[g.node(n).rank].push(n);\n    }\n    visited[n] = true;\n  });\n  orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs);\n  return layers;\n};\nexports.default = initOrder;","map":{"version":3,"mappings":";;;;;AAEA;;;;;;;;;;;AAWA,IAAMA,SAAS,GAAG,SAAZA,SAAS,CAAIC,CAAQ;EACzB,IAAMC,OAAO,GAA4B,EAAE;EAC3C,IAAMC,WAAW,GAAGF,CAAC,CAACG,KAAK,EAAE,CAACC,MAAM,CAAC,UAACC,CAAC;;IACrC,OAAO,EAAC,OAAC,CAACC,QAAQ,CAACD,CAAC,CAAC,0CAAEE,MAAM;EAC/B,CAAC,CAAC;EACF,IAAMC,SAAS,GAAGN,WAAW,CAACO,GAAG,CAAC,UAACJ,CAAC;IAAK,OAACL,CAAC,CAACU,IAAI,CAACL,CAAC,CAAE,CAACM,IAAe;EAA3B,CAA2B,CAAC;EACrE,IAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,OAARD,IAAI,EAAQL,SAAS,CAAC;EACtC,IAAMO,MAAM,GAAe,EAAE;EAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,OAAO,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAE;IACpCD,MAAM,CAACE,IAAI,CAAC,EAAE,CAAC;;EAGjB,IAAMC,GAAG,GAAG,SAANA,GAAG,CAAIb,CAAS;;IACpB,IAAIJ,OAAO,CAACkB,cAAc,CAACd,CAAC,CAAC,EAAE;IAC/BJ,OAAO,CAACI,CAAC,CAAC,GAAG,IAAI;IACjB,IAAMK,IAAI,GAAGV,CAAC,CAACU,IAAI,CAACL,CAAC,CAAE;IACvB,IAAI,CAACe,KAAK,CAACV,IAAI,CAACC,IAAc,CAAC,EAAE;MAC/BI,MAAM,CAACL,IAAI,CAACC,IAAc,CAAC,CAACM,IAAI,CAACZ,CAAC,CAAC;;IAErC,OAAC,CAACgB,UAAU,CAAChB,CAAC,CAAC,0CAAEiB,OAAO,CAAC,UAACC,KAAK;MAAK,UAAG,CAACA,KAAY,CAAC;IAAjB,CAAiB,CAAC;EACxD,CAAC;EAED,IAAMC,SAAS,GAAGtB,WAAW,CAACuB,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAK,OAAC3B,CAAC,CAACU,IAAI,CAACgB,CAAC,CAAE,CAACf,IAAe,GAAIX,CAAC,CAACU,IAAI,CAACiB,CAAC,CAAE,CAAChB,IAAe;EAAzD,CAAyD,CAAC;EACvG;EAEA;EACA,IAAMiB,UAAU,GAAGJ,SAAS,CAACpB,MAAM,CAAC,UAACyB,CAAC;IACpC,OAAO7B,CAAC,CAACU,IAAI,CAACmB,CAAC,CAAE,CAACC,QAAQ,KAAKC,SAAS;EAC1C,CAAC,CAAC;EACF,IAAMC,aAAa,GAAGJ,UAAU,CAACH,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;IAAK,OAAC3B,CAAC,CAACU,IAAI,CAACgB,CAAC,CAAE,CAACI,QAAmB,GAAI9B,CAAC,CAACU,IAAI,CAACiB,CAAC,CAAE,CAACG,QAAmB;EAAjE,CAAiE,CAAC;EAClHE,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEV,OAAO,CAAC,UAACO,CAAC;IACvB,IAAI,CAACT,KAAK,CAACpB,CAAC,CAACU,IAAI,CAACmB,CAAC,CAAE,CAAClB,IAAc,CAAC,EAAE;MACrCI,MAAM,CAACf,CAAC,CAACU,IAAI,CAACmB,CAAC,CAAE,CAAClB,IAAc,CAAC,CAACM,IAAI,CAACY,CAAC,CAAC;;IAE3C5B,OAAO,CAAC4B,CAAC,CAAC,GAAG,IAAI;EACnB,CAAC,CAAC;EAEFL,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEF,OAAO,CAACJ,GAAG,CAAC;EAEvB,OAAOH,MAAM;AACf,CAAC;AAEDkB,kBAAelC,SAAS","names":["initOrder","g","visited","simpleNodes","nodes","filter","v","children","length","nodeRanks","map","node","rank","maxRank","Math","max","layers","i","push","dfs","hasOwnProperty","isNaN","successors","forEach","child","orderedVs","sort","a","b","beforeSort","n","fixorder","undefined","fixOrderNodes","exports"],"sources":["/home/iam/Documents/network/node_modules/@antv/layout/src/layout/dagre/src/order/init-order.ts"],"sourcesContent":["import { Graph } from \"../../graph\";\n\n/*\n * Assigns an initial order value for each node by performing a DFS search\n * starting from nodes in the first rank. Nodes are assigned an order in their\n * rank as they are first visited.\n *\n * This approach comes from Gansner, et al., \"A Technique for Drawing Directed\n * Graphs.\"\n *\n * Returns a layering matrix with an array per layer and each layer sorted by\n * the order of its nodes.\n */\nconst initOrder = (g: Graph) => {\n  const visited: Record<string, boolean> = {};\n  const simpleNodes = g.nodes().filter((v) => {\n    return !g.children(v)?.length;\n  });\n  const nodeRanks = simpleNodes.map((v) => (g.node(v)!.rank as number));\n  const maxRank = Math.max(...nodeRanks);\n  const layers: string[][] = [];\n  for (let i = 0; i < maxRank + 1; i++) {\n    layers.push([]);\n  }\n\n  const dfs = (v: string) => {\n    if (visited.hasOwnProperty(v)) return;\n    visited[v] = true;\n    const node = g.node(v)!;\n    if (!isNaN(node.rank as number)) {\n      layers[node.rank as number].push(v);\n    }\n    g.successors(v)?.forEach((child) => dfs(child as any));\n  };\n\n  const orderedVs = simpleNodes.sort((a, b) => (g.node(a)!.rank as number) - (g.node(b)!.rank as number));\n  // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });\n\n  // 有fixOrder的，直接排序好放进去\n  const beforeSort = orderedVs.filter((n) => {\n    return g.node(n)!.fixorder !== undefined;\n  });\n  const fixOrderNodes = beforeSort.sort((a, b) => (g.node(a)!.fixorder as number) - (g.node(b)!.fixorder as number));\n  fixOrderNodes?.forEach((n) => {\n    if (!isNaN(g.node(n)!.rank as number)) {\n      layers[g.node(n)!.rank as number].push(n);\n    }\n    visited[n] = true;\n  });\n\n  orderedVs?.forEach(dfs);\n\n  return layers;\n};\n\nexport default initOrder;"]},"metadata":{},"sourceType":"script","externalDependencies":[]}