{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { each } from '@antv/util';\nimport GridBase from './base';\nvar Line = /** @class */function (_super) {\n  __extends(Line, _super);\n  function Line() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Line.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    return __assign(__assign({}, cfg), {\n      type: 'line'\n    });\n  };\n  Line.prototype.getGridPath = function (points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  };\n  return Line;\n}(GridBase);\nexport default Line;","map":{"version":3,"mappings":";AAAA,SAASA,IAAI,QAAQ,YAAY;AAEjC,OAAOC,QAAQ,MAAM,QAAQ;AAE7B;EAAmBC;EAAnB;;EAoBA;EAnBSC,4BAAa,GAApB;IACE,IAAMC,GAAG,GAAGC,iBAAMC,aAAa,WAAE;IACjC,6BACKF,GAAG;MACNG,IAAI,EAAE;IAAM;EAEhB,CAAC;EAESJ,0BAAW,GAArB,UAAsBK,MAAe;IACnC,IAAMC,IAAI,GAAG,EAAE;IACfT,IAAI,CAACQ,MAAM,EAAE,UAACE,KAAK,EAAEC,KAAK;MACxB,IAAIA,KAAK,KAAK,CAAC,EAAE;QACfF,IAAI,CAACG,IAAI,CAAC,CAAC,GAAG,EAAEF,KAAK,CAACG,CAAC,EAAEH,KAAK,CAACI,CAAC,CAAC,CAAC;OACnC,MAAM;QACLL,IAAI,CAACG,IAAI,CAAC,CAAC,GAAG,EAAEF,KAAK,CAACG,CAAC,EAAEH,KAAK,CAACI,CAAC,CAAC,CAAC;;IAEtC,CAAC,CAAC;IACF,OAAOL,IAAI;EACb,CAAC;EACH,WAAC;AAAD,CAAC,CApBkBR,QAAQ;AAsB3B,eAAeE,IAAI","names":["each","GridBase","__extends","Line","cfg","_super","getDefaultCfg","type","points","path","point","index","push","x","y"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/component/src/grid/line.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { Point } from '../types';\nimport GridBase from './base';\n\nclass Line extends GridBase {\n  public getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    return {\n      ...cfg,\n      type: 'line',\n    };\n  }\n\n  protected getGridPath(points: Point[]): any[] {\n    const path = [];\n    each(points, (point, index) => {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  }\n}\n\nexport default Line;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}