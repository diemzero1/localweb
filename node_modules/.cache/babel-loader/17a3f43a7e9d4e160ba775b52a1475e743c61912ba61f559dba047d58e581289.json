{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport Adjust from './adjust';\nvar Dodge = /** @class */function (_super) {\n  __extends(Dodge, _super);\n  function Dodge(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.cacheMap = {};\n    _this.adjustDataArray = [];\n    _this.mergeData = [];\n    var _a = cfg.marginRatio,\n      marginRatio = _a === void 0 ? MARGIN_RATIO : _a,\n      _b = cfg.dodgeRatio,\n      dodgeRatio = _b === void 0 ? DODGE_RATIO : _b,\n      dodgeBy = cfg.dodgeBy,\n      intervalPadding = cfg.intervalPadding,\n      dodgePadding = cfg.dodgePadding,\n      xDimensionLength = cfg.xDimensionLength,\n      groupNum = cfg.groupNum,\n      defaultSize = cfg.defaultSize,\n      maxColumnWidth = cfg.maxColumnWidth,\n      minColumnWidth = cfg.minColumnWidth,\n      columnWidthRatio = cfg.columnWidthRatio,\n      customOffset = cfg.customOffset;\n    _this.marginRatio = marginRatio;\n    _this.dodgeRatio = dodgeRatio;\n    _this.dodgeBy = dodgeBy;\n    _this.intervalPadding = intervalPadding;\n    _this.dodgePadding = dodgePadding;\n    _this.xDimensionLegenth = xDimensionLength;\n    _this.groupNum = groupNum;\n    _this.defaultSize = defaultSize;\n    _this.maxColumnWidth = maxColumnWidth;\n    _this.minColumnWidth = minColumnWidth;\n    _this.columnWidthRatio = columnWidthRatio;\n    _this.customOffset = customOffset;\n    return _this;\n  }\n  Dodge.prototype.process = function (groupDataArray) {\n    var groupedDataArray = _.clone(groupDataArray);\n    // 将数据数组展开一层\n    var mergeData = _.flatten(groupedDataArray);\n    var dodgeBy = this.dodgeBy;\n    // 如果指定了分组 dim 的字段\n    var adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n    this.cacheMap = {};\n    this.adjustDataArray = adjustDataArray;\n    this.mergeData = mergeData;\n    this.adjustData(adjustDataArray, mergeData);\n    this.adjustDataArray = [];\n    this.mergeData = [];\n    return groupedDataArray;\n  };\n  Dodge.prototype.adjustDim = function (dim, values, data, frameIndex) {\n    var _this = this;\n    var customOffset = this.customOffset;\n    var map = this.getDistribution(dim);\n    var groupData = this.groupData(data, dim); // 根据值分组\n    _.each(groupData, function (group, key) {\n      var range;\n      // xField 中只有一个值，不需要做 dodge\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1\n        };\n      } else {\n        // 如果有多个，则需要获取调整的范围\n        range = _this.getAdjustRange(dim, parseFloat(key), values);\n      }\n      _.each(group, function (d) {\n        var value = d[dim];\n        var valueArr = map[value];\n        var valIndex = valueArr.indexOf(frameIndex);\n        if (!_.isNil(customOffset)) {\n          var pre = range.pre,\n            next = range.next;\n          d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n        } else {\n          d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);\n        }\n      });\n    });\n    return [];\n  };\n  Dodge.prototype.getDodgeOffset = function (range, idx, len) {\n    var _a = this,\n      dodgeRatio = _a.dodgeRatio,\n      marginRatio = _a.marginRatio,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding;\n    var pre = range.pre,\n      next = range.next;\n    var tickLength = next - pre;\n    var position;\n    // 分多种输入情况\n    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n      // 仅配置intervalPadding\n      var offset = this.getIntervalOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n      // 仅配置dodgePadding\n      var offset = this.getDodgeOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(intervalPadding) && !_.isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {\n      // 同时配置intervalPadding和dodgePadding\n      var offset = this.getIntervalAndDodgeOffset(len, idx);\n      position = pre + offset;\n    } else {\n      // 默认情况\n      var width = tickLength * dodgeRatio / len;\n      var margin = marginRatio * width;\n      var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;\n      position = (pre + next) / 2 + offset;\n    }\n    return position;\n  };\n  Dodge.prototype.getIntervalOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      intervalPadding = _a.intervalPadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      dodgeRatio = _a.dodgeRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = !_.isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组内间隔\n    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDodgeOnlyOffset = function (len, idx) {\n    var _a = this,\n      defaultSize = _a.defaultSize,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum,\n      marginRatio = _a.marginRatio,\n      maxColumnWidth = _a.maxColumnWidth,\n      minColumnWidth = _a.minColumnWidth,\n      columnWidthRatio = _a.columnWidthRatio;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      var normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;\n    // 调整组间距\n    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getIntervalAndDodgeOffset = function (len, idx) {\n    var _a = this,\n      intervalPadding = _a.intervalPadding,\n      dodgePadding = _a.dodgePadding,\n      xDimensionLegenth = _a.xDimensionLegenth,\n      groupNum = _a.groupNum;\n    var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    var normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;\n    return offset;\n  };\n  Dodge.prototype.getDistribution = function (dim) {\n    var groupedDataArray = this.adjustDataArray;\n    var cacheMap = this.cacheMap;\n    var map = cacheMap[dim];\n    if (!map) {\n      map = {};\n      _.each(groupedDataArray, function (data, index) {\n        var values = _.valuesOfKey(data, dim);\n        if (!values.length) {\n          values.push(0);\n        }\n        _.each(values, function (val) {\n          if (!map[val]) {\n            map[val] = [];\n          }\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n    return map;\n  };\n  return Dodge;\n}(Adjust);\nexport default Dodge;","map":{"version":3,"mappings":"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","names":["_","DODGE_RATIO","MARGIN_RATIO","Adjust","__extends","cfg","_super","_this","marginRatio","_b","dodgeRatio","dodgeBy","intervalPadding","dodgePadding","xDimensionLength","groupNum","defaultSize","maxColumnWidth","minColumnWidth","columnWidthRatio","customOffset","xDimensionLegenth","Dodge","groupDataArray","groupedDataArray","clone","mergeData","flatten","adjustDataArray","group","cacheMap","adjustData","dim","values","data","frameIndex","map","getDistribution","groupData","each","key","range","length","pre","next","getAdjustRange","parseFloat","d","value","valueArr","valIndex","indexOf","isNil","isFunction","getDodgeOffset","idx","len","tickLength","position","offset","getIntervalOnlyOffset","getDodgeOnlyOffset","getIntervalAndDodgeOffset","width","margin","normalizedIntervalPadding","normalizedDodgePadding","geomWidth","normalizedMaxWidht","Math","min","normalizedMinWidht","max","index","valuesOfKey","push","val"],"sources":["/home/iam/Documents/network/node_modules/@antv/adjust/src/adjusts/dodge.ts"],"sourcesContent":["import * as _ from '@antv/util';\nimport { DODGE_RATIO, MARGIN_RATIO } from '../constant';\nimport { Data, DodgeCfg, Range } from '../interface';\nimport Adjust from './adjust';\n\nexport default class Dodge extends Adjust {\n  private cacheMap: { [key: string]: any } = {};\n  private adjustDataArray: Data[][] = [];\n  private mergeData: Data[] = [];\n\n  constructor(cfg: DodgeCfg) {\n    super(cfg);\n    const {\n      marginRatio = MARGIN_RATIO,\n      dodgeRatio = DODGE_RATIO,\n      dodgeBy,\n      intervalPadding,\n      dodgePadding,\n      xDimensionLength,\n      groupNum,\n      defaultSize,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n      customOffset\n    } = cfg;\n    this.marginRatio = marginRatio;\n    this.dodgeRatio = dodgeRatio;\n    this.dodgeBy = dodgeBy;\n    this.intervalPadding = intervalPadding;\n    this.dodgePadding = dodgePadding;\n    this.xDimensionLegenth = xDimensionLength;\n    this.groupNum = groupNum;\n    this.defaultSize = defaultSize;\n    this.maxColumnWidth = maxColumnWidth;\n    this.minColumnWidth = minColumnWidth;\n    this.columnWidthRatio = columnWidthRatio;\n    this.customOffset = customOffset;\n  }\n\n  public process(groupDataArray: Data[][]): Data[][] {\n    const groupedDataArray = _.clone(groupDataArray);\n    // 将数据数组展开一层\n    const mergeData = _.flatten(groupedDataArray);\n\n    const { dodgeBy } = this;\n\n    // 如果指定了分组 dim 的字段\n    const adjustDataArray = dodgeBy ? _.group(mergeData, dodgeBy) : groupedDataArray;\n\n    this.cacheMap = {};\n    this.adjustDataArray = adjustDataArray;\n    this.mergeData = mergeData;\n\n    this.adjustData(adjustDataArray, mergeData);\n\n    this.adjustDataArray = [];\n    this.mergeData = [];\n\n    return groupedDataArray;\n  }\n\n  protected adjustDim(dim: string, values: number[], data: Data[], frameIndex: number): any[] {\n    const { customOffset } = this;\n    const map = this.getDistribution(dim);\n    const groupData = this.groupData(data, dim); // 根据值分组\n    \n    _.each(groupData, (group, key) => {\n      let range: Range;\n\n      // xField 中只有一个值，不需要做 dodge\n      if (values.length === 1) {\n        range = {\n          pre: values[0] - 1,\n          next: values[0] + 1,\n        };\n      } else {\n        // 如果有多个，则需要获取调整的范围\n        range = this.getAdjustRange(dim, parseFloat(key), values);\n      }\n      _.each(group, (d) => {\n        const value = d[dim];\n        const valueArr = map[value];\n        const valIndex = valueArr.indexOf(frameIndex);\n        if (!_.isNil(customOffset)) {\n          const { pre, next } = range;\n          d[dim] = _.isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;\n        } else {\n          d[dim] = this.getDodgeOffset(range, valIndex, valueArr.length);\n        }\n      });\n    });\n    return [];\n  }\n\n  private getDodgeOffset(range: Range, idx: number, len: number): number {\n    const {\n      dodgeRatio,\n      marginRatio,\n      intervalPadding,\n      dodgePadding,\n    } = this;\n    const { pre, next } = range;\n\n    const tickLength = next - pre;\n    let position;\n    // 分多种输入情况\n    if (!_.isNil(intervalPadding) && _.isNil(dodgePadding) && intervalPadding >= 0) {\n      // 仅配置intervalPadding\n      const offset = this.getIntervalOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (!_.isNil(dodgePadding) && _.isNil(intervalPadding) && dodgePadding >= 0) {\n      // 仅配置dodgePadding\n      const offset = this.getDodgeOnlyOffset(len, idx);\n      position = pre + offset;\n    } else if (\n      !_.isNil(intervalPadding) &&\n      !_.isNil(dodgePadding) &&\n      intervalPadding >= 0 &&\n      dodgePadding >= 0\n    ) {\n      // 同时配置intervalPadding和dodgePadding\n      const offset = this.getIntervalAndDodgeOffset(len, idx);\n      position = pre + offset;\n    } else {\n      // 默认情况\n      const width = (tickLength * dodgeRatio) / len;\n      const margin = marginRatio * width;\n      const offset =\n      (1 / 2) * (tickLength - len * width - (len - 1) * margin) +\n      ((idx + 1) * width + idx * margin) -\n      (1 / 2) * width -\n      (1 / 2) * tickLength;\n      position = (pre + next) / 2 + offset;\n    }\n    return position;\n  }\n\n  private getIntervalOnlyOffset(len: number, idx: number): number {\n    const {\n      defaultSize,\n      intervalPadding,\n      xDimensionLegenth,\n      groupNum,\n      dodgeRatio,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n    } = this;\n    const normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    let normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);\n    let geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = (!_.isNil(columnWidthRatio)) ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      const normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      const normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n    // 调整组内间隔\n    normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getDodgeOnlyOffset(len: number, idx: number): number {\n    const {\n      defaultSize,\n      dodgePadding,\n      xDimensionLegenth,\n      groupNum,\n      marginRatio,\n      maxColumnWidth,\n      minColumnWidth,\n      columnWidthRatio,\n    } = this;\n    const normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    let normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);\n    let geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    // 根据columnWidthRatio/defaultSize/maxColumnWidth/minColumnWidth调整宽度\n    geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;\n    if (!_.isNil(maxColumnWidth)) {\n      const normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;\n      geomWidth = Math.min(geomWidth, normalizedMaxWidht);\n    }\n    if (!_.isNil(minColumnWidth)) {\n      const normalizedMinWidht = minColumnWidth / xDimensionLegenth;\n      geomWidth = Math.max(geomWidth, normalizedMinWidht);\n    }\n    geomWidth = defaultSize ? (defaultSize / xDimensionLegenth) : geomWidth;\n    // 调整组间距\n    normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getIntervalAndDodgeOffset(len: number, idx: number): number {\n    const {\n      intervalPadding,\n      dodgePadding,\n      xDimensionLegenth,\n      groupNum,\n    } = this;\n    const normalizedIntervalPadding = intervalPadding / xDimensionLegenth;\n    const normalizedDodgePadding = dodgePadding / xDimensionLegenth;\n    const geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;\n    const offset =\n      ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding +\n      (1 / 2) * normalizedIntervalPadding) * groupNum -\n      normalizedIntervalPadding / 2;\n    return offset;\n  }\n\n  private getDistribution(dim: string) {\n    const groupedDataArray = this.adjustDataArray;\n    const cacheMap = this.cacheMap;\n    let map = cacheMap[dim];\n\n    if (!map) {\n      map = {};\n      _.each(groupedDataArray, (data, index) => {\n        const values = _.valuesOfKey(data, dim) as number[];\n        if (!values.length) {\n          values.push(0);\n        }\n        _.each(values, (val: number) => {\n          if (!map[val]) {\n            map[val] = [];\n          }\n          map[val].push(index);\n        });\n      });\n      cacheMap[dim] = map;\n    }\n\n    return map;\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}