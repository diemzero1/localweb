{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { max, min } from '@antv/util';\nimport Element from './element';\nimport { isFunction, isObject, each, removeFromArray, upperFirst, isAllowCapture } from '../util/util';\nvar SHAPE_MAP = {};\nvar INDEX = '_INDEX';\n/**\n * 设置 canvas\n * @param {IElement} element 元素\n * @param {ICanvas}  canvas  画布\n */\nfunction setCanvas(element, canvas) {\n  element.set('canvas', canvas);\n  if (element.isGroup()) {\n    var children = element.get('children');\n    if (children.length) {\n      children.forEach(function (child) {\n        setCanvas(child, canvas);\n      });\n    }\n  }\n}\n/**\n * 设置 timeline\n * @param {IElement} element  元素\n * @param {Timeline} timeline 时间轴\n */\nfunction setTimeline(element, timeline) {\n  element.set('timeline', timeline);\n  if (element.isGroup()) {\n    var children = element.get('children');\n    if (children.length) {\n      children.forEach(function (child) {\n        setTimeline(child, timeline);\n      });\n    }\n  }\n}\nfunction contains(container, element) {\n  var children = container.getChildren();\n  return children.indexOf(element) >= 0;\n}\nfunction removeChild(container, element, destroy) {\n  if (destroy === void 0) {\n    destroy = true;\n  }\n  // 不再调用 element.remove() 方法，会出现循环调用\n  if (destroy) {\n    element.destroy();\n  } else {\n    element.set('parent', null);\n    element.set('canvas', null);\n  }\n  removeFromArray(container.getChildren(), element);\n}\nfunction getComparer(compare) {\n  return function (left, right) {\n    var result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\nvar Container = /** @class */function (_super) {\n  __extends(Container, _super);\n  function Container() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Container.prototype.isCanvas = function () {\n    return false;\n  };\n  // 根据子节点确定 BBox\n  Container.prototype.getBBox = function () {\n    // 所有的值可能在画布的可视区外\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var xArr = [];\n    var yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    var children = this.getChildren().filter(function (child) {\n      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);\n    });\n    if (children.length > 0) {\n      each(children, function (child) {\n        var box = child.getBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    var box = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return box;\n  };\n  // 获取画布的包围盒\n  Container.prototype.getCanvasBBox = function () {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var xArr = [];\n    var yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    var children = this.getChildren().filter(function (child) {\n      return child.get('visible') && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);\n    });\n    if (children.length > 0) {\n      each(children, function (child) {\n        var box = child.getCanvasBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    var box = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return box;\n  };\n  Container.prototype.getDefaultCfg = function () {\n    var cfg = _super.prototype.getDefaultCfg.call(this);\n    cfg['children'] = [];\n    return cfg;\n  };\n  Container.prototype.onAttrChange = function (name, value, originValue) {\n    _super.prototype.onAttrChange.call(this, name, value, originValue);\n    if (name === 'matrix') {\n      var totalMatrix = this.getTotalMatrix();\n      this._applyChildrenMarix(totalMatrix);\n    }\n  };\n  // 不但应用到自己身上还要应用于子元素\n  Container.prototype.applyMatrix = function (matrix) {\n    var preTotalMatrix = this.getTotalMatrix();\n    _super.prototype.applyMatrix.call(this, matrix);\n    var totalMatrix = this.getTotalMatrix();\n    // totalMatrix 没有发生变化时，这里仅考虑两者都为 null 时\n    // 不继续向下传递矩阵\n    if (totalMatrix === preTotalMatrix) {\n      return;\n    }\n    this._applyChildrenMarix(totalMatrix);\n  };\n  // 在子元素上设置矩阵\n  Container.prototype._applyChildrenMarix = function (totalMatrix) {\n    var children = this.getChildren();\n    each(children, function (child) {\n      child.applyMatrix(totalMatrix);\n    });\n  };\n  // 兼容老版本的接口\n  Container.prototype.addShape = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var type = args[0];\n    var cfg = args[1];\n    if (isObject(type)) {\n      cfg = type;\n    } else {\n      cfg['type'] = type;\n    }\n    var shapeType = SHAPE_MAP[cfg.type];\n    if (!shapeType) {\n      shapeType = upperFirst(cfg.type);\n      SHAPE_MAP[cfg.type] = shapeType;\n    }\n    var ShapeBase = this.getShapeBase();\n    var shape = new ShapeBase[shapeType](cfg);\n    this.add(shape);\n    return shape;\n  };\n  Container.prototype.addGroup = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var groupClass = args[0],\n      cfg = args[1];\n    var group;\n    if (isFunction(groupClass)) {\n      if (cfg) {\n        group = new groupClass(cfg);\n      } else {\n        group = new groupClass({\n          // canvas,\n          parent: this\n        });\n      }\n    } else {\n      var tmpCfg = groupClass || {};\n      var TmpGroupClass = this.getGroupBase();\n      group = new TmpGroupClass(tmpCfg);\n    }\n    this.add(group);\n    return group;\n  };\n  Container.prototype.getCanvas = function () {\n    var canvas;\n    if (this.isCanvas()) {\n      canvas = this;\n    } else {\n      canvas = this.get('canvas');\n    }\n    return canvas;\n  };\n  Container.prototype.getShape = function (x, y, ev) {\n    // 如果不支持拾取，则直接返回\n    if (!isAllowCapture(this)) {\n      return null;\n    }\n    var children = this.getChildren();\n    var shape;\n    // 如果容器是 group\n    if (!this.isCanvas()) {\n      var v = [x, y, 1];\n      // 将 x, y 转换成对应于 group 的局部坐标\n      v = this.invertFromMatrix(v);\n      if (!this.isClipped(v[0], v[1])) {\n        shape = this._findShape(children, v[0], v[1], ev);\n      }\n    } else {\n      shape = this._findShape(children, x, y, ev);\n    }\n    return shape;\n  };\n  Container.prototype._findShape = function (children, x, y, ev) {\n    var shape = null;\n    for (var i = children.length - 1; i >= 0; i--) {\n      var child = children[i];\n      if (isAllowCapture(child)) {\n        if (child.isGroup()) {\n          shape = child.getShape(x, y, ev);\n        } else if (child.isHit(x, y)) {\n          shape = child;\n        }\n      }\n      if (shape) {\n        break;\n      }\n    }\n    return shape;\n  };\n  Container.prototype.add = function (element) {\n    var canvas = this.getCanvas();\n    var children = this.getChildren();\n    var timeline = this.get('timeline');\n    var preParent = element.getParent();\n    if (preParent) {\n      removeChild(preParent, element, false);\n    }\n    element.set('parent', this);\n    if (canvas) {\n      setCanvas(element, canvas);\n    }\n    if (timeline) {\n      setTimeline(element, timeline);\n    }\n    children.push(element);\n    element.onCanvasChange('add');\n    this._applyElementMatrix(element);\n  };\n  // 将当前容器的矩阵应用到子元素\n  Container.prototype._applyElementMatrix = function (element) {\n    var totalMatrix = this.getTotalMatrix();\n    // 添加图形或者分组时，需要把当前图元的矩阵设置进去\n    if (totalMatrix) {\n      element.applyMatrix(totalMatrix);\n    }\n  };\n  Container.prototype.getChildren = function () {\n    return this.get('children');\n  };\n  Container.prototype.sort = function () {\n    var children = this.getChildren();\n    // 稳定排序\n    each(children, function (child, index) {\n      child[INDEX] = index;\n      return child;\n    });\n    children.sort(getComparer(function (obj1, obj2) {\n      return obj1.get('zIndex') - obj2.get('zIndex');\n    }));\n    this.onCanvasChange('sort');\n  };\n  Container.prototype.clear = function () {\n    this.set('clearing', true);\n    if (this.destroyed) {\n      return;\n    }\n    var children = this.getChildren();\n    for (var i = children.length - 1; i >= 0; i--) {\n      children[i].destroy(); // 销毁子元素\n    }\n\n    this.set('children', []);\n    this.onCanvasChange('clear');\n    this.set('clearing', false);\n  };\n  Container.prototype.destroy = function () {\n    if (this.get('destroyed')) {\n      return;\n    }\n    this.clear();\n    _super.prototype.destroy.call(this);\n  };\n  /**\n   * 获取第一个子元素\n   * @return {IElement} 第一个元素\n   */\n  Container.prototype.getFirst = function () {\n    return this.getChildByIndex(0);\n  };\n  /**\n   * 获取最后一个子元素\n   * @return {IElement} 元素\n   */\n  Container.prototype.getLast = function () {\n    var children = this.getChildren();\n    return this.getChildByIndex(children.length - 1);\n  };\n  /**\n   * 根据索引获取子元素\n   * @return {IElement} 第一个元素\n   */\n  Container.prototype.getChildByIndex = function (index) {\n    var children = this.getChildren();\n    return children[index];\n  };\n  /**\n   * 子元素的数量\n   * @return {number} 子元素数量\n   */\n  Container.prototype.getCount = function () {\n    var children = this.getChildren();\n    return children.length;\n  };\n  /**\n   * 是否包含对应元素\n   * @param {IElement} element 元素\n   * @return {boolean}\n   */\n  Container.prototype.contain = function (element) {\n    var children = this.getChildren();\n    return children.indexOf(element) > -1;\n  };\n  /**\n   * 移除对应子元素\n   * @param {IElement} element 子元素\n   * @param {boolean} destroy 是否销毁子元素，默认为 true\n   */\n  Container.prototype.removeChild = function (element, destroy) {\n    if (destroy === void 0) {\n      destroy = true;\n    }\n    if (this.contain(element)) {\n      element.remove(destroy);\n    }\n  };\n  /**\n   * 查找所有匹配的元素\n   * @param  {ElementFilterFn}   fn  匹配函数\n   * @return {IElement[]} 元素数组\n   */\n  Container.prototype.findAll = function (fn) {\n    var rst = [];\n    var children = this.getChildren();\n    each(children, function (element) {\n      if (fn(element)) {\n        rst.push(element);\n      }\n      if (element.isGroup()) {\n        rst = rst.concat(element.findAll(fn));\n      }\n    });\n    return rst;\n  };\n  /**\n   * 查找元素，找到第一个返回\n   * @param  {ElementFilterFn} fn    匹配函数\n   * @return {IElement|null} 元素，可以为空\n   */\n  Container.prototype.find = function (fn) {\n    var rst = null;\n    var children = this.getChildren();\n    each(children, function (element) {\n      if (fn(element)) {\n        rst = element;\n      } else if (element.isGroup()) {\n        rst = element.find(fn);\n      }\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  };\n  /**\n   * 根据 ID 查找元素\n   * @param {string} id 元素 id\n   * @return {IElement|null} 元素\n   */\n  Container.prototype.findById = function (id) {\n    return this.find(function (element) {\n      return element.get('id') === id;\n    });\n  };\n  /**\n   * 该方法即将废弃，不建议使用\n   * 根据 className 查找元素\n   * TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\n   * @param {string} className 元素 className\n   * @return {IElement | null} 元素\n   */\n  Container.prototype.findByClassName = function (className) {\n    return this.find(function (element) {\n      return element.get('className') === className;\n    });\n  };\n  /**\n   * 根据 name 查找元素列表\n   * @param {string}      name 元素名称\n   * @return {IElement[]} 元素\n   */\n  Container.prototype.findAllByName = function (name) {\n    return this.findAll(function (element) {\n      return element.get('name') === name;\n    });\n  };\n  return Container;\n}(Element);\nexport default Container;","map":{"version":3,"mappings":"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","names":["max","min","Element","isFunction","isObject","each","removeFromArray","upperFirst","isAllowCapture","SHAPE_MAP","INDEX","setCanvas","element","canvas","set","isGroup","children","get","length","forEach","child","setTimeline","timeline","contains","container","getChildren","indexOf","removeChild","destroy","getComparer","compare","left","right","result","__extends","Container","minX","Infinity","maxX","minY","maxY","xArr","yArr","filter","box","getBBox","push","x","y","width","height","getCanvasBBox","cfg","_super","getDefaultCfg","name","value","originValue","onAttrChange","totalMatrix","getTotalMatrix","_applyChildrenMarix","matrix","preTotalMatrix","applyMatrix","_i","args","type","shapeType","ShapeBase","getShapeBase","shape","add","group","groupClass","parent","tmpCfg","TmpGroupClass","getGroupBase","isCanvas","ev","v","invertFromMatrix","isClipped","_findShape","i","getShape","isHit","getCanvas","preParent","getParent","onCanvasChange","_applyElementMatrix","index","sort","obj1","obj2","destroyed","clear","getChildByIndex","contain","remove","fn","rst","concat","findAll","find","id","className"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g-base/src/abstract/container.ts"],"sourcesContent":["import { max, min } from '@antv/util';\nimport { IContainer, IShape, IGroup, IElement, ICanvas } from '../interfaces';\nimport { BBox, ElementFilterFn } from '../types';\nimport Timeline from '../animate/timeline';\nimport Element from './element';\nimport { isFunction, isObject, each, removeFromArray, upperFirst, isAllowCapture } from '../util/util';\n\nconst SHAPE_MAP = {};\nconst INDEX = '_INDEX';\n\n/**\n * 设置 canvas\n * @param {IElement} element 元素\n * @param {ICanvas}  canvas  画布\n */\nfunction setCanvas(element: IElement, canvas: ICanvas) {\n  element.set('canvas', canvas);\n  if (element.isGroup()) {\n    const children = element.get('children');\n    if (children.length) {\n      children.forEach((child) => {\n        setCanvas(child, canvas);\n      });\n    }\n  }\n}\n\n/**\n * 设置 timeline\n * @param {IElement} element  元素\n * @param {Timeline} timeline 时间轴\n */\nfunction setTimeline(element: IElement, timeline: Timeline) {\n  element.set('timeline', timeline);\n  if (element.isGroup()) {\n    const children = element.get('children');\n    if (children.length) {\n      children.forEach((child) => {\n        setTimeline(child, timeline);\n      });\n    }\n  }\n}\n\nfunction contains(container: IContainer, element: IElement): boolean {\n  const children = container.getChildren();\n  return children.indexOf(element) >= 0;\n}\n\nfunction removeChild(container: IContainer, element: IElement, destroy: boolean = true) {\n  // 不再调用 element.remove() 方法，会出现循环调用\n  if (destroy) {\n    element.destroy();\n  } else {\n    element.set('parent', null);\n    element.set('canvas', null);\n  }\n  removeFromArray(container.getChildren(), element);\n}\n\nfunction getComparer(compare: Function) {\n  return function (left, right) {\n    const result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\n\nabstract class Container extends Element implements IContainer {\n  isCanvas() {\n    return false;\n  }\n\n  // 根据子节点确定 BBox\n  getBBox(): BBox {\n    // 所有的值可能在画布的可视区外\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    const xArr = [];\n    const yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    const children = this.getChildren().filter(\n      (child) =>\n        child.get('visible') && (!child.isGroup() || (child.isGroup() && (child as IGroup).getChildren().length > 0))\n    );\n    if (children.length > 0) {\n      each(children, (child: IElement) => {\n        const box = child.getBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    const box = {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    return box;\n  }\n\n  // 获取画布的包围盒\n  getCanvasBBox(): BBox {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    const xArr = [];\n    const yArr = [];\n    // 将可见元素、图形以及不为空的图形分组筛选出来，用于包围盒合并\n    const children = this.getChildren().filter(\n      (child) =>\n        child.get('visible') && (!child.isGroup() || (child.isGroup() && (child as IGroup).getChildren().length > 0))\n    );\n    if (children.length > 0) {\n      each(children, (child: IElement) => {\n        const box = child.getCanvasBBox();\n        xArr.push(box.minX, box.maxX);\n        yArr.push(box.minY, box.maxY);\n      });\n      minX = min(xArr);\n      maxX = max(xArr);\n      minY = min(yArr);\n      maxY = max(yArr);\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n    const box = {\n      x: minX,\n      y: minY,\n      minX,\n      minY,\n      maxX,\n      maxY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n    return box;\n  }\n\n  getDefaultCfg() {\n    const cfg = super.getDefaultCfg();\n    cfg['children'] = [];\n    return cfg;\n  }\n\n  onAttrChange(name, value, originValue) {\n    super.onAttrChange(name, value, originValue);\n    if (name === 'matrix') {\n      const totalMatrix = this.getTotalMatrix();\n      this._applyChildrenMarix(totalMatrix);\n    }\n  }\n\n  // 不但应用到自己身上还要应用于子元素\n  applyMatrix(matrix: number[]) {\n    const preTotalMatrix = this.getTotalMatrix();\n    super.applyMatrix(matrix);\n    const totalMatrix = this.getTotalMatrix();\n    // totalMatrix 没有发生变化时，这里仅考虑两者都为 null 时\n    // 不继续向下传递矩阵\n    if (totalMatrix === preTotalMatrix) {\n      return;\n    }\n    this._applyChildrenMarix(totalMatrix);\n  }\n\n  // 在子元素上设置矩阵\n  _applyChildrenMarix(totalMatrix) {\n    const children = this.getChildren();\n    each(children, (child) => {\n      child.applyMatrix(totalMatrix);\n    });\n  }\n\n  // 兼容老版本的接口\n  addShape(...args): IShape {\n    const type = args[0];\n    let cfg = args[1];\n    if (isObject(type)) {\n      cfg = type;\n    } else {\n      cfg['type'] = type;\n    }\n    let shapeType = SHAPE_MAP[cfg.type];\n    if (!shapeType) {\n      shapeType = upperFirst(cfg.type);\n      SHAPE_MAP[cfg.type] = shapeType;\n    }\n    const ShapeBase = this.getShapeBase();\n    const shape = new ShapeBase[shapeType](cfg);\n    this.add(shape);\n    return shape;\n  }\n\n  addGroup(...args): IGroup {\n    const [groupClass, cfg] = args;\n    let group;\n    if (isFunction(groupClass)) {\n      if (cfg) {\n        group = new groupClass(cfg);\n      } else {\n        group = new groupClass({\n          // canvas,\n          parent: this,\n        });\n      }\n    } else {\n      const tmpCfg = groupClass || {};\n      const TmpGroupClass = this.getGroupBase();\n      group = new TmpGroupClass(tmpCfg);\n    }\n    this.add(group);\n    return group;\n  }\n\n  getCanvas() {\n    let canvas;\n    if (this.isCanvas()) {\n      canvas = this;\n    } else {\n      canvas = this.get('canvas');\n    }\n    return canvas;\n  }\n\n  getShape(x: number, y: number, ev: Event): IShape {\n    // 如果不支持拾取，则直接返回\n    if (!isAllowCapture(this)) {\n      return null;\n    }\n    const children = this.getChildren();\n    let shape;\n    // 如果容器是 group\n    if (!this.isCanvas()) {\n      let v = [x, y, 1];\n      // 将 x, y 转换成对应于 group 的局部坐标\n      v = this.invertFromMatrix(v);\n      if (!this.isClipped(v[0], v[1])) {\n        shape = this._findShape(children, v[0], v[1], ev);\n      }\n    } else {\n      shape = this._findShape(children, x, y, ev);\n    }\n    return shape;\n  }\n\n  _findShape(children: IElement[], x: number, y: number, ev: Event) {\n    let shape = null;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const child = children[i];\n      if (isAllowCapture(child)) {\n        if (child.isGroup()) {\n          shape = (child as IGroup).getShape(x, y, ev);\n        } else if ((child as IShape).isHit(x, y)) {\n          shape = child;\n        }\n      }\n      if (shape) {\n        break;\n      }\n    }\n    return shape;\n  }\n\n  add(element: IElement) {\n    const canvas = this.getCanvas();\n    const children = this.getChildren();\n    const timeline = this.get('timeline');\n    const preParent = element.getParent();\n    if (preParent) {\n      removeChild(preParent, element, false);\n    }\n    element.set('parent', this);\n    if (canvas) {\n      setCanvas(element, canvas);\n    }\n    if (timeline) {\n      setTimeline(element, timeline);\n    }\n    children.push(element);\n    element.onCanvasChange('add');\n    this._applyElementMatrix(element);\n  }\n\n  // 将当前容器的矩阵应用到子元素\n  _applyElementMatrix(element) {\n    const totalMatrix = this.getTotalMatrix();\n    // 添加图形或者分组时，需要把当前图元的矩阵设置进去\n    if (totalMatrix) {\n      element.applyMatrix(totalMatrix);\n    }\n  }\n\n  getChildren(): IElement[] {\n    return this.get('children') as IElement[];\n  }\n\n  sort() {\n    const children = this.getChildren();\n    // 稳定排序\n    each(children, (child, index) => {\n      child[INDEX] = index;\n      return child;\n    });\n    children.sort(\n      getComparer((obj1, obj2) => {\n        return obj1.get('zIndex') - obj2.get('zIndex');\n      })\n    );\n    this.onCanvasChange('sort');\n  }\n\n  clear() {\n    this.set('clearing', true);\n    if (this.destroyed) {\n      return;\n    }\n    const children = this.getChildren();\n    for (let i = children.length - 1; i >= 0; i--) {\n      children[i].destroy(); // 销毁子元素\n    }\n    this.set('children', []);\n    this.onCanvasChange('clear');\n    this.set('clearing', false);\n  }\n\n  destroy() {\n    if (this.get('destroyed')) {\n      return;\n    }\n    this.clear();\n    super.destroy();\n  }\n\n  /**\n   * 获取第一个子元素\n   * @return {IElement} 第一个元素\n   */\n  getFirst(): IElement {\n    return this.getChildByIndex(0);\n  }\n\n  /**\n   * 获取最后一个子元素\n   * @return {IElement} 元素\n   */\n  getLast(): IElement {\n    const children = this.getChildren();\n    return this.getChildByIndex(children.length - 1);\n  }\n\n  /**\n   * 根据索引获取子元素\n   * @return {IElement} 第一个元素\n   */\n  getChildByIndex(index: number): IElement {\n    const children = this.getChildren();\n    return children[index];\n  }\n\n  /**\n   * 子元素的数量\n   * @return {number} 子元素数量\n   */\n  getCount(): number {\n    const children = this.getChildren();\n    return children.length;\n  }\n\n  /**\n   * 是否包含对应元素\n   * @param {IElement} element 元素\n   * @return {boolean}\n   */\n  contain(element: IElement): boolean {\n    const children = this.getChildren();\n    return children.indexOf(element) > -1;\n  }\n\n  /**\n   * 移除对应子元素\n   * @param {IElement} element 子元素\n   * @param {boolean} destroy 是否销毁子元素，默认为 true\n   */\n  removeChild(element: IElement, destroy = true) {\n    if (this.contain(element)) {\n      element.remove(destroy);\n    }\n  }\n\n  /**\n   * 查找所有匹配的元素\n   * @param  {ElementFilterFn}   fn  匹配函数\n   * @return {IElement[]} 元素数组\n   */\n  findAll(fn: ElementFilterFn): IElement[] {\n    let rst: IElement[] = [];\n    const children = this.getChildren();\n    each(children, (element: IElement) => {\n      if (fn(element)) {\n        rst.push(element);\n      }\n      if (element.isGroup()) {\n        rst = rst.concat((element as IGroup).findAll(fn));\n      }\n    });\n    return rst;\n  }\n\n  /**\n   * 查找元素，找到第一个返回\n   * @param  {ElementFilterFn} fn    匹配函数\n   * @return {IElement|null} 元素，可以为空\n   */\n  find(fn: ElementFilterFn): IElement {\n    let rst: IElement = null;\n    const children = this.getChildren();\n    each(children, (element: IElement) => {\n      if (fn(element)) {\n        rst = element;\n      } else if (element.isGroup()) {\n        rst = (element as IGroup).find(fn);\n      }\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  }\n\n  /**\n   * 根据 ID 查找元素\n   * @param {string} id 元素 id\n   * @return {IElement|null} 元素\n   */\n  findById(id: string): IElement {\n    return this.find((element) => {\n      return element.get('id') === id;\n    });\n  }\n\n  /**\n   * 该方法即将废弃，不建议使用\n   * 根据 className 查找元素\n   * TODO: 该方式定义暂时只给 G6 3.3 以后的版本使用，待 G6 中的 findByClassName 方法移除后，G 也需要同步移除\n   * @param {string} className 元素 className\n   * @return {IElement | null} 元素\n   */\n  findByClassName(className: string): IElement {\n    return this.find((element) => {\n      return element.get('className') === className;\n    });\n  }\n\n  /**\n   * 根据 name 查找元素列表\n   * @param {string}      name 元素名称\n   * @return {IElement[]} 元素\n   */\n  findAllByName(name: string): IElement[] {\n    return this.findAll((element) => {\n      return element.get('name') === name;\n    });\n  }\n}\n\nexport default Container;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}