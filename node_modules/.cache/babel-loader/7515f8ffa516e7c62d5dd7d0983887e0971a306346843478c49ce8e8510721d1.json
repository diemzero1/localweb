{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;\n/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\nvar graphlib_1 = require(\"@antv/graphlib\");\nvar util_1 = require(\"../util\");\nvar BlockGraph = /** @class */function (_super) {\n  __extends(BlockGraph, _super);\n  function BlockGraph() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return BlockGraph;\n}(graphlib_1.Graph);\nvar findType1Conflicts = function findType1Conflicts(g, layering) {\n  var conflicts = {};\n  var visitLayer = function visitLayer(prevLayer, layer) {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    var k0 = 0;\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    var scanPos = 0;\n    var prevLayerLength = prevLayer.length;\n    var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, i) {\n      var _a;\n      var w = (0, exports.findOtherInnerSegmentNode)(g, v);\n      var k1 = w ? g.node(w).order : prevLayerLength;\n      if (w || v === lastNode) {\n        (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach(function (scanNode) {\n          var _a;\n          (_a = g.predecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach(function (u) {\n            var _a;\n            var uLabel = g.node(u);\n            var uPos = uLabel.order;\n            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && ((_a = g.node(scanNode)) === null || _a === void 0 ? void 0 : _a.dummy))) {\n              (0, exports.addConflict)(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n    return layer;\n  };\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\nexports.findType1Conflicts = findType1Conflicts;\nvar findType2Conflicts = function findType2Conflicts(g, layering) {\n  var conflicts = {};\n  var scan = function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {\n    var v;\n    var range = [];\n    for (var i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n    range.forEach(function (i) {\n      var _a, _b;\n      v = south[i];\n      if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n        (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach(function (u) {\n          var uNode = g.node(u);\n          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {\n            (0, exports.addConflict)(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n  var visitLayer = function visitLayer(north, south) {\n    var prevNorthPos = -1;\n    var nextNorthPos;\n    var southPos = 0;\n    south === null || south === void 0 ? void 0 : south.forEach(function (v, southLookahead) {\n      var _a;\n      if (((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) === \"border\") {\n        var predecessors = g.predecessors(v) || [];\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]).order;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n    return south;\n  };\n  if (layering === null || layering === void 0 ? void 0 : layering.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\nexports.findType2Conflicts = findType2Conflicts;\nvar findOtherInnerSegmentNode = function findOtherInnerSegmentNode(g, v) {\n  var _a, _b;\n  if ((_a = g.node(v)) === null || _a === void 0 ? void 0 : _a.dummy) {\n    return (_b = g.predecessors(v)) === null || _b === void 0 ? void 0 : _b.find(function (u) {\n      return g.node(u).dummy;\n    });\n  }\n};\nexports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;\nvar addConflict = function addConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n  if (vv > ww) {\n    var tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n  var conflictsV = conflicts[vv];\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n  conflictsV[ww] = true;\n};\nexports.addConflict = addConflict;\nvar hasConflict = function hasConflict(conflicts, v, w) {\n  var vv = v;\n  var ww = w;\n  if (vv > ww) {\n    var tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n  return !!conflicts[vv];\n};\nexports.hasConflict = hasConflict;\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nvar verticalAlignment = function verticalAlignment(g, layering, conflicts, neighborFn) {\n  var root = {};\n  var align = {};\n  var pos = {};\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v, order) {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var prevIdx = -1;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var ws = neighborFn(v);\n      if (ws.length) {\n        ws = ws.sort(function (a, b) {\n          return pos[a] - pos[b];\n        });\n        var mp = (ws.length - 1) / 2;\n        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          var w = ws[i];\n          if (align[v] === v && prevIdx < pos[w] && !(0, exports.hasConflict)(conflicts, v, w)) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n  return {\n    root: root,\n    align: align\n  };\n};\nexports.verticalAlignment = verticalAlignment;\nvar horizontalCompaction = function horizontalCompaction(g, layering, root, align, reverseSep) {\n  var _a;\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  var xs = {};\n  var blockG = (0, exports.buildBlockGraph)(g, layering, root, reverseSep);\n  var borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n  var iterate = function iterate(setXsFunc, nextNodesFunc) {\n    var stack = blockG.nodes();\n    var elem = stack.pop();\n    var visited = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n      elem = stack.pop();\n    }\n  };\n  // First pass, assign smallest coordinates\n  var pass1 = function pass1(elem) {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce(function (acc, e) {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e));\n    }, 0);\n  };\n  // Second pass, assign greatest coordinates\n  var pass2 = function pass2(elem) {\n    var min = (blockG.outEdges(elem) || []).reduce(function (acc, e) {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e));\n    }, Number.POSITIVE_INFINITY);\n    var node = g.node(elem);\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n  // Assign x coordinates to all nodes\n  (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n    xs[v] = xs[root[v]];\n  });\n  return xs;\n};\nexports.horizontalCompaction = horizontalCompaction;\nvar buildBlockGraph = function buildBlockGraph(g, layering, root, reverseSep) {\n  var blockGraph = new BlockGraph();\n  var graphLabel = g.graph();\n  var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);\n  layering === null || layering === void 0 ? void 0 : layering.forEach(function (layer) {\n    var u;\n    layer === null || layer === void 0 ? void 0 : layer.forEach(function (v) {\n      var vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        var uRoot = root[u];\n        var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);\n        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));\n      }\n      u = v;\n    });\n  });\n  return blockGraph;\n};\nexports.buildBlockGraph = buildBlockGraph;\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nvar findSmallestWidthAlignment = function findSmallestWidthAlignment(g, xss) {\n  return (0, util_1.minBy)(Object.values(xss), function (xs) {\n    var _a;\n    var max = Number.NEGATIVE_INFINITY;\n    var min = Number.POSITIVE_INFINITY;\n    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach(function (v) {\n      var x = xs[v];\n      var halfWidth = (0, exports.width)(g, v) / 2;\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n    return max - min;\n  });\n};\nexports.findSmallestWidthAlignment = findSmallestWidthAlignment;\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nfunction alignCoordinates(xss, alignTo) {\n  // @ts-ignore\n  var alignToVals = Object.values(alignTo);\n  var alignToMin = Math.min.apply(Math, alignToVals);\n  var alignToMax = Math.max.apply(Math, alignToVals);\n  [\"u\", \"d\"].forEach(function (vert) {\n    [\"l\", \"r\"].forEach(function (horiz) {\n      var alignment = vert + horiz;\n      var xs = xss[alignment];\n      var delta;\n      if (xs === alignTo) return;\n      var xsVals = Object.values(xs);\n      delta = horiz === \"l\" ? alignToMin - Math.min.apply(Math, xsVals) : alignToMax - Math.max.apply(Math, xsVals);\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach(function (key) {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\nexports.alignCoordinates = alignCoordinates;\nvar balance = function balance(xss, align) {\n  var result = {};\n  Object.keys(xss.ul).forEach(function (key) {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      var values = Object.values(xss).map(function (x) {\n        return x[key];\n      });\n      result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2\n    }\n  });\n\n  return result;\n};\nexports.balance = balance;\nvar positionX = function positionX(g) {\n  var layering = (0, util_1.buildLayerMatrix)(g);\n  var conflicts = Object.assign((0, exports.findType1Conflicts)(g, layering), (0, exports.findType2Conflicts)(g, layering));\n  var xss = {};\n  var adjustedLayering;\n  [\"u\", \"d\"].forEach(function (vert) {\n    adjustedLayering = vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach(function (horiz) {\n      if (horiz === \"r\") {\n        adjustedLayering = adjustedLayering.map(function (inner) {\n          return Object.values(inner).reverse();\n        });\n      }\n      var neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      var align = (0, exports.verticalAlignment)(g, adjustedLayering, conflicts, neighborFn);\n      var xs = (0, exports.horizontalCompaction)(g, adjustedLayering, align.root, align.align, horiz === \"r\");\n      if (horiz === \"r\") {\n        Object.keys(xs).forEach(function (key) {\n          xs[key] = -xs[key];\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n  var smallestWidth = (0, exports.findSmallestWidthAlignment)(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return (0, exports.balance)(xss, g.graph().align);\n};\nexports.positionX = positionX;\nvar sep = function sep(nodeSep, edgeSep, reverseSep) {\n  return function (g, v, w) {\n    var vLabel = g.node(v);\n    var wLabel = g.node(w);\n    var sum = 0;\n    var delta;\n    sum += vLabel.width / 2;\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width / 2;\n          break;\n        case \"r\":\n          delta = vLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += wLabel.width / 2;\n    if (wLabel.labelpos) {\n      switch ((wLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width / 2;\n          break;\n        case \"r\":\n          delta = -wLabel.width / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n    return sum;\n  };\n};\nexports.sep = sep;\nvar width = function width(g, v) {\n  return g.node(v).width || 0;\n};\nexports.width = width;","map":{"version":3,"mappings":"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","names":["__extends","graphlib_1","findType1Conflicts","g","layering","conflicts","visitLayer","prevLayer","layer","k0","scanPos","prevLayerLength","length","lastNode","forEach","v","i","w","k1","node","order","slice","scanNode","predecessors","u","uLabel","uPos","dummy","reduce","exports","findType2Conflicts","scan","south","southPos","southEnd","prevNorthBorder","nextNorthBorder","range","push","uNode","north","prevNorthPos","nextNorthPos","southLookahead","findOtherInnerSegmentNode","find","addConflict","vv","ww","tmp","conflictsV","hasConflict","verticalAlignment","neighborFn","root","align","pos","prevIdx","ws","sort","a","b","mp","Math","floor","il","ceil","horizontalCompaction","reverseSep","xs","blockG","borderType","iterate","setXsFunc","nextNodesFunc","stack","nodes","elem","pop","visited","concat","pass1","inEdges","acc","e","max","edge","pass2","min","outEdges","Number","POSITIVE_INFINITY","bind","successors","values","buildBlockGraph","blockGraph","BlockGraph","graphLabel","graph","sepFn","nodesep","edgesep","vRoot","setNode","uRoot","prevMax","edgeFromArgs","setEdge","findSmallestWidthAlignment","xss","Object","NEGATIVE_INFINITY","keys","x","halfWidth","alignCoordinates","alignTo","alignToVals","alignToMin","alignToMax","vert","horiz","alignment","delta","xsVals","key","balance","result","ul","toLowerCase","map","positionX","assign","adjustedLayering","reverse","inner","smallestWidth","sep","nodeSep","edgeSep","vLabel","wLabel","sum","width","hasOwnProperty","labelpos"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/layout/dagre/src/position/bk.ts"],"sourcesContent":["/*\n * This module provides coordinate assignment based on Brandes and Köpf, \"Fast\n * and Simple Horizontal Coordinate Assignment.\"\n */\nimport { Graph as RawGraph } from \"@antv/graphlib\";\nimport { Graph } from \"../../graph\";\nimport { buildLayerMatrix, minBy } from \"../util\";\n\nclass BlockGraph extends RawGraph<string, string, number> {}\n\n/*\n * Marks all edges in the graph with a type-1 conflict with the \"type1Conflict\"\n * property. A type-1 conflict is one where a non-inner segment crosses an\n * inner segment. An inner segment is an edge with both incident nodes marked\n * with the \"dummy\" property.\n *\n * This algorithm scans layer by layer, starting with the second, for type-1\n * conflicts between the current layer and the previous layer. For each layer\n * it scans the nodes from left to right until it reaches one that is incident\n * on an inner segment. It then scans predecessors to determine if they have\n * edges that cross that inner segment. At the end a final scan is done for all\n * nodes on the current rank to see if they cross the last visited inner\n * segment.\n *\n * This algorithm (safely) assumes that a dummy node will only be incident on a\n * single node in the layers being scanned.\n */\n\ntype Conflicts = Record<string, Record<string, boolean>>;\n\nexport const findType1Conflicts = (g: Graph, layering?: string[][]) => {\n  const conflicts = {};\n\n  const visitLayer = (prevLayer: string[], layer: string[]) => {\n    // last visited node in the previous layer that is incident on an inner\n    // segment.\n    let k0 = 0;\n    // Tracks the last node in this layer scanned for crossings with a type-1\n    // segment.\n    let scanPos = 0;\n    const prevLayerLength = prevLayer.length;\n    const lastNode = layer?.[layer?.length - 1];\n\n    layer?.forEach((v: string, i: number) => {\n      const w = findOtherInnerSegmentNode(g, v);\n      const k1 = w ? g.node(w)!.order! : prevLayerLength;\n\n      if (w || v === lastNode) {\n        layer.slice(scanPos, i + 1)?.forEach((scanNode) => {\n          g.predecessors(scanNode)?.forEach((u) => {\n            const uLabel = g.node(u)!;\n            const uPos = uLabel.order as number;\n            if (\n              (uPos < k0 || k1 < uPos) &&\n              !(uLabel.dummy && g.node(scanNode)?.dummy)\n            ) {\n              addConflict(conflicts, u, scanNode);\n            }\n          });\n        });\n        scanPos = i + 1;\n        k0 = k1;\n      }\n    });\n\n    return layer;\n  };\n\n  if (layering?.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\n\nexport const findType2Conflicts = (g: Graph, layering?: string[][]) => {\n  const conflicts = {};\n\n  const scan = (\n    south: string[],\n    southPos: number,\n    southEnd: number,\n    prevNorthBorder: number,\n    nextNorthBorder: number\n  ) => {\n    let v: string;\n    const range = [];\n    for (let i = southPos; i < southEnd; i++) {\n      range.push(i);\n    }\n    range.forEach((i) => {\n      v = south[i];\n      if (g.node(v)?.dummy) {\n        g.predecessors(v)?.forEach((u) => {\n          const uNode = g.node(u)!;\n          if (\n            uNode.dummy &&\n            ((uNode.order as number) < prevNorthBorder ||\n              (uNode.order as number) > nextNorthBorder)\n          ) {\n            addConflict(conflicts, u, v);\n          }\n        });\n      }\n    });\n  };\n\n  const visitLayer = (north: string[], south: string[]) => {\n    let prevNorthPos = -1;\n    let nextNorthPos: number;\n    let southPos = 0;\n\n    south?.forEach((v: string, southLookahead: number) => {\n      if (g.node(v)?.dummy === \"border\") {\n        const predecessors = g.predecessors(v) || [];\n        if (predecessors.length) {\n          nextNorthPos = g.node(predecessors[0]!)!.order as number;\n          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);\n          southPos = southLookahead;\n          prevNorthPos = nextNorthPos;\n        }\n      }\n      scan(south, southPos, south.length, nextNorthPos, north.length);\n    });\n\n    return south;\n  };\n\n  if (layering?.length) {\n    layering.reduce(visitLayer);\n  }\n  return conflicts;\n};\n\nexport const findOtherInnerSegmentNode = (g: Graph, v: string) => {\n  if (g.node(v)?.dummy) {\n    return g.predecessors(v)?.find((u) => g.node(u)!.dummy);\n  }\n};\n\nexport const addConflict = (conflicts: Conflicts, v: string, w: string) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = vv;\n    vv = ww;\n    ww = tmp;\n  }\n\n  let conflictsV = conflicts[vv];\n  if (!conflictsV) {\n    conflicts[vv] = conflictsV = {};\n  }\n  conflictsV[ww] = true;\n};\n\nexport const hasConflict = (conflicts: Conflicts, v: string, w: string) => {\n  let vv = v;\n  let ww = w;\n  if (vv > ww) {\n    const tmp = v;\n    vv = ww;\n    ww = tmp;\n  }\n  return !!conflicts[vv];\n};\n\n/*\n * Try to align nodes into vertical \"blocks\" where possible. This algorithm\n * attempts to align a node with one of its median neighbors. If the edge\n * connecting a neighbor is a type-1 conflict then we ignore that possibility.\n * If a previous node has already formed a block with a node after the node\n * we're trying to form a block with, we also ignore that possibility - our\n * blocks would be split in that scenario.\n */\nexport const verticalAlignment = (\n  g: Graph,\n  layering: string[][],\n  conflicts: Conflicts,\n  neighborFn: (v: string) => string[]\n) => {\n  const root: Record<string, string> = {};\n  const align: Record<string, string> = {};\n  const pos: Record<string, number> = {};\n\n  // We cache the position here based on the layering because the graph and\n  // layering may be out of sync. The layering matrix is manipulated to\n  // generate different extreme alignments.\n  layering?.forEach((layer) => {\n    layer?.forEach((v, order: number) => {\n      root[v] = v;\n      align[v] = v;\n      pos[v] = order;\n    });\n  });\n\n  layering?.forEach((layer) => {\n    let prevIdx = -1;\n    layer?.forEach((v) => {\n      let ws = neighborFn(v);\n      if (ws.length) {\n        ws = ws.sort((a: string, b: string) => pos[a] - pos[b]);\n        const mp = (ws.length - 1) / 2;\n        for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {\n          const w = ws[i];\n          if (\n            align[v] === v &&\n            prevIdx < pos[w] &&\n            !hasConflict(conflicts, v, w)\n          ) {\n            align[w] = v;\n            align[v] = root[v] = root[w];\n            prevIdx = pos[w];\n          }\n        }\n      }\n    });\n  });\n\n  return { root, align };\n};\n\nexport const horizontalCompaction = (\n  g: Graph,\n  layering: string[][],\n  root: Record<string, string>,\n  align: Record<string, string>,\n  reverseSep?: boolean\n) => {\n  // This portion of the algorithm differs from BK due to a number of problems.\n  // Instead of their algorithm we construct a new block graph and do two\n  // sweeps. The first sweep places blocks with the smallest possible\n  // coordinates. The second sweep removes unused space by moving blocks to the\n  // greatest coordinates without violating separation.\n  const xs: Record<string, number> = {};\n  const blockG = buildBlockGraph(g, layering, root, reverseSep);\n  const borderType = reverseSep ? \"borderLeft\" : \"borderRight\";\n\n  const iterate = (\n    setXsFunc: (param: string) => void,\n    nextNodesFunc: (param: string) => string\n  ) => {\n    let stack = blockG.nodes();\n    let elem = stack.pop();\n    const visited: Record<string, boolean> = {};\n    while (elem) {\n      if (visited[elem]) {\n        setXsFunc(elem);\n      } else {\n        visited[elem] = true;\n        stack.push(elem);\n        stack = stack.concat(nextNodesFunc(elem));\n      }\n\n      elem = stack.pop();\n    }\n  };\n\n  // First pass, assign smallest coordinates\n  const pass1 = (elem: string) => {\n    xs[elem] = (blockG.inEdges(elem) || []).reduce((acc: number, e) => {\n      return Math.max(acc, (xs[e.v] || 0) + blockG.edge(e)!);\n    }, 0);\n  };\n\n  // Second pass, assign greatest coordinates\n  const pass2 = (elem: string) => {\n    const min = (blockG.outEdges(elem) || []).reduce((acc: number, e) => {\n      return Math.min(acc, (xs[e.w] || 0) - blockG.edge(e)!);\n    }, Number.POSITIVE_INFINITY);\n\n    const node = g.node(elem)!;\n    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {\n      xs[elem] = Math.max(xs[elem], min);\n    }\n  };\n\n  iterate(pass1, blockG.predecessors.bind(blockG));\n  iterate(pass2, blockG.successors.bind(blockG));\n\n  // Assign x coordinates to all nodes\n  Object.values(align)?.forEach((v) => {\n    xs[v] = xs[root[v]];\n  });\n\n  return xs;\n};\n\nexport const buildBlockGraph = (\n  g: Graph,\n  layering: string[][],\n  root: Record<string, string>,\n  reverseSep?: boolean\n) => {\n  const blockGraph = new BlockGraph();\n  const graphLabel = g.graph();\n  const sepFn = sep(\n    graphLabel.nodesep as number,\n    graphLabel.edgesep as number,\n    reverseSep as boolean\n  );\n\n  layering?.forEach((layer) => {\n    let u: string;\n    layer?.forEach((v) => {\n      const vRoot = root[v];\n      blockGraph.setNode(vRoot);\n      if (u) {\n        const uRoot = root[u];\n        const prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);\n        blockGraph.setEdge(\n          uRoot,\n          vRoot,\n          Math.max(sepFn(g, v, u), prevMax || 0)\n        );\n      }\n      u = v;\n    });\n  });\n\n  return blockGraph;\n};\n/*\n * Returns the alignment that has the smallest width of the given alignments.\n */\nexport const findSmallestWidthAlignment = (\n  g: Graph,\n  xss: Record<string, Record<string, number>>\n) => {\n  return minBy(Object.values(xss), (xs) => {\n    let max = Number.NEGATIVE_INFINITY;\n    let min = Number.POSITIVE_INFINITY;\n\n    Object.keys(xs)?.forEach((v: string) => {\n      const x = xs[v];\n      const halfWidth = width(g, v) / 2;\n\n      max = Math.max(x + halfWidth, max);\n      min = Math.min(x - halfWidth, min);\n    });\n\n    return max - min;\n  });\n};\n\n/*\n * Align the coordinates of each of the layout alignments such that\n * left-biased alignments have their minimum coordinate at the same point as\n * the minimum coordinate of the smallest width alignment and right-biased\n * alignments have their maximum coordinate at the same point as the maximum\n * coordinate of the smallest width alignment.\n */\nexport function alignCoordinates(\n  xss: Record<string, Record<string, number>>,\n  alignTo: Record<string, number>\n) {\n  // @ts-ignore\n  const alignToVals = Object.values(alignTo) as number[];\n  const alignToMin = Math.min(...alignToVals);\n  const alignToMax = Math.max(...alignToVals);\n\n  [\"u\", \"d\"].forEach((vert) => {\n    [\"l\", \"r\"].forEach((horiz) => {\n      const alignment = vert + horiz;\n      const xs = xss[alignment];\n      let delta: number;\n      if (xs === alignTo) return;\n\n      const xsVals = Object.values(xs) as number[];\n      delta =\n        horiz === \"l\"\n          ? alignToMin - Math.min(...xsVals)\n          : alignToMax - Math.max(...xsVals);\n\n      if (delta) {\n        xss[alignment] = {};\n        Object.keys(xs).forEach((key) => {\n          xss[alignment][key] = xs[key] + delta;\n        });\n      }\n    });\n  });\n}\n\nexport const balance = (\n  xss: Record<string, Record<string, number>>,\n  align?: string\n) => {\n  const result: Record<string, number> = {};\n  Object.keys(xss.ul).forEach((key) => {\n    if (align) {\n      result[key] = xss[align.toLowerCase()][key];\n    } else {\n      const values = Object.values(xss).map((x) => x[key]);\n      result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2\n    }\n  });\n  return result;\n};\n\nexport const positionX = (g: Graph) => {\n  const layering = buildLayerMatrix(g);\n  const conflicts = Object.assign(\n    findType1Conflicts(g, layering),\n    findType2Conflicts(g, layering)\n  );\n\n  const xss: Record<string, Record<string, number>> = {};\n  let adjustedLayering: string[][];\n  [\"u\", \"d\"].forEach((vert) => {\n    adjustedLayering =\n      vert === \"u\" ? layering : Object.values(layering).reverse();\n    [\"l\", \"r\"].forEach((horiz) => {\n      if (horiz === \"r\") {\n        adjustedLayering = adjustedLayering.map((inner) =>\n          Object.values(inner).reverse()\n        );\n      }\n\n      const neighborFn = (vert === \"u\" ? g.predecessors : g.successors).bind(g);\n      const align = verticalAlignment(\n        g,\n        adjustedLayering,\n        conflicts,\n        neighborFn\n      );\n      const xs = horizontalCompaction(\n        g,\n        adjustedLayering,\n        align.root,\n        align.align,\n        horiz === \"r\"\n      );\n      if (horiz === \"r\") {\n        Object.keys(xs).forEach((key) => {\n          xs[key] = -xs[key];\n        });\n      }\n      xss[vert + horiz] = xs;\n    });\n  });\n\n  const smallestWidth = findSmallestWidthAlignment(g, xss);\n  alignCoordinates(xss, smallestWidth);\n  return balance(xss, g.graph().align as string);\n};\n\nexport const sep = (nodeSep: number, edgeSep: number, reverseSep: boolean) => {\n  return (g: Graph, v: string, w: string) => {\n    const vLabel = g.node(v)!;\n    const wLabel = g.node(w)!;\n    let sum = 0;\n    let delta;\n\n    sum += vLabel.width! / 2;\n    if (vLabel.hasOwnProperty(\"labelpos\")) {\n      switch ((vLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = -vLabel.width! / 2;\n          break;\n        case \"r\":\n          delta = vLabel.width! / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;\n    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;\n\n    sum += wLabel.width! / 2;\n    if (wLabel.labelpos) {\n      switch ((wLabel.labelpos || \"\").toLowerCase()) {\n        case \"l\":\n          delta = wLabel.width! / 2;\n          break;\n        case \"r\":\n          delta = -wLabel.width! / 2;\n          break;\n      }\n    }\n    if (delta) {\n      sum += reverseSep ? delta : -delta;\n    }\n    delta = 0;\n\n    return sum;\n  };\n};\n\nexport const width = (g: Graph, v: string) => g.node(v)!.width || 0;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}