{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { ext, vec2, vec3 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport Coordinate from './base';\nvar Polar = /** @class */function (_super) {\n  __extends(Polar, _super);\n  function Polar(cfg) {\n    var _this = _super.call(this, cfg) || this;\n    _this.isPolar = true;\n    _this.type = 'polar';\n    var _a = cfg.startAngle,\n      startAngle = _a === void 0 ? -Math.PI / 2 : _a,\n      _b = cfg.endAngle,\n      endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b,\n      _c = cfg.innerRadius,\n      innerRadius = _c === void 0 ? 0 : _c,\n      radius = cfg.radius;\n    _this.startAngle = startAngle;\n    _this.endAngle = endAngle;\n    _this.innerRadius = innerRadius;\n    _this.radius = radius;\n    _this.initial();\n    return _this;\n  }\n  Polar.prototype.initial = function () {\n    _super.prototype.initial.call(this);\n    while (this.endAngle < this.startAngle) {\n      this.endAngle += Math.PI * 2;\n    }\n    var oneBox = this.getOneBox();\n    var oneWidth = oneBox.maxX - oneBox.minX;\n    var oneHeight = oneBox.maxY - oneBox.minY;\n    var left = Math.abs(oneBox.minX) / oneWidth;\n    var top = Math.abs(oneBox.minY) / oneHeight;\n    var maxRadius;\n    if (this.height / oneHeight > this.width / oneWidth) {\n      // width 为主\n      maxRadius = this.width / oneWidth;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * this.width,\n        y: this.center.y - (0.5 - top) * maxRadius * oneHeight\n      };\n    } else {\n      // height 为主\n      maxRadius = this.height / oneHeight;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * maxRadius * oneWidth,\n        y: this.center.y - (0.5 - top) * this.height\n      };\n    }\n    this.polarRadius = this.radius;\n    if (!this.radius) {\n      this.polarRadius = maxRadius;\n    } else if (this.radius > 0 && this.radius <= 1) {\n      this.polarRadius = maxRadius * this.radius;\n    } else if (this.radius <= 0 || this.radius > maxRadius) {\n      this.polarRadius = maxRadius;\n    }\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle\n    };\n    this.y = {\n      start: this.innerRadius * this.polarRadius,\n      end: this.polarRadius\n    };\n  };\n  Polar.prototype.getRadius = function () {\n    return this.polarRadius;\n  };\n  Polar.prototype.convertPoint = function (point) {\n    var _a;\n    var center = this.getCenter();\n    var x = point.x,\n      y = point.y;\n    if (this.isTransposed) {\n      _a = [y, x], x = _a[0], y = _a[1];\n    }\n    x = this.convertDim(x, 'x');\n    y = this.convertDim(y, 'y');\n    return {\n      x: center.x + Math.cos(x) * y,\n      y: center.y + Math.sin(x) * y\n    };\n  };\n  Polar.prototype.invertPoint = function (point) {\n    var _a;\n    var center = this.getCenter();\n    var vPoint = [point.x - center.x, point.y - center.y];\n    var _b = this,\n      startAngle = _b.startAngle,\n      endAngle = _b.endAngle;\n    if (this.isReflect('x')) {\n      _a = [endAngle, startAngle], startAngle = _a[0], endAngle = _a[1];\n    }\n    var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    ext.leftRotate(m, m, startAngle);\n    var vStart3 = [1, 0, 0];\n    vec3.transformMat3(vStart3, vStart3, m);\n    var vStart2 = [vStart3[0], vStart3[1]];\n    var angle = ext.angleTo(vStart2, vPoint, endAngle < startAngle);\n    if (isNumberEqual(angle, Math.PI * 2)) {\n      angle = 0;\n    }\n    var radius = vec2.length(vPoint);\n    var xPercent = angle / (endAngle - startAngle);\n    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;\n    var yPercent = this.invertDim(radius, 'y');\n    var rst = {\n      x: 0,\n      y: 0\n    };\n    rst.x = this.isTransposed ? yPercent : xPercent;\n    rst.y = this.isTransposed ? xPercent : yPercent;\n    return rst;\n  };\n  Polar.prototype.getCenter = function () {\n    return this.circleCenter;\n  };\n  Polar.prototype.getOneBox = function () {\n    var startAngle = this.startAngle;\n    var endAngle = this.endAngle;\n    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n      return {\n        minX: -1,\n        maxX: 1,\n        minY: -1,\n        maxY: 1\n      };\n    }\n    var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];\n    var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];\n    for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n      xs.push(Math.cos(i));\n      ys.push(Math.sin(i));\n    }\n    return {\n      minX: Math.min.apply(Math, xs),\n      maxX: Math.max.apply(Math, xs),\n      minY: Math.min.apply(Math, ys),\n      maxY: Math.max.apply(Math, ys)\n    };\n  };\n  return Polar;\n}(Coordinate);\nexport default Polar;","map":{"version":3,"mappings":"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","names":["ext","vec2","vec3","isNumberEqual","Coordinate","__extends","cfg","_super","_this","startAngle","Math","PI","_b","endAngle","_c","innerRadius","radius","initial","Polar","oneBox","getOneBox","oneWidth","maxX","minX","oneHeight","maxY","minY","left","abs","top","maxRadius","height","width","circleCenter","x","center","y","polarRadius","start","end","point","getCenter","isTransposed","_a","convertDim","cos","sin","vPoint","isReflect","m","leftRotate","vStart3","transformMat3","vStart2","angle","angleTo","length","xPercent","yPercent","invertDim","rst","xs","ys","i","min","max","push"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/coord/src/coord/polar.ts"],"sourcesContent":["import { ext, vec2, vec3 } from '@antv/matrix-util';\nimport { isNumberEqual } from '@antv/util';\nimport { Point, PolarCfg } from '../interface';\nimport Coordinate, { Matrix3, Vector2, Vector3 } from './base';\n\nexport default class Polar extends Coordinate {\n  public readonly isPolar: boolean = true;\n  public readonly type: string = 'polar';\n\n  public circleCenter: Point;\n\n  // 极坐标的半径值，区别于用户设置的归一化 radius\n  private polarRadius: number;\n\n  constructor(cfg: PolarCfg) {\n    super(cfg);\n\n    const { startAngle = -Math.PI / 2, endAngle = (Math.PI * 3) / 2, innerRadius = 0, radius } = cfg;\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n\n    this.initial();\n  }\n\n  public initial() {\n    super.initial();\n\n    while (this.endAngle < this.startAngle) {\n      this.endAngle += Math.PI * 2;\n    }\n\n    const oneBox = this.getOneBox();\n\n    const oneWidth = oneBox.maxX - oneBox.minX;\n    const oneHeight = oneBox.maxY - oneBox.minY;\n\n    const left = Math.abs(oneBox.minX) / oneWidth;\n    const top = Math.abs(oneBox.minY) / oneHeight;\n\n    let maxRadius: number;\n\n    if (this.height / oneHeight > this.width / oneWidth) {\n      // width 为主\n      maxRadius = this.width / oneWidth;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * this.width,\n        y: this.center.y - (0.5 - top) * maxRadius * oneHeight,\n      };\n    } else {\n      // height 为主\n      maxRadius = this.height / oneHeight;\n      this.circleCenter = {\n        x: this.center.x - (0.5 - left) * maxRadius * oneWidth,\n        y: this.center.y - (0.5 - top) * this.height,\n      };\n    }\n\n    this.polarRadius = this.radius;\n    if (!this.radius) {\n      this.polarRadius = maxRadius;\n    } else if (this.radius > 0 && this.radius <= 1) {\n      this.polarRadius = maxRadius * this.radius;\n    } else if (this.radius <= 0 || this.radius > maxRadius) {\n      this.polarRadius = maxRadius;\n    }\n\n    this.x = {\n      start: this.startAngle,\n      end: this.endAngle,\n    };\n\n    this.y = {\n      start: this.innerRadius * this.polarRadius,\n      end: this.polarRadius,\n    };\n  }\n\n  public getRadius() {\n    return this.polarRadius;\n  }\n\n  public convertPoint(point: Point): Point {\n    const center = this.getCenter();\n\n    let { x, y } = point;\n\n    if (this.isTransposed) {\n      [x, y] = [y, x];\n    }\n\n    x = this.convertDim(x, 'x');\n    y = this.convertDim(y, 'y');\n\n    return {\n      x: center.x + Math.cos(x) * y,\n      y: center.y + Math.sin(x) * y,\n    };\n  }\n\n  public invertPoint(point: Point): Point {\n    const center = this.getCenter();\n    const vPoint: Vector2 = [point.x - center.x, point.y - center.y];\n\n    let { startAngle, endAngle } = this;\n    if (this.isReflect('x')) {\n      [startAngle, endAngle] = [endAngle, startAngle];\n    }\n\n    const m: Matrix3 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    ext.leftRotate(m, m, startAngle);\n\n    const vStart3: Vector3 = [1, 0, 0];\n    vec3.transformMat3(vStart3, vStart3, m);\n    const vStart2: Vector2 = [vStart3[0], vStart3[1]];\n    let angle = ext.angleTo(vStart2, vPoint, endAngle < startAngle);\n    if (isNumberEqual(angle, Math.PI * 2)) {\n      angle = 0;\n    }\n    const radius = vec2.length(vPoint);\n\n    let xPercent = angle / (endAngle - startAngle);\n    xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;\n\n    const yPercent = this.invertDim(radius, 'y');\n    const rst = { x: 0, y: 0 };\n    rst.x = this.isTransposed ? yPercent : xPercent;\n    rst.y = this.isTransposed ? xPercent : yPercent;\n    return rst;\n  }\n\n  public getCenter() {\n    return this.circleCenter;\n  }\n\n  private getOneBox() {\n    const startAngle = this.startAngle;\n    const endAngle = this.endAngle;\n    if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {\n      return {\n        minX: -1,\n        maxX: 1,\n        minY: -1,\n        maxY: 1,\n      };\n    }\n    const xs = [0, Math.cos(startAngle), Math.cos(endAngle)];\n    const ys = [0, Math.sin(startAngle), Math.sin(endAngle)];\n\n    for (let i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {\n      xs.push(Math.cos(i));\n      ys.push(Math.sin(i));\n    }\n\n    return {\n      minX: Math.min(...xs),\n      maxX: Math.max(...xs),\n      minY: Math.min(...ys),\n      maxY: Math.max(...ys),\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}