{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { isArray, isFunction, isString } from '@antv/util';\nimport { getContainerSize, LEVEL, log } from '../../utils';\nimport { normalPadding } from '../../utils/padding';\nimport { functor, wordCloud } from '../../utils/transform/word-cloud';\n/**\n * 用 DataSet 转换词云图数据\n * @param params\n */\nexport function transform(params) {\n  var rawOptions = params.options,\n    chart = params.chart;\n  var _a = chart,\n    width = _a.width,\n    height = _a.height,\n    chartPadding = _a.padding,\n    appendPadding = _a.appendPadding,\n    ele = _a.ele;\n  var data = rawOptions.data,\n    imageMask = rawOptions.imageMask,\n    wordField = rawOptions.wordField,\n    weightField = rawOptions.weightField,\n    colorField = rawOptions.colorField,\n    wordStyle = rawOptions.wordStyle,\n    timeInterval = rawOptions.timeInterval,\n    random = rawOptions.random,\n    spiral = rawOptions.spiral,\n    _b = rawOptions.autoFit,\n    autoFit = _b === void 0 ? true : _b,\n    placementStrategy = rawOptions.placementStrategy;\n  if (!data || !data.length) {\n    return [];\n  }\n  var fontFamily = wordStyle.fontFamily,\n    fontWeight = wordStyle.fontWeight,\n    padding = wordStyle.padding,\n    fontSize = wordStyle.fontSize;\n  var arr = getSingleKeyValues(data, weightField);\n  var range = [min(arr), max(arr)];\n  // 变换出 text 和 value 字段\n  var words = data.map(function (datum) {\n    return {\n      text: datum[wordField],\n      value: datum[weightField],\n      color: datum[colorField],\n      datum: datum\n    };\n  });\n  var options = {\n    imageMask: imageMask,\n    font: fontFamily,\n    fontSize: getFontSizeMapping(fontSize, range),\n    fontWeight: fontWeight,\n    // 图表宽高减去 padding 之后的宽高\n    size: getSize({\n      width: width,\n      height: height,\n      padding: chartPadding,\n      appendPadding: appendPadding,\n      autoFit: autoFit,\n      container: ele\n    }),\n    padding: padding,\n    timeInterval: timeInterval,\n    random: random,\n    spiral: spiral,\n    rotate: getRotate(rawOptions)\n  };\n  // 自定义布局函数\n  if (isFunction(placementStrategy)) {\n    var result = words.map(function (word, index, words) {\n      return __assign(__assign(__assign({}, word), {\n        hasText: !!word.text,\n        font: functor(options.font)(word, index, words),\n        weight: functor(options.fontWeight)(word, index, words),\n        rotate: functor(options.rotate)(word, index, words),\n        size: functor(options.fontSize)(word, index, words),\n        style: 'normal'\n      }), placementStrategy.call(chart, word, index, words));\n    });\n    // 添加两个参照数据，分别表示左上角和右下角\n    result.push({\n      text: '',\n      value: 0,\n      x: 0,\n      y: 0,\n      opacity: 0\n    });\n    result.push({\n      text: '',\n      value: 0,\n      x: options.size[0],\n      y: options.size[1],\n      opacity: 0\n    });\n    return result;\n  }\n  // 数据准备在外部做，wordCloud 单纯就是做布局\n  return wordCloud(words, options);\n}\n/**\n * 获取最终的实际绘图尺寸：[width, height]\n * @param chart\n */\nexport function getSize(options) {\n  var width = options.width,\n    height = options.height;\n  var container = options.container,\n    autoFit = options.autoFit,\n    padding = options.padding,\n    appendPadding = options.appendPadding;\n  // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，\n  // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，\n  // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的\n  // 宽高信息与最终显示的宽高信息相同，避免显示错乱。\n  if (autoFit) {\n    var containerSize = getContainerSize(container);\n    width = containerSize.width;\n    height = containerSize.height;\n  }\n  // 宽高不能为 0，否则会造成死循环\n  width = width || 400;\n  height = height || 400;\n  var _a = resolvePadding({\n      padding: padding,\n      appendPadding: appendPadding\n    }),\n    top = _a[0],\n    right = _a[1],\n    bottom = _a[2],\n    left = _a[3];\n  var result = [width - (left + right), height - (top + bottom)];\n  return result;\n}\n/**\n * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding\n * @param chart\n */\nfunction resolvePadding(options) {\n  var padding = normalPadding(options.padding);\n  var appendPadding = normalPadding(options.appendPadding);\n  var top = padding[0] + appendPadding[0];\n  var right = padding[1] + appendPadding[1];\n  var bottom = padding[2] + appendPadding[2];\n  var left = padding[3] + appendPadding[3];\n  return [top, right, bottom, left];\n}\n/**\n * 处理 imageMask 可能为 url 字符串的情况\n * @param  {HTMLImageElement | string} img\n * @return {Promise}\n */\nexport function processImageMask(img) {\n  return new Promise(function (res, rej) {\n    if (img instanceof HTMLImageElement) {\n      res(img);\n      return;\n    }\n    if (isString(img)) {\n      var image_1 = new Image();\n      image_1.crossOrigin = 'anonymous';\n      image_1.src = img;\n      image_1.onload = function () {\n        res(image_1);\n      };\n      image_1.onerror = function () {\n        log(LEVEL.ERROR, false, 'image %s load failed !!!', img);\n        rej();\n      };\n      return;\n    }\n    log(LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');\n    rej();\n  });\n}\n/**\n * 把用户提供的 fontSize 值转换成符合 DataSet 要求的值\n * @param options\n * @param range\n */\nexport function getFontSizeMapping(fontSize, range) {\n  if (isFunction(fontSize)) {\n    return fontSize;\n  }\n  if (isArray(fontSize)) {\n    var fMin_1 = fontSize[0],\n      fMax_1 = fontSize[1];\n    if (!range) {\n      return function () {\n        return (fMax_1 + fMin_1) / 2;\n      };\n    }\n    var min_1 = range[0],\n      max_1 = range[1];\n    if (max_1 === min_1) {\n      return function () {\n        return (fMax_1 + fMin_1) / 2;\n      };\n    }\n    return function fontSize(_a) {\n      var value = _a.value;\n      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value - min_1) + fMin_1;\n    };\n  }\n  return function () {\n    return fontSize;\n  };\n}\nexport function getSingleKeyValues(data, key) {\n  return data.map(function (v) {\n    return v[key];\n  }).filter(function (v) {\n    // 过滤非 number\n    if (typeof v === 'number' && !isNaN(v)) return true;\n    return false;\n  });\n}\n/**\n * 把用户提供的关于旋转角度的字段值转换成符合 DataSet 要求的值\n * @param options\n */\nfunction getRotate(options) {\n  var _a = resolveRotate(options),\n    rotation = _a.rotation,\n    rotationSteps = _a.rotationSteps;\n  if (!isArray(rotation)) return rotation;\n  var min = rotation[0];\n  var max = rotation[1];\n  // 等于 1 时不旋转，所以把每份大小设为 0\n  var perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);\n  return function rotate() {\n    if (max === min) return max;\n    return Math.floor(Math.random() * rotationSteps) * perSize;\n  };\n}\n/**\n * 确保值在要求范围内\n * @param options\n */\nfunction resolveRotate(options) {\n  var rotationSteps = options.wordStyle.rotationSteps;\n  if (rotationSteps < 1) {\n    log(LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');\n    rotationSteps = 1;\n  }\n  return {\n    rotation: options.wordStyle.rotation,\n    rotationSteps: rotationSteps\n  };\n}\n/**\n * 传入一个元素为数字的数组，\n * 返回该数组中值最小的数字。\n * @param numbers\n */\nfunction min(numbers) {\n  return Math.min.apply(Math, numbers);\n}\n/**\n * 传入一个元素为数字的数组，\n * 返回该数组中值最大的数字。\n * @param numbers\n */\nfunction max(numbers) {\n  return Math.max.apply(Math, numbers);\n}","map":{"version":3,"mappings":"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","names":["isArray","isFunction","isString","getContainerSize","LEVEL","log","normalPadding","functor","wordCloud","transform","params","rawOptions","chart","width","height","chartPadding","appendPadding","ele","imageMask","wordField","weightField","colorField","wordStyle","timeInterval","random","spiral","_b","autoFit","placementStrategy","data","length","fontWeight","padding","fontSize","arr","getSingleKeyValues","range","min","max","words","map","datum","text","value","color","options","font","fontFamily","getFontSizeMapping","size","getSize","container","rotate","getRotate","result","word","index","hasText","weight","style","call","push","x","y","opacity","containerSize","resolvePadding","top","right","bottom","left","processImageMask","img","Promise","res","rej","HTMLImageElement","image_1","Image","crossOrigin","src","onload","onerror","ERROR","WARN","undefined","fMax_1","fMin_1","max_1","min_1","_a","key","v","filter","isNaN","resolveRotate","rotation","rotationSteps","perSize","Math","floor","numbers"],"sources":["/home/iam/Documents/network/node_modules/@antv/g2plot/src/plots/word-cloud/utils.ts"],"sourcesContent":["import { Chart, Types } from '@antv/g2';\r\nimport { isArray, isFunction, isString } from '@antv/util';\r\nimport { Params } from '../../core/adaptor';\r\nimport { Datum } from '../../types';\r\nimport { getContainerSize, LEVEL, log } from '../../utils';\r\nimport { normalPadding } from '../../utils/padding';\r\nimport { functor, wordCloud } from '../../utils/transform/word-cloud';\r\nimport { Tag, Word, WordCloudOptions, WordStyle } from './types';\r\n\r\n/**\r\n * 用 DataSet 转换词云图数据\r\n * @param params\r\n */\r\nexport function transform(params: Params<WordCloudOptions>): Tag[] {\r\n  const { options: rawOptions, chart } = params;\r\n  const { width, height, padding: chartPadding, appendPadding, ele } = chart as Chart;\r\n  const {\r\n    data,\r\n    imageMask,\r\n    wordField,\r\n    weightField,\r\n    colorField,\r\n    wordStyle,\r\n    timeInterval,\r\n    random,\r\n    spiral,\r\n    autoFit = true,\r\n    placementStrategy,\r\n  } = rawOptions;\r\n  if (!data || !data.length) {\r\n    return [];\r\n  }\r\n  const { fontFamily, fontWeight, padding, fontSize } = wordStyle;\r\n  const arr = getSingleKeyValues(data, weightField);\r\n  const range = [min(arr), max(arr)] as [number, number];\r\n\r\n  // 变换出 text 和 value 字段\r\n  const words = data.map(\r\n    (datum: Datum): Word => ({\r\n      text: datum[wordField],\r\n      value: datum[weightField],\r\n      color: datum[colorField],\r\n      datum, // 存一下原始数据\r\n    })\r\n  );\r\n\r\n  const options = {\r\n    imageMask: imageMask as HTMLImageElement,\r\n    font: fontFamily,\r\n    fontSize: getFontSizeMapping(fontSize, range),\r\n    fontWeight: fontWeight,\r\n    // 图表宽高减去 padding 之后的宽高\r\n    size: getSize({\r\n      width,\r\n      height,\r\n      padding: chartPadding,\r\n      appendPadding,\r\n      autoFit,\r\n      container: ele,\r\n    }),\r\n    padding: padding,\r\n    timeInterval,\r\n    random,\r\n    spiral,\r\n    rotate: getRotate(rawOptions),\r\n  };\r\n\r\n  // 自定义布局函数\r\n  if (isFunction(placementStrategy)) {\r\n    const result = words.map((word: Word, index: number, words: Word[]) => ({\r\n      ...word,\r\n      hasText: !!word.text,\r\n      font: functor(options.font)(word, index, words),\r\n      weight: functor(options.fontWeight)(word, index, words),\r\n      rotate: functor(options.rotate)(word, index, words),\r\n      size: functor(options.fontSize)(word, index, words),\r\n      style: 'normal',\r\n      ...placementStrategy.call(chart, word, index, words),\r\n    }));\r\n\r\n    // 添加两个参照数据，分别表示左上角和右下角\r\n    result.push({\r\n      text: '',\r\n      value: 0,\r\n      x: 0,\r\n      y: 0,\r\n      opacity: 0,\r\n    });\r\n    result.push({\r\n      text: '',\r\n      value: 0,\r\n      x: options.size[0],\r\n      y: options.size[1],\r\n      opacity: 0,\r\n    });\r\n\r\n    return result;\r\n  }\r\n\r\n  // 数据准备在外部做，wordCloud 单纯就是做布局\r\n  return wordCloud(words, options);\r\n}\r\n\r\n/**\r\n * 获取最终的实际绘图尺寸：[width, height]\r\n * @param chart\r\n */\r\nexport function getSize(options: {\r\n  width: number;\r\n  height: number;\r\n  padding: Types.ViewPadding;\r\n  appendPadding: Types.ViewAppendPadding;\r\n  autoFit: boolean;\r\n  container: HTMLElement;\r\n}): [number, number] {\r\n  let { width, height } = options;\r\n  const { container, autoFit, padding, appendPadding } = options;\r\n\r\n  // 由于词云图每个词语的坐标都是先通过 DataSet 根据图表宽高计算出来的，\r\n  // 也就是说，如果一开始提供给 DataSet 的宽高信息和最终显示的宽高不相同，\r\n  // 那么就会出现布局错乱的情况，所以这里处理的目的就是让一开始提供给 DataSet 的\r\n  // 宽高信息与最终显示的宽高信息相同，避免显示错乱。\r\n  if (autoFit) {\r\n    const containerSize = getContainerSize(container);\r\n    width = containerSize.width;\r\n    height = containerSize.height;\r\n  }\r\n\r\n  // 宽高不能为 0，否则会造成死循环\r\n  width = width || 400;\r\n  height = height || 400;\r\n\r\n  const [top, right, bottom, left] = resolvePadding({ padding, appendPadding });\r\n  const result = [width - (left + right), height - (top + bottom)];\r\n\r\n  return result as [number, number];\r\n}\r\n\r\n/**\r\n * 根据图表的 padding 和 appendPadding 计算出图表的最终 padding\r\n * @param chart\r\n */\r\nfunction resolvePadding(options: { padding: Types.ViewPadding; appendPadding: Types.ViewAppendPadding }) {\r\n  const padding = normalPadding(options.padding);\r\n  const appendPadding = normalPadding(options.appendPadding);\r\n  const top = padding[0] + appendPadding[0];\r\n  const right = padding[1] + appendPadding[1];\r\n  const bottom = padding[2] + appendPadding[2];\r\n  const left = padding[3] + appendPadding[3];\r\n\r\n  return [top, right, bottom, left];\r\n}\r\n\r\n/**\r\n * 处理 imageMask 可能为 url 字符串的情况\r\n * @param  {HTMLImageElement | string} img\r\n * @return {Promise}\r\n */\r\nexport function processImageMask(img: HTMLImageElement | string): Promise<HTMLImageElement> {\r\n  return new Promise((res, rej) => {\r\n    if (img instanceof HTMLImageElement) {\r\n      res(img);\r\n      return;\r\n    }\r\n    if (isString(img)) {\r\n      const image = new Image();\r\n      image.crossOrigin = 'anonymous';\r\n      image.src = img;\r\n      image.onload = () => {\r\n        res(image);\r\n      };\r\n      image.onerror = () => {\r\n        log(LEVEL.ERROR, false, 'image %s load failed !!!', img);\r\n        rej();\r\n      };\r\n      return;\r\n    }\r\n    log(LEVEL.WARN, img === undefined, 'The type of imageMask option must be String or HTMLImageElement.');\r\n    rej();\r\n  });\r\n}\r\n\r\n/**\r\n * 把用户提供的 fontSize 值转换成符合 DataSet 要求的值\r\n * @param options\r\n * @param range\r\n */\r\nexport function getFontSizeMapping(fontSize: WordStyle['fontSize'], range?: [number, number]) {\r\n  if (isFunction(fontSize)) {\r\n    return fontSize;\r\n  }\r\n  if (isArray(fontSize)) {\r\n    const [fMin, fMax] = fontSize;\r\n    if (!range) {\r\n      return () => (fMax + fMin) / 2;\r\n    }\r\n    const [min, max] = range;\r\n    if (max === min) {\r\n      return () => (fMax + fMin) / 2;\r\n    }\r\n    return function fontSize({ value }) {\r\n      return ((fMax - fMin) / (max - min)) * (value - min) + fMin;\r\n    };\r\n  }\r\n  return () => fontSize;\r\n}\r\n\r\nexport function getSingleKeyValues(data: Datum[], key: string) {\r\n  return data\r\n    .map((v) => v[key])\r\n    .filter((v) => {\r\n      // 过滤非 number\r\n      if (typeof v === 'number' && !isNaN(v)) return true;\r\n      return false;\r\n    });\r\n}\r\n\r\n/**\r\n * 把用户提供的关于旋转角度的字段值转换成符合 DataSet 要求的值\r\n * @param options\r\n */\r\nfunction getRotate(options: WordCloudOptions) {\r\n  const { rotation, rotationSteps } = resolveRotate(options);\r\n  if (!isArray(rotation)) return rotation;\r\n  const min = rotation[0];\r\n  const max = rotation[1];\r\n  // 等于 1 时不旋转，所以把每份大小设为 0\r\n  const perSize = rotationSteps === 1 ? 0 : (max - min) / (rotationSteps - 1);\r\n  return function rotate() {\r\n    if (max === min) return max;\r\n    return Math.floor(Math.random() * rotationSteps) * perSize;\r\n  };\r\n}\r\n\r\n/**\r\n * 确保值在要求范围内\r\n * @param options\r\n */\r\nfunction resolveRotate(options: WordCloudOptions) {\r\n  let { rotationSteps } = options.wordStyle;\r\n  if (rotationSteps < 1) {\r\n    log(LEVEL.WARN, false, 'The rotationSteps option must be greater than or equal to 1.');\r\n    rotationSteps = 1;\r\n  }\r\n  return {\r\n    rotation: options.wordStyle.rotation,\r\n    rotationSteps,\r\n  };\r\n}\r\n\r\n/**\r\n * 传入一个元素为数字的数组，\r\n * 返回该数组中值最小的数字。\r\n * @param numbers\r\n */\r\nfunction min(numbers: number[]) {\r\n  return Math.min(...numbers);\r\n}\r\n\r\n/**\r\n * 传入一个元素为数字的数组，\r\n * 返回该数组中值最大的数字。\r\n * @param numbers\r\n */\r\nfunction max(numbers: number[]) {\r\n  return Math.max(...numbers);\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}