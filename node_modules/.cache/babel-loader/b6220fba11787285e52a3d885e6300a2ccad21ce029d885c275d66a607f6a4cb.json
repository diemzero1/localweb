{"ast":null,"code":"import { assign, isFunction, isNil } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  font: function font() {\n    return 'serif';\n  },\n  padding: 1,\n  size: [500, 500],\n  spiral: 'archimedean',\n  // timeInterval: Infinity // max execute time\n  timeInterval: 3000\n};\n/**\n * 根据对应的数据对象，计算每个\n * 词语在画布中的渲染位置，并返回\n * 计算后的数据对象\n * @param words\n * @param options\n */\nexport function wordCloud(words, options) {\n  // 混入默认配置\n  options = assign({}, DEFAULT_OPTIONS, options);\n  return transform(words, options);\n}\n/**\n * 抛出没有混入默认配置的方法，用于测试。\n * @param words\n * @param options\n */\nexport function transform(words, options) {\n  // 布局对象\n  var layout = tagCloud();\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {\n    if (!isNil(options[key])) {\n      layout[key](options[key]);\n    }\n  });\n  layout.words(words);\n  if (options.imageMask) {\n    layout.createMask(options.imageMask);\n  }\n  var result = layout.start();\n  var tags = result._tags;\n  tags.forEach(function (tag) {\n    tag.x += options.size[0] / 2;\n    tag.y += options.size[1] / 2;\n  });\n  var _a = options.size,\n    w = _a[0],\n    h = _a[1];\n  // 添加两个参照数据，分别表示左上角和右下角。\n  // 不添加的话不会按照真实的坐标渲染，而是以\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\n  // 这样的后果会导致词语之间的重叠。\n  tags.push({\n    text: '',\n    value: 0,\n    x: 0,\n    y: 0,\n    opacity: 0\n  });\n  tags.push({\n    text: '',\n    value: 0,\n    x: w,\n    y: h,\n    opacity: 0\n  });\n  return tags;\n}\nvar cloudRadians = Math.PI / 180,\n  cw = 1 << 11 >> 5,\n  ch = 1 << 11;\nfunction cloudText(d) {\n  return d.text;\n}\nfunction cloudFont() {\n  return 'serif';\n}\nfunction cloudFontNormal() {\n  return 'normal';\n}\nfunction cloudFontSize(d) {\n  return d.value;\n}\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\nfunction cloudPadding() {\n  return 1;\n}\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n    ratio = contextAndRatio.ratio;\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n    y = 0,\n    maxh = 0;\n  var n = data.length;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n    var w = c.measureText(d.text + 'm').width * ratio,\n      h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n        cr = Math.cos(d.rotate * cloudRadians),\n        wcr = w * cr,\n        wsr = w * sr,\n        hcr = h * cr,\n        hsr = h * sr;\n      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = w + 0x1f >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n    sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n      w32 = w >> 5;\n    var h = d.y1 - d.y0;\n    // Zero the buffer\n    for (var i = 0; i < h * w32; i++) {\n      sprite[i] = 0;\n    }\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n      seenRow = -1;\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n          m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n    w = tag.width >> 5,\n    lx = tag.x - (w << 4),\n    sx = lx & 0x7f,\n    msx = 32 - sx,\n    h = tag.y1 - tag.y0;\n  var x = (tag.y + tag.y0) * sw + (lx >> 5),\n    last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n    b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\nfunction rectangularSpiral(size) {\n  var dy = 4,\n    dx = dy * size[0] / size[1];\n  var x = 0,\n    y = 0;\n  return function (t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n      case 0:\n        x += dx;\n        break;\n      case 1:\n        y += dy;\n        break;\n      case 2:\n        x -= dx;\n        break;\n      default:\n        y -= dy;\n        break;\n    }\n    return [x, y];\n  };\n}\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [];\n  var i = -1;\n  while (++i < n) {\n    a[i] = 0;\n  }\n  return a;\n}\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\nexport function functor(d) {\n  return isFunction(d) ? d : function () {\n    return d;\n  };\n}\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\nfunction tagCloud() {\n  var size = [256, 256],\n    font = cloudFont,\n    fontSize = cloudFontSize,\n    fontWeight = cloudFontNormal,\n    rotate = cloudRotate,\n    padding = cloudPadding,\n    spiral = archimedeanSpiral,\n    random = Math.random,\n    words = [],\n    timeInterval = Infinity;\n  var text = cloudText;\n  var fontStyle = cloudFontNormal;\n  var canvas = cloudCanvas;\n  var cloud = {};\n  cloud.start = function () {\n    var width = size[0],\n      height = size[1];\n    var contextAndRatio = getContext(canvas()),\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n      n = words.length,\n      tags = [],\n      data = words.map(function (d, i, data) {\n        d.text = text.call(this, d, i, data);\n        d.font = font.call(this, d, i, data);\n        d.style = fontStyle.call(this, d, i, data);\n        d.weight = fontWeight.call(this, d, i, data);\n        d.rotate = rotate.call(this, d, i, data);\n        d.size = ~~fontSize.call(this, d, i, data);\n        d.padding = padding.call(this, d, i, data);\n        return d;\n      }).sort(function (a, b) {\n        return b.size - a.size;\n      });\n    var i = -1,\n      bounds = !cloud.board ? null : [{\n        x: 0,\n        y: 0\n      }, {\n        x: width,\n        y: height\n      }];\n    step();\n    function step() {\n      var start = Date.now();\n      while (Date.now() - start < timeInterval && ++i < n) {\n        var d = data[i];\n        d.x = width * (random() + 0.5) >> 1;\n        d.y = height * (random() + 0.5) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [{\n              x: d.x + d.x0,\n              y: d.y + d.y0\n            }, {\n              x: d.x + d.x1,\n              y: d.y + d.y1\n            }];\n          }\n          // Temporary hack\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n    }\n    return cloud;\n  };\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n    var context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    return {\n      context: context,\n      ratio: ratio\n    };\n  }\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    var startX = tag.x,\n      startY = tag.y,\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n      s = spiral(size),\n      dt = random() < 0.5 ? 1 : -1;\n    var dxdy,\n      t = -dt,\n      dx,\n      dy;\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n            w = tag.width >> 5,\n            sw = size[0] >> 5,\n            lx = tag.x - (w << 4),\n            sx = lx & 0x7f,\n            msx = 32 - sx,\n            h = tag.y1 - tag.y0;\n          var last = void 0,\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  cloud.createMask = function (img) {\n    var can = document.createElement('canvas');\n    var width = size[0],\n      height = size[1];\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n    if (!width || !height) {\n      return;\n    }\n    var w32 = width >> 5;\n    var board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    var cxt = can.getContext('2d');\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    var imageData = cxt.getImageData(0, 0, width, height).data;\n    for (var j = 0; j < height; j++) {\n      for (var i = 0; i < width; i++) {\n        var k = w32 * j + (i >> 5);\n        var tmp = j * width + i << 2;\n        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n        var m = flag ? 1 << 31 - i % 32 : 0;\n        board[k] |= m;\n      }\n    }\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n  cloud.words = function (_) {\n    words = _;\n  };\n  cloud.size = function (_) {\n    size = [+_[0], +_[1]];\n  };\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n  return cloud;\n}","map":{"version":3,"mappings":"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","names":["assign","isFunction","isNil","DEFAULT_OPTIONS","font","padding","size","spiral","timeInterval","wordCloud","words","options","transform","layout","tagCloud","forEach","key","imageMask","createMask","result","start","tags","_tags","tag","x","y","w","h","push","text","value","opacity","cloudRadians","Math","PI","cw","ch","cloudText","d","cloudFont","cloudFontNormal","cloudFontSize","cloudRotate","random","cloudPadding","cloudSprite","contextAndRatio","data","di","sprite","c","context","ratio","clearRect","maxh","n","length","save","style","weight","measureText","width","rotate","sr","sin","cr","cos","wcr","wsr","hcr","hsr","max","abs","translate","fillText","lineWidth","strokeText","restore","height","xoff","yoff","x1","y1","x0","y0","hasText","pixels","getImageData","w32","i","seen","seenRow","j","k","m","slice","cloudCollide","board","sw","lx","sx","msx","last","cloudBounds","bounds","b0","b1","collideRects","a","b","archimedeanSpiral","e","t","rectangularSpiral","dy","dx","sign","sqrt","zeroArray","cloudCanvas","document","createElement","functor","spirals","archimedean","rectangular","fontSize","fontWeight","Infinity","fontStyle","canvas","cloud","getContext","map","call","sort","step","Date","now","place","hasImage","_bounds","fillStyle","strokeStyle","textAlign","startX","startY","maxDelta","s","dt","dxdy","min","img","can","cxt","drawImage","imageData","tmp","flag","_"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/g2plot/src/utils/transform/word-cloud.ts"],"sourcesContent":["import { assign, isFunction, isNil } from '@antv/util';\r\nimport { Tag, Word } from '../../plots/word-cloud/types';\r\n\r\ntype FontWeight = number | 'normal' | 'bold' | 'bolder' | 'lighter';\r\n\r\nexport interface Options {\r\n  size: [number, number];\r\n  font?: string | ((row: Word, index?: number, words?: Word[]) => string);\r\n  fontSize?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  fontWeight?: FontWeight | ((row: Word, index?: number, words?: Word[]) => FontWeight);\r\n  rotate?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  padding?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  spiral?: 'archimedean' | 'rectangular' | ((size: [number, number]) => (t: number) => number[]);\r\n  random?: number | (() => number);\r\n  timeInterval?: number;\r\n  imageMask?: HTMLImageElement;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Options = {\r\n  font: () => 'serif',\r\n  padding: 1,\r\n  size: [500, 500],\r\n  spiral: 'archimedean', // 'archimedean' || 'rectangular' || {function}\r\n  // timeInterval: Infinity // max execute time\r\n  timeInterval: 3000, // max execute time\r\n  // imageMask: '', // instance of Image, must be loaded\r\n};\r\n\r\n/**\r\n * 根据对应的数据对象，计算每个\r\n * 词语在画布中的渲染位置，并返回\r\n * 计算后的数据对象\r\n * @param words\r\n * @param options\r\n */\r\nexport function wordCloud(words: Word[], options?: Partial<Options>): Tag[] {\r\n  // 混入默认配置\r\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\r\n  return transform(words, options as Options);\r\n}\r\n\r\n/**\r\n * 抛出没有混入默认配置的方法，用于测试。\r\n * @param words\r\n * @param options\r\n */\r\nexport function transform(words: Word[], options: Options) {\r\n  // 布局对象\r\n  const layout = tagCloud();\r\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(\r\n    (key: string) => {\r\n      if (!isNil(options[key])) {\r\n        layout[key](options[key]);\r\n      }\r\n    }\r\n  );\r\n\r\n  layout.words(words);\r\n  if (options.imageMask) {\r\n    layout.createMask(options.imageMask);\r\n  }\r\n\r\n  const result = layout.start();\r\n  const tags: any[] = result._tags;\r\n\r\n  tags.forEach((tag) => {\r\n    tag.x += options.size[0] / 2;\r\n    tag.y += options.size[1] / 2;\r\n  });\r\n\r\n  const [w, h] = options.size;\r\n  // 添加两个参照数据，分别表示左上角和右下角。\r\n  // 不添加的话不会按照真实的坐标渲染，而是以\r\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\r\n  // 这样的后果会导致词语之间的重叠。\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: 0,\r\n    y: 0,\r\n    opacity: 0,\r\n  });\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: w,\r\n    y: h,\r\n    opacity: 0,\r\n  });\r\n\r\n  return tags;\r\n}\r\n\r\n/*\r\n * Synchronous version of d3-cloud\r\n */\r\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\r\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\r\n/* eslint-disable no-return-assign, no-cond-assign */\r\n\r\ninterface Item {\r\n  value: number;\r\n  text: string;\r\n  sprite: boolean;\r\n}\r\n\r\nconst cloudRadians = Math.PI / 180,\r\n  cw = (1 << 11) >> 5,\r\n  ch = 1 << 11;\r\n\r\nfunction cloudText(d: Item) {\r\n  return d.text;\r\n}\r\n\r\nfunction cloudFont() {\r\n  return 'serif';\r\n}\r\n\r\nfunction cloudFontNormal() {\r\n  return 'normal';\r\n}\r\n\r\nfunction cloudFontSize(d: Item) {\r\n  return d.value;\r\n}\r\n\r\nfunction cloudRotate() {\r\n  return ~~(Math.random() * 2) * 90;\r\n}\r\n\r\nfunction cloudPadding() {\r\n  return 1;\r\n}\r\n\r\n// Fetches a monochrome sprite bitmap for the specified text.\r\n// Load in batches for speed.\r\nfunction cloudSprite(contextAndRatio, d, data, di) {\r\n  if (d.sprite) return;\r\n  const c = contextAndRatio.context,\r\n    ratio = contextAndRatio.ratio;\r\n\r\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\r\n  let x = 0,\r\n    y = 0,\r\n    maxh = 0;\r\n  const n = data.length;\r\n  --di;\r\n  while (++di < n) {\r\n    d = data[di];\r\n    c.save();\r\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\r\n    let w = c.measureText(d.text + 'm').width * ratio,\r\n      h = d.size << 1;\r\n    if (d.rotate) {\r\n      const sr = Math.sin(d.rotate * cloudRadians),\r\n        cr = Math.cos(d.rotate * cloudRadians),\r\n        wcr = w * cr,\r\n        wsr = w * sr,\r\n        hcr = h * cr,\r\n        hsr = h * sr;\r\n      w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\r\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\r\n    } else {\r\n      w = ((w + 0x1f) >> 5) << 5;\r\n    }\r\n    if (h > maxh) maxh = h;\r\n    if (x + w >= cw << 5) {\r\n      x = 0;\r\n      y += maxh;\r\n      maxh = 0;\r\n    }\r\n    if (y + h >= ch) break;\r\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\r\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\r\n    c.fillText(d.text, 0, 0);\r\n    if (d.padding) {\r\n      c.lineWidth = 2 * d.padding;\r\n      c.strokeText(d.text, 0, 0);\r\n    }\r\n    c.restore();\r\n    d.width = w;\r\n    d.height = h;\r\n    d.xoff = x;\r\n    d.yoff = y;\r\n    d.x1 = w >> 1;\r\n    d.y1 = h >> 1;\r\n    d.x0 = -d.x1;\r\n    d.y0 = -d.y1;\r\n    d.hasText = true;\r\n    x += w;\r\n  }\r\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\r\n    sprite = [];\r\n  while (--di >= 0) {\r\n    d = data[di];\r\n    if (!d.hasText) continue;\r\n    const w = d.width,\r\n      w32 = w >> 5;\r\n    let h = d.y1 - d.y0;\r\n    // Zero the buffer\r\n    for (let i = 0; i < h * w32; i++) sprite[i] = 0;\r\n    x = d.xoff;\r\n    if (x == null) return;\r\n    y = d.yoff;\r\n    let seen = 0,\r\n      seenRow = -1;\r\n    for (let j = 0; j < h; j++) {\r\n      for (let i = 0; i < w; i++) {\r\n        const k = w32 * j + (i >> 5),\r\n          m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\r\n        sprite[k] |= m;\r\n        seen |= m;\r\n      }\r\n      if (seen) seenRow = j;\r\n      else {\r\n        d.y0++;\r\n        h--;\r\n        j--;\r\n        y++;\r\n      }\r\n    }\r\n    d.y1 = d.y0 + seenRow;\r\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\r\n  }\r\n}\r\n\r\n// Use mask-based collision detection.\r\nfunction cloudCollide(tag, board, sw) {\r\n  sw >>= 5;\r\n  const sprite = tag.sprite,\r\n    w = tag.width >> 5,\r\n    lx = tag.x - (w << 4),\r\n    sx = lx & 0x7f,\r\n    msx = 32 - sx,\r\n    h = tag.y1 - tag.y0;\r\n  let x = (tag.y + tag.y0) * sw + (lx >> 5),\r\n    last;\r\n  for (let j = 0; j < h; j++) {\r\n    last = 0;\r\n    for (let i = 0; i <= w; i++) {\r\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\r\n    }\r\n    x += sw;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction cloudBounds(bounds, d) {\r\n  const b0 = bounds[0],\r\n    b1 = bounds[1];\r\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\r\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\r\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\r\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\r\n}\r\n\r\nfunction collideRects(a, b) {\r\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\r\n}\r\n\r\nfunction archimedeanSpiral(size) {\r\n  const e = size[0] / size[1];\r\n  return function (t) {\r\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\r\n  };\r\n}\r\n\r\nfunction rectangularSpiral(size) {\r\n  const dy = 4,\r\n    dx = (dy * size[0]) / size[1];\r\n  let x = 0,\r\n    y = 0;\r\n  return function (t) {\r\n    const sign = t < 0 ? -1 : 1;\r\n    // See triangular numbers: T_n = n * (n + 1) / 2.\r\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\r\n      case 0:\r\n        x += dx;\r\n        break;\r\n      case 1:\r\n        y += dy;\r\n        break;\r\n      case 2:\r\n        x -= dx;\r\n        break;\r\n      default:\r\n        y -= dy;\r\n        break;\r\n    }\r\n    return [x, y];\r\n  };\r\n}\r\n\r\n// TODO reuse arrays?\r\nfunction zeroArray(n) {\r\n  const a = [];\r\n  let i = -1;\r\n  while (++i < n) a[i] = 0;\r\n  return a;\r\n}\r\n\r\nfunction cloudCanvas() {\r\n  return document.createElement('canvas');\r\n}\r\n\r\nexport function functor(d) {\r\n  return isFunction(d)\r\n    ? d\r\n    : function () {\r\n        return d;\r\n      };\r\n}\r\n\r\nconst spirals = {\r\n  archimedean: archimedeanSpiral,\r\n  rectangular: rectangularSpiral,\r\n};\r\n\r\nfunction tagCloud() {\r\n  let size = [256, 256],\r\n    font = cloudFont,\r\n    fontSize = cloudFontSize,\r\n    fontWeight = cloudFontNormal,\r\n    rotate = cloudRotate,\r\n    padding = cloudPadding,\r\n    spiral = archimedeanSpiral,\r\n    random = Math.random,\r\n    words = [],\r\n    timeInterval = Infinity;\r\n\r\n  const text = cloudText;\r\n  const fontStyle = cloudFontNormal;\r\n  const canvas = cloudCanvas;\r\n  const cloud: any = {};\r\n\r\n  cloud.start = function () {\r\n    const [width, height] = size;\r\n    const contextAndRatio = getContext(canvas()),\r\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\r\n      n = words.length,\r\n      tags = [],\r\n      data = words\r\n        .map(function (d, i, data) {\r\n          d.text = text.call(this, d, i, data);\r\n          d.font = font.call(this, d, i, data);\r\n          d.style = fontStyle.call(this, d, i, data);\r\n          d.weight = fontWeight.call(this, d, i, data);\r\n          d.rotate = rotate.call(this, d, i, data);\r\n          d.size = ~~fontSize.call(this, d, i, data);\r\n          d.padding = padding.call(this, d, i, data);\r\n          return d;\r\n        })\r\n        .sort(function (a, b) {\r\n          return b.size - a.size;\r\n        });\r\n    let i = -1,\r\n      bounds = !cloud.board\r\n        ? null\r\n        : [\r\n            {\r\n              x: 0,\r\n              y: 0,\r\n            },\r\n            {\r\n              x: width,\r\n              y: height,\r\n            },\r\n          ];\r\n\r\n    step();\r\n\r\n    function step() {\r\n      const start = Date.now();\r\n      while (Date.now() - start < timeInterval && ++i < n) {\r\n        const d = data[i];\r\n        d.x = (width * (random() + 0.5)) >> 1;\r\n        d.y = (height * (random() + 0.5)) >> 1;\r\n        cloudSprite(contextAndRatio, d, data, i);\r\n        if (d.hasText && place(board, d, bounds)) {\r\n          tags.push(d);\r\n          if (bounds) {\r\n            if (!cloud.hasImage) {\r\n              // update bounds if image mask not set\r\n              cloudBounds(bounds, d);\r\n            }\r\n          } else {\r\n            bounds = [\r\n              { x: d.x + d.x0, y: d.y + d.y0 },\r\n              { x: d.x + d.x1, y: d.y + d.y1 },\r\n            ];\r\n          }\r\n          // Temporary hack\r\n          d.x -= size[0] >> 1;\r\n          d.y -= size[1] >> 1;\r\n        }\r\n      }\r\n      cloud._tags = tags;\r\n      cloud._bounds = bounds;\r\n    }\r\n\r\n    return cloud;\r\n  };\r\n\r\n  function getContext(canvas: HTMLCanvasElement) {\r\n    canvas.width = canvas.height = 1;\r\n    const ratio = Math.sqrt(canvas.getContext('2d')!.getImageData(0, 0, 1, 1).data.length >> 2);\r\n    canvas.width = (cw << 5) / ratio;\r\n    canvas.height = ch / ratio;\r\n\r\n    const context = canvas.getContext('2d') as CanvasRenderingContext2D;\r\n    context.fillStyle = context.strokeStyle = 'red';\r\n    context.textAlign = 'center';\r\n    return { context, ratio };\r\n  }\r\n\r\n  function place(board, tag, bounds) {\r\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\r\n    const startX = tag.x,\r\n      startY = tag.y,\r\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\r\n      s = spiral(size),\r\n      dt = random() < 0.5 ? 1 : -1;\r\n    let dxdy,\r\n      t = -dt,\r\n      dx,\r\n      dy;\r\n\r\n    while ((dxdy = s((t += dt)))) {\r\n      dx = ~~dxdy[0];\r\n      dy = ~~dxdy[1];\r\n\r\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\r\n\r\n      tag.x = startX + dx;\r\n      tag.y = startY + dy;\r\n\r\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\r\n      // TODO only check for collisions within current bounds.\r\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\r\n        if (!bounds || collideRects(tag, bounds)) {\r\n          const sprite = tag.sprite,\r\n            w = tag.width >> 5,\r\n            sw = size[0] >> 5,\r\n            lx = tag.x - (w << 4),\r\n            sx = lx & 0x7f,\r\n            msx = 32 - sx,\r\n            h = tag.y1 - tag.y0;\r\n          let last,\r\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\r\n          for (let j = 0; j < h; j++) {\r\n            last = 0;\r\n            for (let i = 0; i <= w; i++) {\r\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\r\n            }\r\n            x += sw;\r\n          }\r\n          delete tag.sprite;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  cloud.createMask = (img: HTMLImageElement) => {\r\n    const can: HTMLCanvasElement = document.createElement('canvas');\r\n    const [width, height] = size;\r\n\r\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n    const w32 = width >> 5;\r\n    const board = zeroArray((width >> 5) * height);\r\n    can.width = width;\r\n    can.height = height;\r\n    const cxt = can.getContext('2d') as CanvasRenderingContext2D;\r\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\r\n    const imageData = cxt.getImageData(0, 0, width, height).data;\r\n    for (let j = 0; j < height; j++) {\r\n      for (let i = 0; i < width; i++) {\r\n        const k = w32 * j + (i >> 5);\r\n        const tmp = (j * width + i) << 2;\r\n        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\r\n        const m = flag ? 1 << (31 - (i % 32)) : 0;\r\n        board[k] |= m;\r\n      }\r\n    }\r\n    cloud.board = board;\r\n    cloud.hasImage = true;\r\n  };\r\n\r\n  cloud.timeInterval = function (_) {\r\n    timeInterval = _ == null ? Infinity : _;\r\n  };\r\n\r\n  cloud.words = function (_) {\r\n    words = _;\r\n  };\r\n\r\n  cloud.size = function (_) {\r\n    size = [+_[0], +_[1]];\r\n  };\r\n\r\n  cloud.font = function (_) {\r\n    font = functor(_);\r\n  };\r\n\r\n  cloud.fontWeight = function (_) {\r\n    fontWeight = functor(_);\r\n  };\r\n\r\n  cloud.rotate = function (_) {\r\n    rotate = functor(_);\r\n  };\r\n\r\n  cloud.spiral = function (_) {\r\n    spiral = spirals[_] || _;\r\n  };\r\n\r\n  cloud.fontSize = function (_) {\r\n    fontSize = functor(_);\r\n  };\r\n\r\n  cloud.padding = function (_) {\r\n    padding = functor(_);\r\n  };\r\n\r\n  cloud.random = function (_) {\r\n    random = functor(_);\r\n  };\r\n\r\n  return cloud;\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}