{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as _ from '@antv/util';\nimport Adjust from './adjust';\nvar Symmetric = /** @class */function (_super) {\n  __extends(Symmetric, _super);\n  function Symmetric() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  Symmetric.prototype.process = function (groupDataArray) {\n    var mergeData = _.flatten(groupDataArray);\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 每个 x 值对应的 最大值\n    var cache = this.getXValuesMaxMap(mergeData);\n    // 所有数据的最大的值\n    var max = Math.max.apply(Math, Object.keys(cache).map(function (key) {\n      return cache[key];\n    }));\n    return _.map(groupDataArray, function (dataArray) {\n      return _.map(dataArray, function (data) {\n        var _a, _b;\n        var yValue = data[yField];\n        var xValue = data[xField];\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          var off_1 = (max - cache[xValue]) / 2;\n          return __assign(__assign({}, data), (_a = {}, _a[yField] = _.map(yValue, function (y) {\n            return off_1 + y;\n          }), _a));\n        }\n        // 非数组处理逻辑\n        var offset = (max - yValue) / 2;\n        return __assign(__assign({}, data), (_b = {}, _b[yField] = [offset, yValue + offset], _b));\n      });\n    });\n  };\n  // 获取每个 x 对应的最大的值\n  Symmetric.prototype.getXValuesMaxMap = function (mergeData) {\n    var _this = this;\n    var _a = this,\n      xField = _a.xField,\n      yField = _a.yField;\n    // 根据 xField 的值进行分组\n    var groupDataArray = _.groupBy(mergeData, function (data) {\n      return data[xField];\n    });\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, function (dataArray) {\n      return _this.getDimMaxValue(dataArray, yField);\n    });\n  };\n  Symmetric.prototype.getDimMaxValue = function (mergeData, dim) {\n    // 所有的 value 值\n    var dimValues = _.map(mergeData, function (data) {\n      return _.get(data, dim, []);\n    });\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    var flattenValues = _.flatten(dimValues);\n    // 求出数组的最大值\n    return Math.max.apply(Math, flattenValues);\n  };\n  return Symmetric;\n}(Adjust);\nexport default Symmetric;","map":{"version":3,"mappings":";AAAA,OAAO,KAAKA,CAAC,MAAM,YAAY;AAE/B,OAAOC,MAAM,MAAM,UAAU;AAE7B;EAAuCC;EAAvC;;EAyDA;EAxDSC,2BAAO,GAAd,UAAeC,cAAwB;IACrC,IAAMC,SAAS,GAAGL,CAAC,CAACM,OAAO,CAACF,cAAc,CAAC;IAErC,SAAqB,IAAI;MAAvBG,MAAM;MAAEC,MAAM,YAAS;IAE/B;IACA,IAAMC,KAAK,GAAG,IAAI,CAACC,gBAAgB,CAACL,SAAS,CAAC;IAE9C;IACA,IAAMM,GAAG,GAAGC,IAAI,CAACD,GAAG,OAARC,IAAI,EAAQC,MAAM,CAACC,IAAI,CAACL,KAAK,CAAC,CAACM,GAAG,CAAC,UAACC,GAAG;MAAK,YAAK,CAACA,GAAG,CAAC;IAAV,CAAU,CAAC,CAAC;IAEpE,OAAOhB,CAAC,CAACe,GAAG,CAACX,cAAc,EAAE,UAACa,SAAS;MACrC,OAAOjB,CAAC,CAACe,GAAG,CAACE,SAAS,EAAE,UAACC,IAAI;;QAC3B,IAAMC,MAAM,GAAGD,IAAI,CAACV,MAAM,CAAC;QAC3B,IAAMY,MAAM,GAAGF,IAAI,CAACX,MAAM,CAAC;QAE3B;QACA,IAAIP,CAAC,CAACqB,OAAO,CAACF,MAAM,CAAC,EAAE;UACrB,IAAMG,KAAG,GAAG,CAACX,GAAG,GAAGF,KAAK,CAACW,MAAM,CAAC,IAAI,CAAC;UAErC,6BACKF,IAAI,gBACNV,MAAM,IAAGR,CAAC,CAACe,GAAG,CAACI,MAAM,EAAE,UAACI,CAAS;YAAK,YAAG,GAAGA,CAAC;UAAP,CAAO,CAAC;;QAInD;QACA,IAAMC,MAAM,GAAG,CAACb,GAAG,GAAGQ,MAAM,IAAI,CAAC;QACjC,6BACKD,IAAI,gBACNV,MAAM,IAAG,CAACgB,MAAM,EAAEL,MAAM,GAAGK,MAAM,CAAC;MAEvC,CAAC,CAAC;IACJ,CAAC,CAAC;EACJ,CAAC;EAED;EACQrB,oCAAgB,GAAxB,UAAyBE,SAAiB;IAA1C;IACQ,SAAqB,IAAI;MAAvBE,MAAM;MAAEC,MAAM,YAAS;IAE/B;IACA,IAAMJ,cAAc,GAAGJ,CAAC,CAACyB,OAAO,CAACpB,SAAS,EAAE,UAACa,IAAI;MAAK,WAAI,CAACX,MAAM,CAAW;IAAtB,CAAsB,CAAC;IAE7E;IACA,OAAOP,CAAC,CAAC0B,SAAS,CAACtB,cAAc,EAAE,UAACa,SAAS;MAAK,YAAI,CAACU,cAAc,CAACV,SAAS,EAAET,MAAM,CAAC;IAAtC,CAAsC,CAAC;EAC3F,CAAC;EAEOL,kCAAc,GAAtB,UAAuBE,SAAiB,EAAEuB,GAAW;IACnD;IACA,IAAMC,SAAS,GAAG7B,CAAC,CAACe,GAAG,CAACV,SAAS,EAAE,UAACa,IAAI;MAAK,QAAC,CAACY,GAAG,CAACZ,IAAI,EAAEU,GAAG,EAAE,EAAE,CAAC;IAApB,CAAoB,CAAC;IAClE;IACA,IAAMG,aAAa,GAAG/B,CAAC,CAACM,OAAO,CAACuB,SAAS,CAAC;IAE1C;IACA,OAAOjB,IAAI,CAACD,GAAG,OAARC,IAAI,EAAQmB,aAAa;EAClC,CAAC;EACH,gBAAC;AAAD,CAAC,CAzDsC9B,MAAM","names":["_","Adjust","__extends","Symmetric","groupDataArray","mergeData","flatten","xField","yField","cache","getXValuesMaxMap","max","Math","Object","keys","map","key","dataArray","data","yValue","xValue","isArray","off_1","y","offset","groupBy","mapValues","getDimMaxValue","dim","dimValues","get","flattenValues"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/adjust/src/adjusts/symmetric.ts"],"sourcesContent":["import * as _ from '@antv/util';\nimport { Data } from '../interface';\nimport Adjust from './adjust';\n\nexport default class Symmetric extends Adjust {\n  public process(groupDataArray: Data[][]): Data[][] {\n    const mergeData = _.flatten(groupDataArray);\n\n    const { xField, yField } = this;\n\n    // 每个 x 值对应的 最大值\n    const cache = this.getXValuesMaxMap(mergeData);\n\n    // 所有数据的最大的值\n    const max = Math.max(...Object.keys(cache).map((key) => cache[key]));\n\n    return _.map(groupDataArray, (dataArray) => {\n      return _.map(dataArray, (data) => {\n        const yValue = data[yField];\n        const xValue = data[xField];\n\n        // 数组处理逻辑\n        if (_.isArray(yValue)) {\n          const off = (max - cache[xValue]) / 2;\n\n          return {\n            ...data,\n            [yField]: _.map(yValue, (y: number) => off + y),\n          };\n        }\n\n        // 非数组处理逻辑\n        const offset = (max - yValue) / 2;\n        return {\n          ...data,\n          [yField]: [offset, yValue + offset],\n        };\n      });\n    });\n  }\n\n  // 获取每个 x 对应的最大的值\n  private getXValuesMaxMap(mergeData: Data[]): { [key: string]: number } {\n    const { xField, yField } = this;\n\n    // 根据 xField 的值进行分组\n    const groupDataArray = _.groupBy(mergeData, (data) => data[xField] as string);\n\n    // 获取每个 xField 值中的最大值\n    return _.mapValues(groupDataArray, (dataArray) => this.getDimMaxValue(dataArray, yField));\n  }\n\n  private getDimMaxValue(mergeData: Data[], dim: string): number {\n    // 所有的 value 值\n    const dimValues = _.map(mergeData, (data) => _.get(data, dim, []));\n    // 将数组打平（dim value 有可能是数组，比如 stack 之后的）\n    const flattenValues = _.flatten(dimValues);\n\n    // 求出数组的最大值\n    return Math.max(...flattenValues);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}