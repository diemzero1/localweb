{"ast":null,"code":"import { each } from '@antv/util';\nvar MAX_TIMES = 100;\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nvar Greedy = /** @class */function () {\n  function Greedy(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n    this.bitmap = {};\n    var _a = cfg.xGap,\n      xGap = _a === void 0 ? 1 : _a,\n      _b = cfg.yGap,\n      yGap = _b === void 0 ? 8 : _b;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n  Greedy.prototype.hasGap = function (bbox) {\n    var hasGap = true;\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (var j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  };\n  Greedy.prototype.fillGap = function (bbox) {\n    var bitmap = this.bitmap;\n    var minX = Math.round(bbox.minX);\n    var maxX = Math.round(bbox.maxX);\n    var minY = Math.round(bbox.minY);\n    var maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (var i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (var i = minX; i <= maxX; i += this.xGap) {\n      for (var j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (var i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (var i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  };\n  Greedy.prototype.destroy = function () {\n    this.bitmap = {};\n  };\n  return Greedy;\n}();\nfunction spiralFill(label, greedy, maxTimes) {\n  if (maxTimes === void 0) {\n    maxTimes = MAX_TIMES;\n  }\n  var dt = -1;\n  var _a = label.attr(),\n    x = _a.x,\n    y = _a.y;\n  var bbox = label.getCanvasBBox();\n  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  var dxdy;\n  var t = -dt;\n  var dx = 0;\n  var dy = 0;\n  var f = function (param) {\n    var nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  var canFill = false;\n  var times = 0;\n  var accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f(t += dt);\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if (!dx && !dy || accessedCache[\"\".concat(dx, \"-\").concat(dy)]) {\n      continue;\n    }\n    label.attr({\n      x: x + dx,\n      y: y + dy\n    });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[\"\".concat(dx, \"-\").concat(dy)] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label, x, y, index) {\n  var _a = label.getCanvasBBox(),\n    width = _a.width,\n    height = _a.height;\n  var attrs = {\n    x: x,\n    y: y,\n    textAlign: 'center'\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items, labels, shapes, region) {\n  var greedy = new Greedy();\n  each(labels, function (label) {\n    var labelShape = label.find(function (shape) {\n      return shape.get('type') === 'text';\n    });\n    var _a = labelShape.attr(),\n      x = _a.x,\n      y = _a.y;\n    var canFill = false;\n    for (var i = 0; i <= 8; i++) {\n      var bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}","map":{"version":3,"mappings":"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","names":["each","MAX_TIMES","cfg","xGap","_b","yGap","Greedy","bbox","hasGap","bitmap","minX","Math","round","maxX","minY","maxY","i","j","spiralFill","label","greedy","maxTimes","dt","attr","x","y","getCanvasBBox","maxDelta","sqrt","width","height","dxdy","t","dx","dy","f","param","nt","cos","sin","fillGap","canFill","times","accessedCache","min","abs","adjustLabelPosition","index","attrs","textAlign","fixedOverlap","items","labels","shapes","region","labelShape","find","shape","get","remove","destroy","overlap"],"sources":["/home/iam/Documents/network/node_modules/@antv/g2/src/geometry/label/layout/overlap.ts"],"sourcesContent":["import { each } from '@antv/util';\nimport { BBox, IGroup, IShape } from '../../../dependents';\nimport { LabelItem } from '../interface';\n\nconst MAX_TIMES = 100;\n\n/** @ignore */\ninterface Bitmap {\n  [key: number]: {\n    [key: number]: boolean;\n  };\n}\n\n/** @ignore */\ninterface GreedyCfg {\n  readonly xGap?: number;\n  readonly yGap?: number;\n}\n\n/**\n * @ignore\n * Greedy 贪婪算法\n */\nclass Greedy {\n  public readonly xGap: number;\n  /** optimizing for text overlapping detection: use a min text height as gap */\n  public readonly yGap: number;\n\n  private bitmap: Bitmap = {};\n\n  constructor(cfg: GreedyCfg = {}) {\n    const { xGap = 1, yGap = 8 } = cfg;\n    this.xGap = xGap;\n    this.yGap = yGap;\n  }\n\n  public hasGap(bbox: BBox): boolean {\n    let hasGap = true;\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n        continue;\n      }\n      if (i === minX || i === maxX) {\n        for (let j = minY; j <= maxY; j++) {\n          if (bitmap[i][j]) {\n            hasGap = false;\n            break;\n          }\n        }\n      } else {\n        if (bitmap[i][minY] || bitmap[i][maxY]) {\n          hasGap = false;\n          break;\n        }\n      }\n    }\n    return hasGap;\n  }\n\n  public fillGap(bbox: BBox): void {\n    const bitmap = this.bitmap;\n    const minX = Math.round(bbox.minX);\n    const maxX = Math.round(bbox.maxX);\n    const minY = Math.round(bbox.minY);\n    const maxY = Math.round(bbox.maxY);\n    // filling grid\n    for (let i = minX; i <= maxX; i += 1) {\n      if (!bitmap[i]) {\n        bitmap[i] = {};\n      }\n    }\n    for (let i = minX; i <= maxX; i += this.xGap) {\n      for (let j = minY; j <= maxY; j += this.yGap) {\n        bitmap[i][j] = true;\n      }\n      bitmap[i][maxY] = true;\n    }\n\n    // filling y edges\n    if (this.yGap !== 1) {\n      for (let i = minY; i <= maxY; i += 1) {\n        bitmap[minX][i] = true;\n        bitmap[maxX][i] = true;\n      }\n    }\n\n    // filling x edges\n    if (this.xGap !== 1) {\n      for (let i = minX; i <= maxX; i += 1) {\n        bitmap[i][minY] = true;\n        bitmap[i][maxY] = true;\n      }\n    }\n  }\n\n  public destroy(): void {\n    this.bitmap = {};\n  }\n}\n\nfunction spiralFill(label: IShape, greedy: Greedy, maxTimes: number = MAX_TIMES) {\n  const dt = -1;\n  const { x, y } = label.attr();\n  const bbox = label.getCanvasBBox();\n  const maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);\n  let dxdy;\n  let t = -dt;\n  let dx = 0;\n  let dy = 0;\n  const f = (param: number) => {\n    const nt = param * 0.1;\n    return [nt * Math.cos(nt), nt * Math.sin(nt)];\n  };\n\n  if (greedy.hasGap(bbox)) {\n    greedy.fillGap(bbox);\n    return true;\n  }\n  let canFill = false;\n  let times = 0;\n  const accessedCache = {};\n  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times < maxTimes) {\n    dxdy = f((t += dt));\n    dx = ~~dxdy[0];\n    dy = ~~dxdy[1];\n    if ((!dx && !dy) || accessedCache[`${dx}-${dy}`]) {\n      continue;\n    }\n    label.attr({ x: x + dx, y: y + dy });\n    if (dx + dy < 0) {\n      label.attr('textAlign', 'right');\n    }\n    times++;\n    if (greedy.hasGap(label.getCanvasBBox())) {\n      greedy.fillGap(label.getCanvasBBox());\n      canFill = true;\n      accessedCache[`${dx}-${dy}`] = true;\n      break;\n    }\n  }\n  return canFill;\n}\n\n/*\n *  根据如下规则尝试放置label\n *                5\n *        ------------------\n *        |    1   |   0   |\n *    8   —————————4————————   7\n *        |    2   |   3   |\n *        ——————————————————\n *                 6\n */\nfunction adjustLabelPosition(label: IShape, x: number, y: number, index: number) {\n  const { width, height } = label.getCanvasBBox();\n  const attrs = {\n    x,\n    y,\n    textAlign: 'center',\n  };\n  switch (index) {\n    case 0:\n      attrs.y -= height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 1:\n      attrs.y -= height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 2:\n      attrs.y += height + 1;\n      attrs.x -= 1;\n      attrs.textAlign = 'right';\n      break;\n    case 3:\n      attrs.y += height + 1;\n      attrs.x += 1;\n      attrs.textAlign = 'left';\n      break;\n    case 5:\n      attrs.y -= height * 2 + 2;\n      break;\n    case 6:\n      attrs.y += height * 2 + 2;\n      break;\n    case 7:\n      attrs.x += width + 1;\n      attrs.textAlign = 'left';\n      break;\n    case 8:\n      attrs.x -= width + 1;\n      attrs.textAlign = 'right';\n      break;\n    default:\n      break;\n  }\n  label.attr(attrs);\n  return label.getCanvasBBox();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：在不改变 label 位置的情况下对相互重叠的 label 进行调整。\n * 不同于 'overlap' 类型的布局，该布局不会对 label 的位置进行偏移调整。\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function fixedOverlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    if (!spiralFill(labelShape, greedy)) {\n      label.remove(true);\n    }\n  });\n  greedy.destroy();\n}\n\n/**\n * @ignore\n * label 防遮挡布局：为了防止 label 之间相互覆盖同时保证尽可能多 的 label 展示，通过尝试将 label 向**四周偏移**来剔除放不下的 label\n * @param labels 参与布局调整的 label 数组集合\n */\nexport function overlap(items: LabelItem[], labels: IGroup[], shapes: IShape[] | IGroup[], region: BBox) {\n  const greedy = new Greedy();\n  each(labels, (label: IGroup) => {\n    const labelShape = label.find((shape) => shape.get('type') === 'text') as IShape;\n    const { x, y } = labelShape.attr();\n    let canFill = false;\n    for (let i = 0; i <= 8; i++) {\n      const bbox = adjustLabelPosition(labelShape, x, y, i);\n      if (greedy.hasGap(bbox)) {\n        greedy.fillGap(bbox);\n        canFill = true;\n        break;\n      }\n    }\n    if (!canFill) {\n      label.remove(true);\n    }\n  });\n\n  greedy.destroy();\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}