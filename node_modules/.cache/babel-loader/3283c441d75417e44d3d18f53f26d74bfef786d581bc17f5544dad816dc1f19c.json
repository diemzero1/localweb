{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCoreNodeAndRelativeLeafNodes = exports.getAvgNodePosition = exports.getLayoutBBox = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegreeMap = exports.getDegree = exports.getEdgeTerminal = void 0;\nvar array_1 = require(\"./array\");\nvar number_1 = require(\"./number\");\nvar object_1 = require(\"./object\");\nvar getEdgeTerminal = function getEdgeTerminal(edge, type) {\n  var terminal = edge[type];\n  if ((0, object_1.isObject)(terminal)) {\n    return terminal.cell;\n  }\n  return terminal;\n};\nexports.getEdgeTerminal = getEdgeTerminal;\nvar getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n  for (var i = 0; i < n; i++) {\n    degrees[i] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  }\n  if (!edges) return degrees;\n  edges.forEach(function (e) {\n    var source = (0, exports.getEdgeTerminal)(e, 'source');\n    var target = (0, exports.getEdgeTerminal)(e, 'target');\n    if (source && degrees[nodeIdxMap[source]]) {\n      degrees[nodeIdxMap[source]].out += 1;\n      degrees[nodeIdxMap[source]].all += 1;\n    }\n    if (target && degrees[nodeIdxMap[target]]) {\n      degrees[nodeIdxMap[target]].in += 1;\n      degrees[nodeIdxMap[target]].all += 1;\n    }\n  });\n  return degrees;\n};\nexports.getDegree = getDegree;\nvar getDegreeMap = function getDegreeMap(nodes, edges) {\n  var degreesMap = {};\n  nodes.forEach(function (node) {\n    degreesMap[node.id] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  });\n  if (!edges) return degreesMap;\n  edges.forEach(function (e) {\n    var source = (0, exports.getEdgeTerminal)(e, 'source');\n    var target = (0, exports.getEdgeTerminal)(e, 'target');\n    if (source) {\n      degreesMap[source].out += 1;\n      degreesMap[source].all += 1;\n    }\n    if (target) {\n      degreesMap[target].in += 1;\n      degreesMap[target].all += 1;\n    }\n  });\n  return degreesMap;\n};\nexports.getDegreeMap = getDegreeMap;\nvar floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\nexports.floydWarshall = floydWarshall;\nvar getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n    edges = data.edges;\n  var matrix = [];\n  // map node with index in data.nodes\n  var nodeMap = {};\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n  edges === null || edges === void 0 ? void 0 : edges.forEach(function (e) {\n    var source = (0, exports.getEdgeTerminal)(e, 'source');\n    var target = (0, exports.getEdgeTerminal)(e, 'target');\n    var sIndex = nodeMap[source];\n    var tIndex = nodeMap[target];\n    if (sIndex === undefined || tIndex === undefined) return;\n    matrix[sIndex][tIndex] = 1;\n    if (!directed) {\n      matrix[tIndex][sIndex] = 1;\n    }\n  });\n  return matrix;\n};\nexports.getAdjMatrix = getAdjMatrix;\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nvar scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\nexports.scaleMatrix = scaleMatrix;\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n  if (!fn(data)) {\n    return false;\n  }\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\nvar traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n  traverseUp(data, fn);\n};\nexports.traverseTreeUp = traverseTreeUp;\n/**\n * calculate the bounding box for the nodes according to their x, y, and size\n * @param nodes nodes in the layout\n * @returns\n */\nvar getLayoutBBox = function getLayoutBBox(nodes) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var maxX = -Infinity;\n  var maxY = -Infinity;\n  nodes.forEach(function (node) {\n    var size = node.size;\n    if ((0, array_1.isArray)(size)) {\n      if (size.length === 1) size = [size[0], size[0]];\n    } else if ((0, number_1.isNumber)(size)) {\n      size = [size, size];\n    } else if (size === undefined || isNaN(size)) {\n      size = [30, 30];\n    }\n    var halfSize = [size[0] / 2, size[1] / 2];\n    var left = node.x - halfSize[0];\n    var right = node.x + halfSize[0];\n    var top = node.y - halfSize[1];\n    var bottom = node.y + halfSize[1];\n    if (minX > left) minX = left;\n    if (minY > top) minY = top;\n    if (maxX < right) maxX = right;\n    if (maxY < bottom) maxY = bottom;\n  });\n  return {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  };\n};\nexports.getLayoutBBox = getLayoutBBox;\n/**\n * 获取节点集合的平均位置信息\n * @param nodes 节点集合\n * @returns 平局内置\n */\nvar getAvgNodePosition = function getAvgNodePosition(nodes) {\n  var totalNodes = {\n    x: 0,\n    y: 0\n  };\n  nodes.forEach(function (node) {\n    totalNodes.x += node.x || 0;\n    totalNodes.y += node.y || 0;\n  });\n  // 获取均值向量\n  var length = nodes.length || 1;\n  return {\n    x: totalNodes.x / length,\n    y: totalNodes.y / length\n  };\n};\nexports.getAvgNodePosition = getAvgNodePosition;\n// 找出指定节点关联的边的起点或终点\nvar getCoreNode = function getCoreNode(type, node, edges) {\n  var _a, _b;\n  if (type === 'source') {\n    return ((_a = edges === null || edges === void 0 ? void 0 : edges.find(function (edge) {\n      return edge.target === node.id;\n    })) === null || _a === void 0 ? void 0 : _a.source) || {};\n  }\n  return ((_b = edges === null || edges === void 0 ? void 0 : edges.find(function (edge) {\n    return edge.source === node.id;\n  })) === null || _b === void 0 ? void 0 : _b.target) || {};\n};\n// 找出指定节点为起点或终点的所有一度叶子节点\nvar getRelativeNodeIds = function getRelativeNodeIds(type, coreNode, edges) {\n  var relativeNodes = [];\n  switch (type) {\n    case 'source':\n      relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) {\n        return edge.source === coreNode.id;\n      }).map(function (edge) {\n        return edge.target;\n      });\n      break;\n    case 'target':\n      relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) {\n        return edge.target === coreNode.id;\n      }).map(function (edge) {\n        return edge.source;\n      });\n      break;\n    case 'both':\n      relativeNodes = edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) {\n        return edge.source === coreNode.id;\n      }).map(function (edge) {\n        return edge.target;\n      }).concat(edges === null || edges === void 0 ? void 0 : edges.filter(function (edge) {\n        return edge.target === coreNode.id;\n      }).map(function (edge) {\n        return edge.source;\n      }));\n      break;\n    default:\n      break;\n  }\n  // 去重\n  var set = new Set(relativeNodes);\n  return Array.from(set);\n};\n// 找出同类型的节点\nvar getSameTypeNodes = function getSameTypeNodes(type, nodeClusterBy, node, relativeNodes, degreesMap) {\n  // @ts-ignore\n  var typeName = node[nodeClusterBy] || '';\n  // @ts-ignore\n  var sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter(function (item) {\n    return item[nodeClusterBy] === typeName;\n  })) || [];\n  if (type === 'leaf') {\n    sameTypeNodes = sameTypeNodes.filter(function (node) {\n      var _a, _b;\n      return ((_a = degreesMap[node.id]) === null || _a === void 0 ? void 0 : _a.in) === 0 || ((_b = degreesMap[node.id]) === null || _b === void 0 ? void 0 : _b.out) === 0;\n    });\n  }\n  return sameTypeNodes;\n};\n// 找出与指定节点关联的边的起点或终点出发的所有一度叶子节点\nvar getCoreNodeAndRelativeLeafNodes = function getCoreNodeAndRelativeLeafNodes(type, node, edges, nodeClusterBy, degreesMap, nodeMap) {\n  var _a = degreesMap[node.id],\n    inDegree = _a.in,\n    outDegree = _a.out;\n  var coreNode = node;\n  var relativeLeafNodes = [];\n  if (inDegree === 0) {\n    // 如果为没有出边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('source', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map(function (nodeId) {\n      return nodeMap[nodeId];\n    });\n  } else if (outDegree === 0) {\n    // 如果为没有入边边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('target', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map(function (nodeId) {\n      return nodeMap[nodeId];\n    });\n  }\n  relativeLeafNodes = relativeLeafNodes.filter(function (node) {\n    return degreesMap[node.id] && (degreesMap[node.id].in === 0 || degreesMap[node.id].out === 0);\n  });\n  var sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);\n  return {\n    coreNode: coreNode,\n    relativeLeafNodes: relativeLeafNodes,\n    sameTypeLeafNodes: sameTypeLeafNodes\n  };\n};\nexports.getCoreNodeAndRelativeLeafNodes = getCoreNodeAndRelativeLeafNodes;","map":{"version":3,"mappings":"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","names":["getEdgeTerminal","edge","type","terminal","cell","exports","getDegree","n","nodeIdxMap","edges","degrees","i","in","out","all","forEach","e","source","target","getDegreeMap","nodes","degreesMap","node","id","floydWarshall","adjMatrix","dist","size","length","j","Infinity","k","getAdjMatrix","data","directed","matrix","nodeMap","Error","row","push","sIndex","tIndex","undefined","scaleMatrix","ratio","result","newRow","v","traverseUp","fn","children","traverseTreeUp","getLayoutBBox","minX","minY","maxX","maxY","isNaN","halfSize","left","x","right","top","y","bottom","getAvgNodePosition","totalNodes","getCoreNode","find","getRelativeNodeIds","coreNode","relativeNodes","filter","map","concat","set","Set","Array","from","getSameTypeNodes","nodeClusterBy","typeName","sameTypeNodes","item","getCoreNodeAndRelativeLeafNodes","inDegree","outDegree","relativeLeafNodes","nodeId","sameTypeLeafNodes"],"sources":["/home/iam/Documents/LocalWeb-master/node_modules/@antv/layout/src/util/math.ts"],"sourcesContent":["import { Matrix, Model, IndexMap, Edge, Node, OutNode, Degree, NodeMap } from '../layout/types';\nimport { isArray } from './array';\nimport { isNumber } from './number';\nimport { isObject } from './object';\n\nexport const getEdgeTerminal = (edge: Edge, type: 'source' | 'target') => {\n  const terminal = edge[type];\n  if (isObject(terminal)) {\n    return terminal.cell;\n  }\n  return terminal;\n};\n\nexport const getDegree = (n: number, nodeIdxMap: IndexMap, edges: Edge[] | null) => {\n  const degrees: Degree[] = [];\n  for (let i = 0; i < n; i++) {\n    degrees[i] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  }\n  if (!edges) return degrees;\n  edges.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    if (source && degrees[nodeIdxMap[source]]) {\n      degrees[nodeIdxMap[source]].out += 1;\n      degrees[nodeIdxMap[source]].all += 1;\n    }\n    if (target && degrees[nodeIdxMap[target]]) {\n      degrees[nodeIdxMap[target]].in += 1;\n      degrees[nodeIdxMap[target]].all += 1;\n    }\n  });\n  return degrees;\n};\n\nexport const getDegreeMap = (nodes: Node[], edges: Edge[] | null) => {\n  const degreesMap: { [id: string]: Degree } = {};\n  nodes.forEach((node) => {\n    degreesMap[node.id] = {\n      in: 0,\n      out: 0,\n      all: 0\n    };\n  });\n\n  if (!edges) return degreesMap;\n  edges.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    if (source) {\n      degreesMap[source].out += 1;\n      degreesMap[source].all += 1;\n    }\n    if (target) {\n      degreesMap[target].in += 1;\n      degreesMap[target].all += 1;\n    }\n  });\n  return degreesMap;\n};\n\nexport const floydWarshall = (adjMatrix: Matrix[]): Matrix[] => {\n  // initialize\n  const dist: Matrix[] = [];\n  const size = adjMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n\nexport const getAdjMatrix = (data: Model, directed: boolean): Matrix[] => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix: Matrix[] = [];\n  // map node with index in data.nodes\n  const nodeMap: {\n    [key: string]: number;\n  } = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row: number[] = [];\n      matrix.push(row);\n    });\n  }\n\n  edges?.forEach((e) => {\n    const source = getEdgeTerminal(e, 'source');\n    const target = getEdgeTerminal(e, 'target');\n    const sIndex = nodeMap[source as string];\n    const tIndex = nodeMap[target as string];\n    if (sIndex === undefined || tIndex === undefined) return;\n    matrix[sIndex][tIndex] = 1;\n    if (!directed) {\n      matrix[tIndex][sIndex] = 1;\n    }\n  });\n  return matrix;\n};\n\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\nexport const scaleMatrix = (matrix: Matrix[], ratio: number) => {\n  const result: Matrix[] = [];\n  matrix.forEach((row) => {\n    const newRow: number[] = [];\n    row.forEach((v) => {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\nconst traverseUp = <T extends { children?: T[] }>(data: T, fn: (param: T) => boolean) => {\n  if (data && data.children) {\n    for (let i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (!fn(data)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\nexport const traverseTreeUp = <T extends { children?: T[] }>(\n  data: T,\n  fn: (param: T) => boolean,\n) => {\n  if (typeof fn !== 'function') {\n    return;\n  }\n  traverseUp(data, fn);\n};\n\n/**\n * calculate the bounding box for the nodes according to their x, y, and size\n * @param nodes nodes in the layout\n * @returns \n */\nexport const getLayoutBBox = (nodes: OutNode[]) => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  nodes.forEach((node) => {\n    let size = node.size;\n    if (isArray(size)) {\n      if (size.length === 1) size = [size[0], size[0]];\n    }  else if (isNumber(size)) {\n      size = [size, size];\n    } else if (size === undefined || isNaN(size as any)) {\n      size = [30, 30];\n    }\n\n    const halfSize = [size[0] / 2, size[1] / 2];\n    const left = node.x - halfSize[0];\n    const right = node.x + halfSize[0];\n    const top = node.y - halfSize[1];\n    const bottom = node.y + halfSize[1];\n\n    if (minX > left) minX = left;\n    if (minY > top) minY = top;\n    if (maxX < right) maxX = right;\n    if (maxY < bottom) maxY = bottom;\n  });\n  return { minX, minY, maxX, maxY };\n};\n\n/**\n * 获取节点集合的平均位置信息\n * @param nodes 节点集合\n * @returns 平局内置\n */\nexport const getAvgNodePosition = (nodes: OutNode[]) => {\n  const totalNodes = { x: 0, y: 0 };\n  nodes.forEach((node) => {\n    totalNodes.x += node.x || 0;\n    totalNodes.y += node.y || 0;\n  });\n  // 获取均值向量\n  const length = nodes.length || 1;\n  return {\n    x: totalNodes.x / length,\n    y: totalNodes.y / length,\n  };\n};\n\n// 找出指定节点关联的边的起点或终点\nconst getCoreNode = (type: 'source' | 'target', node: Node, edges: Edge[]) => {\n  if (type === 'source') {\n    return (edges?.find((edge) => edge.target === node.id)?.source || {}) as Node;\n  }\n  return (edges?.find((edge) => edge.source === node.id)?.target || {}) as Node;\n};\n\n// 找出指定节点为起点或终点的所有一度叶子节点\nconst getRelativeNodeIds = (type: 'source' | 'target' | 'both', coreNode: Node, edges: Edge[]) => {\n  let relativeNodes: string[] = [];\n  switch (type) {\n    case 'source':\n      relativeNodes = edges?.filter((edge) => edge.source === coreNode.id).map((edge) => edge.target);\n      break;\n    case 'target':\n      relativeNodes = edges?.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source);\n      break;\n    case 'both':\n      relativeNodes = edges\n        ?.filter((edge) => edge.source === coreNode.id)\n        .map((edge) => edge.target)\n        .concat(edges?.filter((edge) => edge.target === coreNode.id).map((edge) => edge.source));\n      break;\n    default:\n      break;\n  }\n  // 去重\n  const set = new Set(relativeNodes);\n  return Array.from(set);\n};\n// 找出同类型的节点\nconst getSameTypeNodes = (type: 'leaf' | 'all', nodeClusterBy: string, node: Node, relativeNodes: Node[], degreesMap: { [id: string]: Degree }) => {\n  // @ts-ignore\n  const typeName = node[nodeClusterBy] || '';\n  // @ts-ignore\n  let sameTypeNodes = relativeNodes?.filter((item) => item[nodeClusterBy] === typeName) || [];\n  if (type === 'leaf') {\n    sameTypeNodes = sameTypeNodes.filter((node) => degreesMap[node.id]?.in === 0 ||degreesMap[node.id]?.out === 0);\n  }\n  return sameTypeNodes;\n};\n\n\n// 找出与指定节点关联的边的起点或终点出发的所有一度叶子节点\nexport const getCoreNodeAndRelativeLeafNodes = (type: 'leaf' | 'all', node: Node, edges: Edge[], nodeClusterBy: string, degreesMap: { [id: string]: Degree }, nodeMap: NodeMap) => {\n  const { in: inDegree, out: outDegree } = degreesMap[node.id];\n  let coreNode: Node = node;\n  let relativeLeafNodes: Node[] = [];\n  if (inDegree === 0) {\n    // 如果为没有出边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('source', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);\n  } else if (outDegree === 0) {\n    // 如果为没有入边边的叶子节点，则找出与它关联的边的起点出发的所有一度节点\n    coreNode = getCoreNode('target', node, edges);\n    relativeLeafNodes = getRelativeNodeIds('both', coreNode, edges).map((nodeId) => nodeMap[nodeId]);\n  }\n  relativeLeafNodes = relativeLeafNodes.filter(\n    (node) => degreesMap[node.id] && (degreesMap[node.id].in === 0 || degreesMap[node.id].out === 0),\n  );\n  const sameTypeLeafNodes = getSameTypeNodes(type, nodeClusterBy, node, relativeLeafNodes, degreesMap);\n  return { coreNode, relativeLeafNodes, sameTypeLeafNodes };\n};"]},"metadata":{},"sourceType":"script","externalDependencies":[]}